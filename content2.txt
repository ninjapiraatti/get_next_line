 SECOND EDITION
THE
BRIAN W KERNIGHAN DENNIS M. RITCHIE
PRENTICE HALL SOFTWARE SERIES

 
 THE
c
PROGRAMMING LANGUAGE
Second Edition

 
 THE
c
PROGRAMMING LANGUAGE
Second Edition
Brian W. Kernighan • Dennis M. Ritchie
AT& T Bell Laboratories Murray Hill, New Jersey
PRENTICE HALL, Englewood Cliffs, New Jersey 07632

 Ubrary of Congress Cataloging-in-Publication Data Kernighan, Brian W.
The C programming language.
Includes index.
1. C (Computer program language) I. Ritchie, Dennis M. II. Title. QA76.73.C15K47 1988 005.13'3 88-5934 ISBN 0-13-110370-9
ISBN 0-13-110362-8 (pbk.)
Copyrighte 1988,1978byBellTelephoneLaboratories,Incorporated.
All rights reserved. No part of this publication may be reproduced, stored in a retrieval system, or transmitted, in any form or by any means, electronic, mechanical, photocopy- ing, recording, or otherwise, without the prior written permission of the publisher. PrintedintheUnitedStatesofAmerica. PublishedsimultaneouslyinCanada.
UNIX is a registered trademark of AT&T.
Thisbookwastypeset(picItblleqnItroff -ms)inTimesRomanandCourierby the authors, using an Autologic APS-5 phototypesetter and a DEC VAX 8550 running the 9th Edition of the UNIX. operating system.
Prentice Hall Software Series Brian Kernighan, Advisor
Printed in the United States of America 10 9 8 7
ISBN 0-13-110362-8 {PBK} ISBN 0-l3-110370-9
International (UK) Limited, London of Australia Pty. Limited, Sydney Canada Inc., Toronto Hispanoamericana, S. A. , Mexico
Prentice-Hall
Prentice-Hall
Prentice-Hall
Prentice-Hall
Prentice-Hall
Prentice-Hall
Simon & Schuster Asia Pte. Ltd., Singapore
Editora Prentice-Hall do Brasil, Ltda., Rio de Janeiro
of India Private Limited, New Delhi of Japan, Inc., Tokyo

 Contents
Preface ix Preface to the First Edition xi Introduction I
Chapter I. A Tutorial Introduction 5 1.1 Getting Started 5 1.2 Variables and Arithmetic Expressions 8 1.3 The For Statement 13 1.4 Symbolic Constants 14 1.5 Character Input and Output 15
22
1.6 Arrays
1.7 Functions
1.8 Arguments-Call
1.9 Character Arrays
1.10External Variables and Scope 31
24 by Value 27 28
Chapter 2. Types, Operators, and Expressions 35 2.1 Variable Names 35 2.2 Data Types and Sizes 36 2.3 Constants 37 2.4 Declarations 40 2.5 Arithmetic Operators 41 2.6 Relational and Logical Operators 41 2.7 Type Conversions 42 2.8 Increment and Decrement Operators 46 2.9 Bitwise Operators 48 2.10 Assignment Operators and Expressions 50
51 2.12 Precedence and Order of Evaluation 52
2.11 Conditional Expressions Chapter 3. Control Flow
3.1 Statements and Blocks 3.2 If-Else
55
55 55
,

 vi THE C PROGRAMMING
LANGUAGE
CONTENTS
3.3 Else-If
3.4 Switch
3.5 Loops- While and For 60 3.6 Loops- Do-while 63 3.7 Break and Continue 64 3.8 Goto and Labels 65
Chapter 4. Functionsand Program Structure 67
4.1 Basicsof Functions 67
4.2 Functions Returning Non-integers 71
4.3 External Variables 73
4.4 ScopeRules 80
4.5 Header Files 81
4.6 Static Variables 83
4.7 Register Variables 83
4.8 BlockStructure 84
4.9 Initialization 85
4.10 Recursion 86 4.11 The C Preprocessor 88
Chapter5. PointersandArrays 93 5.1 Pointers and Addresses 93 5.2 Pointers and Function Arguments 95 5.3 Pointers and Arrays 97 5.4 AddressArithmetic 100 5.5 Character Pointers and Functions 104 5.6 Pointer Arrays; Pointers to Pointers 107 5.7 Multi-dimensionalArrays 110 5.8 Initialization of Pointer Arrays 113 5.9 Pointersvs.Multi-dimensionalArrays 113 5.10 Command-line Arguments 114 5.11 Pointers to Functions 118 5.12 Complicated Declarations 122
Chapter6. Structures 127 6.1 Basicsof Structures 127 6.2 Structures and Functions 129 6.3 Arrays of Structures 132 6.4 Pointers to Structures 136 6.5 Self-referential Structures 139 6.6 Table Lookup 143 6.7 Typedef 146 6.8 Unions 147 6.9 Bit-fields 149
Chapter7. InputandOutput 151 7.1 Standard Input and Output 151 7.2 Formatted Output-Printf 153
57
58

 THE C PROGRAMMING LANGUAGE
CONTENTS vi
7.3 Variable-length Argument Lists 7.4 Formatted Input-Scanf
7.5 File Access
7.6 Error Handling-Stderr
7.7 Line Input and Output
7.8 Miscellaneous Functions
Chapter 8. The UNIX System Interface
8.1 File Descriptors
8.2 Low Level I/O-Read and Write
8.3 Open, Creat, Close, Unlink
8.4 Random Access- Lseek
8.5 Example-An Implementation of Fopen and Getc
8.6 Example - Listing Directories
8.7 Example- A Storage Allocator Appendix A. Reference Manual
 155
 157
 160
 163
 164
 166
169
169 170 172 174 175 179 185
191
191 191 194 195~ 197 197
200
210
222
225
227
228
234
241
241
248
249
250
251
253
254
254
255
255
257
259 263
A 1
A2
A3
A4
A5
A6
A 7
A8
A9
AI0 External Declarations A 11 Scope and Linkage
Introduction
Lexical Conventions Syntax Notation Meaning of Identifiers Objects and Lvalues Conversions Expressions Declarations Statements
A 12 Preprocessing A13 Grammar
Appendix B. Standard Library
Bl Input and Output: <stdio.h>
B2 Character Class Tests: <ctype.h>
B3 String Functions: < string.h >
B4 Mathematical Functions: <rnath.h>
B5 Utility Functions: <stdlib.h>
B6 Diagnostics: < assert.h >
B7 Variable Argument Lists: <stdarg.h>
B8 Non-local Jumps: <setjmp.h>
B9 Signals: <signal.h>
BIODate and Time Functions: < time.h >
Bll Implementation-defined Limits: <limits.h> and <float.h>
Appendix C. Summary of Changes Index
and Exit

 
 Preface
The computing world has undergone a revolution since the publication of The C Programming Language in 1978. Big computers are much bigger, and personal computers have capabilities that rival the mainframes of a decade ago. During this time, C has changed too, although only modestly, and it has spread
far beyond its origins as the language of the UNIX operating system.
The growing popularity of C, the changes in the language over the years, and the creation of compilers by groups not involved in its design, combined to
demonstrate a need for a more precise and more contemporary definition of the language than the first edition of this book provided. In 1983, the American ' National Standards Institute (ANSI) established a committee whose goal was to produce "an unambiguous and machine-independent definition of the language C," while still retaining its spirit. The result is the ANSI standard for C.
The standard formalizes constructions that were hinted at but not described in the first edition, particularly structure assignment and enumerations. It pro- vides a new form of function declaration that permits cross-checking of defini- tion with use. It specifiesa standard library, with an extensiveset of functions for performing input and output, memory management, string manipulation, and similar tasks. It makes precise the behavior of features that were not spelled out in the original definition, and at the same time states explicitly which aspects of the language remain machine-dependent.
This second edition of The C Programming Language describes C as defined by the ANSI standard. Although we have noted the places where the language has evolved,we have chosen to write exclusivelyin the new form. For the most part, this makes no significant difference; the most visible change is the new form of function declaration and definition. Modern compilers already support most features of the standard.
We have tried to retain the brevity of the first edition. C is not a big language, and it is not well served by a big book. We have improved the exposi- tion of critical features, such as pointers, that are central to C programming. We have refined the original examples, and have added new examples in several chapters. For instance, the treatment of complicated declarations is augmented by programs that convert declarations into words and vice versa. As before, all
Ix

 X PREFACE
examples have been tested directly from the text, which is in machine-readable form.
Appendix A, the reference manual, is not the standard, but our attempt to convey the essentials of the standard in a smaller space. It is meant for easy comprehension by programmers, but not as a definition for compiler writers- that role properly belongs to the standard itself. Appendix B is a summary of the facilities of the standard library. It too is meant for reference by program- mers, not implementers. Appendix C is a concise summary of the changes from the original version.
As we said in the preface to the first edition, C "wears well as one's experi- ence with it grows." With a decade more experience, we still feel that way. We hope that this book will help you to learn C and to use it well.
We are deeply indebted to friends who helped us to produce this second edi- tion. Jon Bentley, Doug Gwyn, Doug Mcllroy, Peter Nelson, and Rob Pike gave us perceptive comments on almost every page of draft manuscripts. We are grateful for careful reading by Al Aho, Dennis Allison, Joe Campbell, G. R. Emlin, Karen Fortgang, Allen Holub, Andrew Hume, Dave Kristol, John Linderman, Dave Prosser, Gene Spafford, and Chris Van Wyk. We also received helpful suggestions from BHl Cheswick, Mark Kernighan, Andy Koenig, Robin Lake, Tom London, Jim Reeds, Clovis Tondo, and Peter Wein- berger. Dave Prosser answered many detailed questions about the ANSI stand- ard. We used Bjarne Stroustrup's C++ translator extensively for local testing of our programs, and Pave Kristol provided us with an ANSI C compiler for final testing, Rich Drechsler helped greatly with typesetting.
Our sincerethanks to all.
Brian W. Kernighan Dennis M. Ritchie

 Preface to the First Edition
C is a general-purpose programming language which features economy of expression, modern control flow and data structures, and a rich set of operators. C is not a "very high level" language, nor a "big" one, and is not specialized to any particular area of application. But its absence of restrictions and its gen- erality make it more convenient and effective for many tasks than supposedly more powerful languages.
C was originally designed for and implemented on the UNIX operating sys- tem on the DEC PDP-ll, by Dennis Ritchie. The operating system, the C com- piler, and essentially all UNIX applications programs (including all of the software used to prepare this book) are written in C. Production compilers also exist for several other machines, including the IBM System/370, the Honeywell 6000, and the Interdata 8/32. C is not tied to any particular hardware or sys- tem, however, and it is easy to write programs that will run without change on any machine that supports C.
This book is meant to help the reader learn how to program in C. It con- tains a tutorial introduction to get new users started as soon as possible, separate chapters on each major feature, and a reference manual. Most of the treatment is based on reading, writing and revising examples, rather than on mere statements of rules. For the most part, the examples are complete, real programs, rather than isolated fragments. All examples have been tested directlyfromthetext,whichisinmachine-readableform. Besidesshowinghow to make effective use of the language, we have also tried where possible to illus- trate useful algorithms and principles of good style and sound design.
The book is not an introductory programming manual; it assumes some fam- iliarity with basic programming concepts like variables, assignment statements, loops, and functions. Nonetheless, a novice programmer should be able to read along and pick up the language, although access to a more knowledgeablecol- league will help.
In our experience, C has proven to be a pleasant, expressive, and versatile language for a wide variety of programs. It is easy to learn, and it wears well as one's experience with it grows. We hope that this book will help you to use it well.
xi

 xii PREFACE TO THE 1ST EDITION
The thoughtful criticisms and suggestions of many friends and colleagues have added greatly to this book and to our pleasure in writing it. In particular, Mike Bianchi, Jim Blue, Stu Feldman, Doug McIlroy, Bill Roome, Bob Rosin, and Larry Rosier all read multiple versions with care. We are also indebted to Al Aho, Steve Bourne, Dan Dvorak, Chuck Haley, Debbie Haley, Marion Harris, Rick Holt, Steve Johnson, John Mashey, Bob Mitze, Ralph Muha, Peter Nelson, Elliot Pinson, Bill PIauger, Jerry Spivack, Ken Thompson, and Peter Weinberger for helpful comments at various stages, and to Mike Lesk and Joe Ossanna for invaluable assistance with typesetting.
Brian W. Kernighan Dennis M. Ritchie

 Introduction
C is a general-purpose programming language. It has been closely associ- ated with the UNIX system where it was developed, since both the system and most of the programs that run on it are written in C. The language, however,is not tied to anyone operating system or machine; and although it has been called a "system programming language" because it is useful for writing com- pilers and operating systems, it has been used equally well to write major pro- grams in many different domains.
Many of the important ideas of C stem from the language BCPL, developed by Martin Richards. The influence of BCPL on C proceeded indirectly through the language B, which was written by Ken Thompson in 1970 for the first UNIX system on the DEC PDP-7.
BCPL and Bare "typeless" languages. By contrast, C provides a variety of data types. The fundamental types are characters, and integers and floating- point numbers of several sizes. In addition, there is a hierarchy of derived data types created with pointers, arrays, structures, and unions. Expressions are formed from operators and operands; any expression, including an assignment or a function call, can be a statement. Pointers provide for machine-independent address arithmetic.
C provides the fundamental control-flow constructions required for well- structuredprograms:statementgrouping,decisionmaking(if-else), selecting oneofasetofpossiblecases(switch),loopingwiththeterminationtestatthe top (while, for) or at the bottom (do),and early loopexit (break).
Functions may return values of basic types, structures, unions, or pointers. Any function may be called recursively. Local variables are typically "automatic," or created anew with each invocation. Function definitions may not be nested but variables may be declared in a block-structured fashion. The functions of a C program may exist in separate source files that are compiled separately. Variables may be internal to a function, external but known only within a single source file, or visible to the entire program.
A preprocessing step performs macro substitution on program text, inclusion of other source files, and conditional compilation.
C is a relatively "low level" language. This characterization is not
1

 1 INTRODUCTION
pejorative; it simply means that C deals with the same sort of objects that most computers do, namely characters, numbers, and addresses. These may be com- bined and moved about with the arithmetic and logical operators implemented by real machines.
C provides no operations to deal directly with composite objects such as character strings, sets, lists, or arrays. There are no operations that manipulate an entire array or string, although structures may be copied as a unit. The language does not define any storage allocation facility other than static defini- tion and the stack discipline provided by the local variables of functions; there is no heap or garbage collection. Finally, C itself provides no input/output facili- ties; there are no READ or WRITE statements, and no built-in file access methods. All of these higher-level mechanisms must be provided by explicitly- called functions. Most C implementations have included a reasonably standard collection of such functions.
Similarly, C offers only straightforward, single-thread control flow: tests, loops, grouping, and subprograms, but not multiprogramming, parallel opera- tions, synchronization, or coroutines.
Although the absence of some of these features may seem like a grave defi- ciency ("You mean I have to call a function to compare two character strings?"), keeping the language down to modest size has real benefits. Since C is relatively small, it can be described in a small space, and learned quickly. A programmer can reasonably expect to know and understand and indeed regu- larly use the entire language.
For many years, the definition of C was the reference manual in the first edition of The C Programming Language. In 1983, the American National Standards Institute (ANSI) established a committee to provide a modern, comprehensive definition of C. The resulting definition, the ANSI standard, or "ANSI C," was completed late in 1988. Most of the features of the standard are already supported by modern compilers.
The standard is based on the original reference manual. The language is relatively little changed; one of the goals of the standard was to make sure that most existing programs would remain valid, or, failing that, that compilers could produce warnings of new behavior.
For most programmers, the most important change is a new syntax for declaring and defining functions. A function declaration can now include a description of the arguments of the function; the definition syntax changes to match. This extra information makes it much easier for compilers to detect errors caused by mismatched arguments; in our experience, it is a very useful addition to the language.
There are other small-scale language changes. Structure assignment and enumerations, which had been widely available, are now officially part of the language. Floating-point computations may now be done in single precision. The properties of arithmetic, especially for unsigned types, are clarified. The preprocessor is more elaborate. Most of these changes will have only minor

 effects on most programmers.
A second significant contribution of the standard is the definition of a library
toaccompanyC.Itspecifiesfunctionsforaccessingtheoperatingsystem(for instance, to read and write files), formatted input and output, memory alloca- tion, string manipulation, and the like. A collection of standard headers pro- vides uniform access to declarations of functions and data types. Programs that use this library to interact with a host system are assured of compatible behavior. Most of the library is closely modeled on the "standard 1/0 library" of the UNIX system. This library was described in the first edition, and has been widely used on other systems as well. Again, most programmers will not see much change. .
Because the data types and control structures provided by C are supported directly by most computers, the run-time library required to implement self- contained programs is tiny. The standard library functions are only called explicitly, so they can be avoided if they are not needed. Most can be written in C, and except for the operating system details they conceal, are themselves port- able.
Although C matches the capabilities of many computers, it is independent of any particular machine architecture. With a little care' it is easy to write port- able programs, that is, programs that can be run without change on a variety of hardware. The standard makes portability issues explicit, and prescribes a set of constants that characterize the machine on which the program is run.
C is not a strongly-typed language, but as it has evolved, its type-checking has been strengthened. The original definition of C frowned on, but permitted, the interchange of pointers and integers; this has long since been eliminated, and the standard now requires the proper declarations and explicit conversionsthat had already been enforced by good compilers. The new function declarations are another step in this direction. Compilers will warn of most type errors, and there is no automatic conversion of incompatible data types. Nevertheless, C retains the basic philosophy that programmers know what they are doing; it only requires that they state their intentions explicitly.
C, like any other language, has its blemishes. Some of the operators have the wrong precedence; some parts of the syntax could be better. Nonetheless, C has proven to be an extremely effective and expressive language for a wide variety of programming applications.
The book is organized as follows. Chapter 1 is a tutorial on the central part of C. The purpose is to get the reader started as quickly as possible, since we believe strongly that the way to learn a new language is to write programs in it. The tutorial does assume a working knowledge of the basic elements of pro- gramming; there is no explanation of computers, of compilation, nor of the meaning of an expressionlike n=n+ 1. Although we have tried where possibleto show useful programming techniques, the book is not intended to be a reference work on data structures and algorithms; when forced to make a choice, we have Concentratedon the language.
THE C PROGRAMMING LANGUAGE 3

 4 INTRODUCTION
Chapters 2 through 6 discuss various aspects of C in more detail, and rather more formally, than does Chapter 1, although the emphasis is still on examples of complete programs, rather than isolated fragments. Chapter 2 deals with the basic data types, operators and expressions. Chapter 3 treats control flow: if-else, switcb,while,for, etc. Chapter4coversfunctionsandprogram structure-external variables, scope rules, multiple source files, and so on-and also touches on the preprocessor. Chapter 5 discusses pointers and address arithmetic. Chapter 6 covers structures and unions.
Chapter 7 describes the standard library, which provides a common interface to the operating system. This library is defined by the ANSI standard and is meant to be supported on all machines that support C, so programs that use it for input, output, and other operating system access can be moved from one sys- tem to another without change.
Chapter 8 describes an interface between C programs and the UNIX operat- ing system, concentrating on input/output, the file system, and storage alloca- tion. Although some of this chapter is specific to UNIX systems, programmers who use other systems should still find useful material here, including some insight into how one version of the standard library is implemented, and sugges- tions on portability.
AppendixAcontainsalanguagereferencemanual. Theofficialstatementof the syntax and semantics of C is the ANSI standard itself. That document, however, is intended foremost for compiler writers. The reference manual here conveys the definition of the language more concisely and without the same legalistic style. Appendix B is a summary of the standard library, again for users rather than implementers. Appendix C is a short summary of changes from the original language. In cases of doubt, however, the standard and one's own compiler remain the final authorities on the language.

 CHAPTER 1: A Tutorial Introduction
Let us begin with a quick introduction to C. Our aim is to show the essen- tial elements of the language in real programs, but without getting bogged down in details, rules, and exceptions. At this point, we are not trying to be complete or even precise (save that the examples are meant to be correct). We want to get you as quickly as possible to the point where you can write useful programs, and to do that we have to concentrate on the basics: variables and constants, arithmetic, control flow, functions, and the rudiments of input and output. We are intentionally leaving out of this chapter features of C that are important for writing bigger programs. These include pointers, structures, most of C's rich set of operators, several control-flow statements, and the standard library.
This approach has its drawbacks. Most notable is that the complete story on any particular language feature is not found here, and the tutorial, by being brief, may also be misleading. And because the examples do not use the full power of C, they are not as concise and elegant as they might be. We have tried to minimize these effects, but be warned. Another drawback is that later chapters will necessarily repeat some of this chapter. We hope that the repeti- tion will help you more than it annoys.
In any case, experienced programmers should be able to extrapolate from the material in this chapter 'to their own programming needs. Beginners should sup- plement it by writing small, similar programs of their own. Both groups can use it as a framework on which to hang the more detailed descriptions that begin in Chapter 2.
1. 1 Getting Started
The only way to learn a new programming language is by writing programs
in it. The first program to write is the same for all languages: Print the words
hello, world
This is the big hurdle; to leap over it you have to be able to create the program s

 6 A TUTORIAL INTRODUCTION CHAPTER 1
text somewhere, compile it successfully, load it, run it, and find out where your output went. With these mechanical details mastered, everything else is com- paratively easy.
InC,theprogramtoprint"hello,world"is
#include <stdio.h>
maine )
{
}
Just how to run this program depends on the system you are using. As a specific example, on the UNIX operating system you must create the program in afilewhosenameendsin".c",suchashello.c,thencompileitwiththe command
cc hello.c
If you haven't botched anything, such as omitting a character or misspelling something,the compilation will proceed silently, and make an executable file called a. out. If you run a. out by typing the command
a.out
it will print
hello, world
On other systems, the rules will be different; check with a local expert.
Now for some explanations about the program itself. A C program, what- ever its .size, consists of functions and variables. A function contains state- ments that specify the computing operations to be done, and variables store values used during the computation. C functions are like the subroutines and functions of Fortran or the procedures and functions of Pascal. Our example is a function named.main. Normally you are at liberty to give functions whatever names you like, but "main" is special-your program begins executing at the
beginning of main. This means that every program must have a main some- where.
main will usually call other functions to help perform its job, some that you wrote, and others from libraries that are provided for you. The first line of the program,
#include <stdio.h>
tells the compiler to include information about the standard input/output library; this line appears at the beginning of many C source files. The standard library is described in Chapter 7 and Appendix B.
One method of communicating data between functions is for the calling function to provide a list of values, called arguments, to the function it calls. The parentheses after the function name surround the argument list. In this
printf("hello, world\n");

 SECTION 1.1 GETTING STARTED 7
#include <stdio.h> include information about standard library maine) defineaJunctionnamedmain
that receives no argument values { statementsojmainareenclosedinbraces
}
printf( "hello, world\n"); maincallslibraryJunctionprintf to print this sequence oj characters; \n representsthenewlinecharacter
The first C program.
example,mainisdefinedtobeafunctionthatexpectsnoarguments,whichis indicated by the empty list ( ).
Thestatementsofafunctionareenclosedinbraces{}.Thefunctionmain contains only one statement,
printf( "hello, world\n");
A function is called by naming it, followedby a parenthesized list of arguments, so this calls the function printf with the argument "hello, world\n". printf isalibraryfunctionthatprintsoutput,inthiscasethestringofchar- acters between the quotes.
Asequenceofcharactersindoublequotes,like"hello,world\n",is called a character string or string constant. For the moment our only use of characterstringswillbeasargumentsforprintf andotherfunctions.
Thesequence\n inthestringisCnotationforthenewlinecharacter,which when printed advances the output to the left margin on the next line. If you leaveoutthe\n (aworthwhileexperiment),youwillfindthatthereisnoline advance after the output is printed. You must use \n to include a newline characterintheprintf argument;ifyoutrysomethinglike
printf("hello, world
");
the C compiler will produce an error message.
printf neversuppliesanewlineautomatically,soseveralcallsmaybeused
to build up an output line in stages. Our "first program could just as well have been written

 8 A TUTORIAL INTRODUCTION
CHAPTER 1
#include <stdio.h>
maine ) {
printf("hello, "); printf("world"); printf ("'n");
}
to produce identical output.
Notice that \n represents only a single character. An escape sequence like
\n provides a general and extensible mechanism for representing hard-to-type orinvisiblecharacters.AmongtheothersthatCprovidesare\tfortab,\b for backspace, \ n for the double quote, and \ \ for the backslash itself. There is a complete list in Section 2.3.
Exercise 1-1. Run the "hello, world" program on your system. Experiment withleavingoutpartsoftheprogram,toseewhaterrormessagesyouget. 0
Exercise 1-2. Experiment to find out what happens when printf's argument string contains \c, where c is some character not listed above. 0
1.2 Variables and Arithmetic Expressions
The next program uses the formula 0C - (519)(0 F-32) to print the follow- ing table of Fahrenheit temperatures and their centigrade or Celsius equivalents:
o -17 20 -6 40 4 60 15 80 26 100 37 120 48 140 60 160 71 180 82 200 93 220 104 240 115 260 126 280 137 300 148
The program itself still consists of the definition of a single function named main. It is longer than the one that printed "hello, world", but not compli- cated. It introduces several new ideas, including comments, declarations, vari- ables, arithmetic expressions, loops, and formatted output.

 SECTION 1.2 VARIABLES AND ARITHMETIC EXPRESSIONS 9
} }
The two lines
#include <stdio.h>
1* print Fahrenheit-Celsius table for fahr = 0, 20, ..., 300*1
maine )
{
int fahr, celsius;
int lower, upper, step;
lower = 0; upper = 300; step = 20;
1* lower limit of temperature table *1 1* upper limit *1
1* step size *1
fahr = lower;
while (fahr <= upper) {
celsius = 5 * (fahr-32) I 9; printf(""d\t%d\n", fahr, celsius); fahr = fahr + step;
1* print Fahrenheit-Celsius table for fahr = 0, 20, ..., 300*1
are a comment, which in this case explains briefly what the program does. Any charactersbetween1*and*1areignoredbythecompiler;theymaybeused freely to make a program easier to understand. Comments may appear any- where a blank or tab or newline can.
In C, all variables must be declared before they are used, usually at the beginning of the function before any executable statements. A declaration announces the properties of variables; it consists of a type name and a list of variables, such as
int fahr, celsius;
int lower, upper, step;
The type int means that the variables listed are integers, by contrast with f loa t, which means floating point, i.e., numbers that may have a fractional part. The range of both int and float depends on the machine you are using; 16-bit ints, which lie between -32768 and +32767, are common, as are 32-bit ints. A float number is typically a 32-bit quantity, with at least six significant digits and magnitude generally between about 10-38 and 10+38•
C provides several other basic data types besides int and f loa t, including:
char character - a single byte short short integer
long long integer
double double-precision floating point

 10 A TUTORIAL INTRODUCTION CHAPTER 1
The sizes of these objects are also machine-dependent. There are also arrays, structures and unions of these basic types, pointers to them, and junctions that return them, all of which we will meet in due course.
Computation in the temperature conversion program begins with the assign- ment statements
lower =0; upper =300; step =20; fahr =lower;
which set the variables to their initial values. Individual statements are ter- minated by semicolons.
Each line of the table is computed the same way, so we use a loop that repeatsonceperoutputline;thisisthepurposeofthewhile loop
while (fahr <= upper) { }
Thewhile loopoperatesasfollows:Theconditioninparenthesesistested. If itistrue {fahr islessthanorequaltoupper},thebodyoftheloop{thethree statements enclosed in braces} is executed. Then the condition is re-tested, and iftrue,thebodyisexecutedagain.Whenthetestbecomesfalse{fahrexceeds upper}theloopends,andexecutioncontinuesatthestatementthatfollowsthe loop. There are no further statements in this program, so it terminates.
Thebodyofawhile canbeoneormorestatementsenclosedinbraces,as in the temperature converter, or a single statement without braces, as in
while (i < j) i =2* i;
Ineithercase,wewillalwaysindentthestatementscontrolledbythewhile by one tab stop {which we have shown as four spaces} so you can see at a glance which statements are inside the loop. The indentation emphasizes the logical structure of the program. Although C compilers do not care about how a pro- gram looks, proper indentation and spacing are critical in making programs easy for people to read. We recommend writing only one statement per line, and using blanks around operators to clarify grouping. The position of braces is less important, although people hold passionate beliefs. We have chosen one of several popular styles. Pick a style that suits you, then use it consistently.
Most of the work gets done in the body of the loop. The Celsius tempera- tureiscomputedandassignedtothevariablecelsius bythestatement
celsius =5 * (fahr-32) / 9;
The reason for multiplying by 5 and then dividing by 9 instead of just multiply- ingby5/9isthatinC,asinmanyotherlanguages,integerdivisiontruncates: any fractional part is discarded. Since 5 and 9 are integers, 5/9 would be truncated to zero and so all the Celsius temperatures would be reported as zero.

 SECTION 1.2 VARIABLES AND ARITHMETIC EXPRESSIONS 11
Thisexamplealsoshowsabitmoreofhowprintf works.printf isa general-purpose output formatting function, which we will describe in detail in Chapter 7. Its first argument is a string of characters to be printed, with each " indicating where one of the other (second, third, ...) arguments is to be substi- tuted,andinwhatformitistobeprinted. Forinstance,"dspecifiesaninteger argument, so the statement
printf("~\t~\n", fahr, celsius);
causes the values of the two integers fahr and celsius to be printed, with a tab (\t) betweenthem.
Each " construction in the first argument of printf is paired with the corresponding second argument, third argument, etc.; they must match up prop- erly by number and type, or you'll get wrong answers.
Bytheway,printf isnotpartoftheClanguage;thereisnoinputorout- put defined in C itself. prihtf is just a useful function from the.standard library of functions that are normally accessible to C programs. The behavior ofprintf isdefinedintheANSIstandard,however,soitspropertiesshouldbe the same with any compiler and library that conforms to the standard.
In order to concentrate on C itself, we won't talk much about input and out- put until Chapter 7. In particular, we will defer formatted input until then. If youhavetoinputnumbers,readthediscussionofthefunctionscanfinSec- tion 7.4. scanf is like printf, except that it reads input instead of writing output.
There are a couple of problems with the temperature conversion program. The simpler one is that the output isn't very pretty because the numbers are not right-justified.That'seasytofix;ifweaugmenteach"dintheprintf state- ment with a width, the numbers printed will be right-justified in their fields. For instance, we might say
printf(""3d "6d\n", fahr, celsius);
to print the first number of each line in a field three digits wide, and the second in a field six digits wide, like this:
o -17 20 -6 40 4 60 15 80 26
100 37
The more serious problem is that because we have used integer arithmetic, the Celsius temperatures are not very accurate; for instance, 00 F is actually about -17.80 C, not -17. To get more accurate answers, we should use floating-point arithmetic instead of integer. This requires some changes in the program. Here is a second version:

 12
A TUTORIAL INTRODUCTION CHAPTER 1
linclude <stdio.h>
/*pri~tFahrenheit-Celsiustable forfahr=0,20,...,300;floatinq-pointversion*/
maine )
{
float fahr, celsius; int lower, upper, step;
lower=0; /* lowerlimitoftemperaturetable*/ upper=300; /* upperlimit*/
step=20; /*stepsize*/
fahr = lower;
while (fahr <= upper) {
celsius = (5.0/9.0) * (fahr-32.0); printf("%3.0f %6.1f\n", fahr, celsius); fahr = fahr + step;
This is much the same as before, except that fahr and celsius are declared to be f loa t, and the formula for conversion is written in a more naturalway.Wewereunabletouse5/9inthepreviousversionbecause integer division would truncate it to zero. A decimal point in a constant indi- catesthatitisfloatingpoint,however,so5.0/9.0isnottruncatedbecauseit is the ratio of two floating-point values.
If an arithmetic operator has integer operands, an integer operation is per- formed. If an arithmetic operator has one floating-point operand and one integer operand, however, the integer will be converted to floating point before the operation is done. If we had written fahr-32, the 32 would be automati- cally converted to floating point. Nevertheless, writing floating-point constants with explicit decimal points even when they have integral values emphasizes their floating-point nature for human readers.
The detailed rules for when integers are converted to floating point are in Chapter 2. For now, notice that the assignment
} }
fahr = lower;
and the test
while (fahr <= upper)
also work in the natural way-the int is converted to float tion is done.
before the opera-
The printf conversion specification %3.Of says that a floating-point number (here fahr) is to be printed at least three characters wide, with no decimal point and no fraction digits. %6 • 1f describes another number (celsius) that is to be printed at least six characters wide, with 1 digit after the decimal point. The output looks like this:

 SECTION 1.3 THE FOR STATEMENT 13
o -17.8
20 -6.7 40 4.4
Width and precision may be omitted from a specification: %6f says that the number is to be at least six characters wide; %. 2f specifies two characters after the decimal point, but the width is not constrained; and %f merely says to print the number as floating point.
"d print as decimal integer
"6d print as decimal integer, at least 6 characters wide
print as floating point
"6f print as floating point, at least 6 characters wide
".2f print as floating point, 2characters after decimal point
"6.2f print as floating point, at least 6wide and 2after decimal point
Amongothers,printf alsorecognizes%0foroctal,%xforhexadecimal,%cfor character, %8 for character string, and %% for" itself.
Exercise 1-3. Modify the temperature conversion program to print a heading above the table. 0
Exercise 1-4. Write a program to print the corresponding Celsius to Fahrenheit table. 0
1.3 The For Statement
There are plenty of different ways to write a program for a particular task. Let's try a variation on the temperature converter.
#include <stdio.h>
1*printFahrenheit-Celsiustable*1 main( )
{
}
This produces the same answers, but it certainly looks different. One major change is the elimination of most of the variables; only fahr remains, and we have made it an into The lower and upper limits and the step size appear only as constants in the for statement, itself a new construction, and the expression that computes the Celsius temperature now appears as the third argument of printf instead of as a separate assignment statement.
"f
int fahr;
for (fahr = 0; fahr <= 300; fahr = fahr+ 20) printf(""3d "6.1f\n", fahr, (S.0/9.0)*(fahr-32»;
This last change is an instance of a general rule-in any context where it is

 14 A TUTORIAL INTRODUCTION CHAPTER 1
permissible to use the value of a variable of some type, you can use a more com- plicated expressionof that type. Since the third argument of printf must be a floating-point value to match the %6. 1f, any floating-point expression can occur there.
Thefor statementisaloop,ageneralizationofthewhile. Ifyoucompare it to the earlier while, its operation should be clear. Within the parentheses, there are three parts, separated by semicolons. The first part, the initialization
fahr =0
is done once, before the loop proper is entered. The second part is the test or condition that controls the loop:
fahr <= 300
This condition is evaluated; if it is true, the body of the loop (here a single
printf) is executed. Then the increment step
fahr =fahr + 20
is executed, and the condition re-evaluated. The loop terminates if the condition hasbecomefalse.Aswiththewhi1e,thebodyoftheloopcanbeasingle statement, or a group of statements enclosed in braces. The initialization, con- dition, and increment can be any expressions.
The choice between while and for is arbitrary, based on which seems clearer. The for is usually appropriate for loopsin which the initialization and increment are single statements and logically related, since it is more compact thanwhile anditkeepstheloopcontrolstatementstogetherinoneplace.
Exercise 1-5. Modify the temperature conversion program to print the table in reverse order, that is, from 300 degrees to O. 0
1.4 Symbolic Constants
A final observation before we leave temperature conversion forever. It's bad practice to bury "magic numbers" like 300 and 20 in a program; they convey little information to someone who might have to read the program later, and they are hard to change In a systematic way. One way to deal with magic numbers is to give them meaningful names. A #define line defines a sym- bolic name or symbolic constant to be a particular string of characters:
#define name replacementtext
Thereafter, any occurrence of name (not in quotes and not part of another name) will be replaced by the corresponding replacement text. The name has the same form as a variable name: a sequence of letters and digits that begins with a letter. The replacement text can be any sequence of characters; it is not limited to numbers.

 SECTION 1.S
CHARACTER INPUT AND OUTPUT 15
'include <stdio.h>
'define LOWER 'define UPPER 'define STEP
0 300
20
1* lower limit of table *1 1* upper limit *1
1* step size *1
1* p:t'intFahrenheit-Celsius table *1 main ()
{
}
The quantities LOWER, UPPER and STEP are symbolic constants, not variables, so they do not appear in declarations. Symbolic constant names are convention- ally written in upper case so they can be readily distinguished from lower case variable names. Notice that there is no semicolonat the end of a Idefine line.
1.5 Character Input and Output
Weare now going to consider a family of related programs for processing character data. You will find that many programs are just expanded versionsof the prototypes that we discuss here.
The model of input and output supported by the standard library is very sim- ple. Text input or output, regardless of where it originates or where it goes to, is dealt with as streams of characters, A text stream is a sequence of charac- ters divided into lines; each line consists of zero or more characters followed by anewlinecharacter. Itistheresponsibilityofthelibrarytomakeeachinputor output stream conform to this model; the C programmer using the library need not worry about how lines are represented outside the program.
The standard library provides several functions .for reading or writing one character at a time, of which getchar and putchar are the simplest. Each time it is called, getchar reads the next input character from a text stream and returns that as its value. That is, after
c = getchar()
the variable c contains the next character of input. The characters normally come from the keyboard; input from files is discussed in Chapter 7. Thefunctionputcharprintsacharactereachtimeitiscalled:
putchar(c)
prints the contents of the integer variable c as a character, usually on the screen. Calls to putchar and printf may be interleaved; the output will
int fahr;
for (fahr = LOWER; fahr <= UPPER; fahr = fahr+ STEP) printf(""3d "6.1f\n", fahr, (S.0/9.0)*(fahr-32»;

 16 A TUTORIAL INTRODUCTION CHAPTER 1 appear in the order in which the calls are made.
1.5.1 File Copying
Given getchar and putchar, you can write a surprising amount of useful code without knowing anything more about input and output. The simplest example is a program that copies its input to its output one character at a time:
read a character
whi 1e (character is not end-of-file indicator)
output the characterjust read read a character
Converting this into C gives
#include <stdio.h>
1* copy input to output; 1st version *1 main( )
{
}
The relational operator I =means "not equal to."
What appears to be a character on the keyboard or screen is of course, like
everything else, stored internally just as a bit pattern. The·type char is specifi- cally meant for storing such character data, but any integer type can be used. We used int for a subtle but important reason.
The problem is distinguishing the end of the input from valid data. The solution is that getchar returns a distinctive value when there is no more input, a value that cannot be confused with any real character. This value is called EOF,for "end of file." We must declare c to be a type big enough to hold any value that getchar returns. We can't use char since c must be big enough to hold EOFin addition to any possible char. Therefore we use into
EOF is an integer defined in <stdio. h>, but the specific numeric value doesn't matter as long as it is not the same as any char value. By using the symbolic constant, we are assured that nothing in the program depends on the specific numeric value.
The program for copying would be written more concisely by experienced C programmers. In C, any assignment, such as
int c;
c =getchar(); while(c1=EOF) {
putchar(c);
c = getchar(); }
c =qetchar()

 SECTION 1.5 CHARACTER INPUT AND OUTPUT 17
is an expression and has a value, which is the value of the left hand side after the assignment. This means that an assignment can appear as part of a larger expression.Iftheassignmentofacharactertocisputinsidethetestpartofa
while
loop, the copy program can be written this way:
#include <stdio.h>
1*copyinputtooutput;2ndversion*1 maine )
{
}
int c;
while «c = getchar(» 1= EOF) putchar(c);
The while
terwastheend-of-filesignal.Ifitwasnot,thebodyofthewhile isexecuted, printing the character. The while then repeats. When the end of the input is finally reached, the while terminates and so does main.
This version centralizes the input-there is now only one reference to qetchar-and shrinks the program. The resulting program is more compact, and, once the idiom is mastered, easier to read. You'll see this style often. (It's possible to get carried away and create impenetrable code, however, a tendency that we will try to curb.)
The parentheses around the assignment within the condition are necessary. The precedence of I= is higher than that of =, which means that in the absence of parentheses the relational test I=would be done before the assignment =. So the statement
c = getchar() 1= EOF
is equivalent to
c = (getchar() 1= EOF)
This has the undesired effect of setting c to 0 or 1, depending on whether or not the call of qetchar encountered end of file. (More on this in Chapter 2.)
Exercise1-6.Verifythattheexpressionqetchar () I=EOFis0or1.0 Exercise 1-7. Write a program to print the value of EOF. 0
1.5.2 Character Counting
gets a character, assigns it to c, and then tests whether the charac-
The next program counts characters; it is similar to the copy program.

 18 A TUTORIAL INTRODUCTION #include <stdio.h>
1*countcharactersininput;1stversion*1 main( )
{
}
The statement
++nc;
CHAPTER 1
long nc;
nc =0;
while (getchar() 1= EOF)
++nc; printf("%ld\n", ncl ;
presents a new operator, ++, which means increment by one. You could instead write nc =nc+ 1 but ++nc is more conciseand often more efficient. There is a correspondingoperator -- to decrement by 1. The operators ++ and -- can be either prefix operators (++nc) or postfix (nc++); these two forms have dif- ferent values in expressions, as will be shown in Chapter 2, but ++nc and nc+» both increment nco For the moment we will stick to the prefix form.
The character counting program accumulates its count in a long variable instead of an into long integers are at least 32 bits. Although on some machines, int and long are the same size, on others an int is 16 bits, with a maximum value of 32767, and it would take relatively little input to overflowan int counter. The conversion specification %ld tells printf that the correspondingargumentisalonginteger.
It may be possible to cope with even bigger numbers by using a double (double precision float). We will also use a for statement instead of a while,toillustrateanotherwaytowritetheloop.
#include <stdio.h>
1*countcharactersininput;2ndversion*1 main( )
{
}
printf uses%fforbothfloat anddouble;%.Ofsuppressesprintingofthe decimal point and the fraction part, which is zero.
The body of this for loop is empty, because all of the work is done in the test and increment parts. But the grammatical rules of C require that a for statement have a body. The isolated semicolon,called a null statement, is there
double nc;
for (nc = 0; getchar() 1= EOF; ++nc)
,
printf("%.Of\n", nc);

 SECTION 1.5 CHARACTER INPUT AND OUTPUT 19
to satisfy that requirement. We put it on a separate line to make it visible. Before we leave the character counting program, observe that if the input contains no characters, the while or for test fails on the very first call to
getchar, and the program produces zero, the right answer. This is important. One of the nice things about while and for is that they test at the top of the loop, before proceeding with the body. If there is nothing to do, nothing is done, even if that means never going through the loop body. Programs should act intelligently when given zero-length input. The while and for statements help ensure that programs do reasonable things with boundary conditions.
1.5.3 Line Counting
The next program counts input lines. As we mentioned above, the standard library ensures that an input text stream appears as a sequence of lines, each terminated by a newline. Hence, counting lines is just counting newlines:
#include <stdio.h>
1* count lines in input *1 maine )
{
}
The body of the while now consists of an if, which in turn controls the increment ++nl. The if statement tests the parenthesized condition, and if the condition is true, executes the statement (or group of statements in braces) that follows. We have again indented to show what is controlled by what.
The double equals sign ==is the C notation for "is equal to" (like Pascal's single =or Fortran's .EQ.). This symbol is used to distinguish the equality test from the single =that C uses for assignment. A word of caution: newcomers to C occasionally write =when they mean ==. As we will see in Chapter 2, the result is usually a legal expression, so you will get no warning.
A character written between single quotes represents an integer value equal to the numerical value of the character in the machine's character set. This is called a character constant, although it is just another way to write a small integer. So, for example, ' A' is a character constant; in the ASCII character set its value is 65, the internal representation of the character A. Of course ' A ' is to be preferred over 65: its meaning is obvious, and it is independent of a par- ticular character set.
int c, nl;
nl =0;
while «c = getchar(» 1= EOF)
if(c== \'n') ++nl;
printf(""d\n", nl);
The escape sequences used in string constants are also legal in character

 20 A TUTORIAL INTRODUCTION CHAPTER 1
constants,so'\n' standsforthevalueofthenewlinecharacter,whichis10in ASCII.Youshouldnotecarefullythat'\n'isasinglecharacter,andin expressionsisJustaninteger;ontheotherhand,"\n"isastringconstantthat happens to contain only one character. The topic of strings versus characters is discussed further in Chapter 2.
Exercise 1..8. Write a program to count blanks, tabs, and newlines. 0
Exercise 1-9. Write a program to copy its input to its output, replacing each stringofoneormoreblanksbyasingleblank. 0
Exercise 1-10. Write a program to copy its input to its output, replacing each tabby\t,eachbackspaceby\b,andeachbackslashby\\. Thismakestabs and backspaces visible in an unambiguous way. 0
1.5.4 Word Counting
The fourth in our series of useful programs counts lines, words, and charac- ters, with the loose definition that a word is any sequence of characters that does not contain a blank, tab or newline. This is a bare-bones version of the UNIX program we.
#include <stdio.h>
#define IN 1 1* inside a word *1
#define OUT 0 1* outside a word *1
1* count lines, words, and characters in input*1 maine )
{
int c, nl, nw, nc, state;
state =OUT;
nl =nw =nc =0;
while «c = getchar()) 1= EOF) {
++nc;
if(c =='\n')
++nl;
if(c== ' II,c==\'n'IIc== 't\')
state =OUT;
else if (state == OUT) {
state =IN;
++nw;
} }
printf("%d %d "d\n", nl, nw, ncl ; }
Every time the program encounters the first character of a word, it counts

 SECTION 1.5 CHARACTER INPUT AND OUTPUT 21
onemoreword.Thevariablestate recordswhethertheprogramiscurrently in a word or not; iriitially it is "not in a word," which is assigned the value OUT. We prefer the symbolic constants IN and OUT to the literal values 1 and 0 because they make the program more readable. In a program as tiny as this, it makes little difference, but in larger programs, the increase in clarity is well worth the modest extra effort to write it this way from the beginning. You'll also find that it's easier to make extensive changes in programs where magic numbers appear only as symbolic constants.
The line
nl =nw =nc =0;
sets all three variables to zero. This is not a special case, but a consequence of the fact that an assignment is an expression with a value and assignments asso- ciate from right to left. It's as if we had written
nl =(nw =(nc =0));
The operator I I means OR, so the line
if (c == ' II,c ==\.'n' II c == 't'\.)
says "if c is a blank or c is a newline or c is a tab". {Recall that the escape sequence \ t is a visible representation of the tab character.} There is a corresponding operator && for AND; its precedence is just higher than I I. Expressions connected by && or I 1are evaluated left to right, and it is guaranteed that evaluation will stop as soon as the truth or falsehood is known. Ifcisablank,thereisnoneedtotestwhetheritisanewlineortab,sothese tests are not made. This isn't particularly important here, but is significant in more complicated situations, as we will soon see.
Theexamplealsoshowsanelse,whichspecifiesanalternativeactionifthe conditionpartofanifstatementisfalse.Thegeneralformis
if ( expression) statement 1
else
statement 2
One and only one of the two statements associated with an if-else formed.Iftheexpressionistrue,statement1isexecuted;ifnot,statement2is executed. Each statement can be a single statement or several in braces. In the wordcountprogram,theoneaftertheelseisanifthatcontrolstwostate- ments in braces.
Exercise 1-11. How would you test the word count program? What kinds of input are most likely to uncover bugs if there are any? 0
Exercise 1-12. Write a program that prints its input one word per line. 0
is per-

 22 A TUTORIAL INTRODUCTION CHAPTER I 1.6 Arrays
Let us write a program to count the number of occurrences of each digit, of white space characters (blank, tab, newline), and of all other characters. This is artificial, butit permits us to illustrate several aspects of C in one program.
There are twelve categories of input, so it is convenient to use an array to hold the number of occurrences of each digit, rather than ten individual vari- ables. Here is one version of the program:
#include <stdio.h~
1*countdigits,whitespace,others*1 maine )
{
}
The output
nwhite, nother);
of this program on itself is
int c, i, nwhite, nother; int ndigit[10];
nwhite =nother =0;
for (i = 0; i < 10; ++i)
ndigit[i] =0;
while «c = getchar(» 1= EOF) if(c>= '0'&&c<= '9')
++ndigit[c-'O'];
e1se if (c== ' ,I I c == '\n' I I c == '\t')
++nwhite; ~lse
++nother;
printf("digits =");
for (i =0; i < 10; ++i)
printf(" %<i", ndigit[i]);
printf(", white space::;%d, other =%d\n",
digits = 9 3 0 0 0 0 0 0 0 1, white space= 123, other = 345
The declaration
int ndigit[10];
declaresndiqittobeanarrayof10integers.Arraysubscriptsalwaysstartat zeroinC,sotheelementsarendigit[0],ndigit[1],...,ndigit[9]. This is reflected in the for loops that initialize and print the array.
A subscript can be any integer expression, which includes integer variables like i, and integer constants.
This particular program relies on the properties of the character representa- tion of the digits. For example, the test

 SECTION 1.6 ARRAYS 23 if (c >= '0' && c <= '9') ...
determines whether the character in c is a digit. If it is, the numeric value of that digit is
c- '0'
Thisworksonlyif'0','1"...,'9' haveconsecutiveincreasingvalues.For- tunately, this is true for all character sets.
By definition, chars are just small integers, so char variables and constants are identical to ints in arithmetic expressions. This is natural and convenient; for example, c - ' 0' is an integer expression with a value between 0 and 9 correspondingtothecharacter'0'to'9'storedinc,andisthusavalidsub- script for the array ndigi t.
The decision as to whether a character is a digit, white space, or something else is made with the sequence
if (c>= '0'&& c <= '9') ++ndigit[c-'O'];
else if (c==" ++nwhite;
else ++nother;
The pattern
if (condition1) statement ,
else if (conditiony statement 2
else
statement;
II c == '\n' II c == '\t')
t
occurs frequently in programs as a way to express a multi-way decision. The conditions are evaluated in order from the top until some condition is satisfied; at that point the corresponding statement part is executed, and the entire con- struction is finished. (Any statement can be several statements enclosed in braces.) If none of the conditions is satisfied, the statement after the final else is executed if it is present. If the final else and statement are omitted, as in the word count program, no action takes place. There can be any number of
else if (condition) statement
groupsbetweentheinitialif andthefinalelse.
As a matter of style, it is advisable to format this construction as we have
shown;ifeachif wereindentedpastthepreviouselse,alongsequenceof decisions would march off the right side of the page.

 24 A TUTORIAL INTRODUCTION CHAPTER 1
The switch statement, to be discussed in Chapter 3, provides another way to write a multi-way branch that is particularly suitable when the condition is whether some integer or character expression matches one of a set of constants. For contrast, we will present a switch versionof this program in Section 3.4.
Exercise 1-13. Write a program to print a histogram of the lengths of words in its input. It is easy to draw the histogram with the bars horizontal; a vertical orientation is more challenging. 0
Exercise 1-14. Write a program to print a histogram of the frequencies of dif- ferent characters in its input. 0
1.7 Functions
In C, a function is equivalent to a subroutine or function in Fortran, or a procedure or function in Pascal. A function provides a convenient way to encapsulate some computation, which can then be used without worrying about its implementation. With properly designed functions, it is possible to ignore how a job is done; knowing what is done is sufficient. C makes the use of func- tions easy, convenient and efficient; you will often see a short function defined and called only once, just because it clarifies some piece of code.
So far we have used only functions like printf, getchar, and putchar that have been provided for us; now it's time to write a few of our own. Since C has no exponentiation operator like the ** of Fortran, let us illustrate the mechanics of function definition by writing a function power (m,n) to raise an integer m to a positive integer power n. That is, the value of power (2,5) is 32. This function is not a practical exponentiation routine, since it handles only positive powers of small integers, but it's good enough for illustration. (The standard library contains a function pow(x ,y) that computes xY.)
Here is the function power and a main program to exercise it, so you can see the whole structure at once.
#include <stdio.h>
int power(int m, int n);
1*testpowerfunction*1 main ()
{
}
int i;
for (i = 0; i < 10; ++i)
printf(""d "d %d\n", i, power(2,i), power(-3,i»;
return 0;

 SECTION 1.7
FUNCTIONS 2S
1* power: raise base to n-th power; n>= 0 *1 int power(int base, int n)
{
int i, p;
p =1;
for (i= 1;i <= n; ++i)
p =p * base; return p;
}
A function definition has this form:
return-type function-name (parameter declarations, if any) {
declarations
statements
}
Function definitions can appear in any order, and in one source file or several, although no function can be split between files. If the source program appears in several files, you may have to say more to compile and load it than if it all appears in one, but that is an operating system matter, not a language attribute. For the moment, we will assume that both functions are in the same file, so whatever you have learned about running C programs will still work.
The function power is called twice by main, in the line
printf(""d "d %d\n", i, power(2,i), power(-3,i»;
Each call passes two arguments to power, which each time returns an integer to be formatted and printed. In an expression, power (2, i) is an integer just as 2 and i are. (Not all functions produce an integer value; we will take this up in Chapter 4.)
The first line of power itself,
int power(int base, int n)
declares the parameter types and names, and the type of the result that the function returns. The names used by power for its parameters are local to power, and are not visible to any other function: other routines can use the same names without conflict. This is also true of the variables i and p: the i in power is unrelated to the i in main.
We will generally use parameter for a variable named in the parenthesized list in a function definition, and argument for the value used in a call of the function. The termsformal argument and actual argument are sometimesused for the same distinction.
The value that power computes is returned to main by the return state- ment. Anyexpressionmayfollowreturn:
return expression;

 26 A TUTORIAL INTRODUCTION CHAPTER I
A function need not return a value; a return statement with no expression causes control, but no useful value, to be returned to the caller, as does "falling off the end" of a function by reaching the terminating right brace. And the cal- ling function can ignore a value returned by a function.
You may have noticed that there is a return statement at the end of main. Since main is a function like any other, it may return a value to its caller, which is in effect the environment in which the program was executed. Typi- cally, a return value of zero implies normal termination; non-zero values signal unusual or erroneous termination conditions. In the interests of simplicity, we have omitted return statements from our main functions up to this point, but we will include them hereafter, as a reminder that programs should return status to their environment.
The declaration
int power(int m, int n);
just before main says that power is a function that expects two int arguments and returns an into This declaration, which is called a function prototype, has to agree with the definition and uses of power. It is an error if the definition of a function or any uses of it do not agree with its prototype.
Parameter names need not agree. Indeed, parameter names are optional in a function prototype, so for the prototype we could have written
int power(int, int);
Well-chosen names are good documentation, however, so we will often use them.
A note of history: The biggest change between ANSI C and earlier versions is how functions are declared and defined. In the original definition of C, the power function would have been written like this:
1* power: raise base to n-th power; n>= 0 *1 1* (old-styleversion) *1
power (base, n)
int base, n;
{
}
The parameters are named between the parentheses, and their types are declared before the opening left brace; undeclared parameters are taken as into (The body of the function is the same as before.)
The declaration of power at the beginning of the program would have looked like this:
int i, p;
p =1;
for (i= 1;i <= n; ++i)
p =p * base; return p;

 SECTION 1.8 ARGUMENTS-CALL BY VALUE 27
int power();
No parameter list was permitted, so the compiler could not readily check that power was being called correctly. Indeed, since by default power would have beenassumedtoreturnanint,theentiredeclarationmightwellhavebeen omitted.
The new syntax of function prototypes makes it much easier for a compiler to detect errors in the number of arguments or their types. The old style of declaration and definition still works in ANSI C, at least for a transition period, but we strongly recommend that you use the new form when you have a com- piler that supports it.
Exercise 1-15. Rewrite the temperature conversion program of Section 1.2 to use a function for conversion. 0
1.8 Arguments-Call by Value
One aspect of C functions may be unfamiliar to programmers who are used to some other languages, particularly Fortran. In C, all function arguments are passed "by value." This means that the called function is given the values of its arguments in temporary variables rather than the originals. This leads to some different properties than are seen with "call by reference" languages like For- tranorwithvarparametersinPascal,inwhichthecalledroutinehasaccessto the original argument, not a local copy.
The main distinction is that in C the called function cannot directly alter a variable in the calling function; it can only alter its private, temporary copy.
Call by value is an asset, however, not a liability. It usually leads to more compact programs with fewer extraneous variables, because parameters can be treated as conveniently initialized local variables in the called routine. For example, here is a version of power that makes use of this property.
1*power:raisebaseton-thpower;n>=O;version2*1 int power(int base, int n)
{
int p;
for(p=1;n> 0;--n) p = p * base;
return p;
}
The parameter n is used as a temporary variable, and is counted down (a for loop that runs backwards) until it becomes zero; there is no longer a need for the variable i. Whatever is done to n inside power has no effect on the argu- ment that power was originally called with.
When necessary, it is possible to arrange for a function to modify a variable

 28 A TUTORIAL INTRODUCTION CHAPTER 1
in a calling routine. The caller must provide the address of the variable to be set (technically a pointer to the variable), and the called function must declare the parameter to be a pointer and access the variable indirectly through it. We will cover pointers in Chapter 5.
The story is different for arrays. When the name of an array is used as an argument, the value passed to the function is the location or address of the beginning of the array-there is no copying of array elements. By subscripting this value, the function can access and alter any element of the array. This is the topic of the next section.
1.9 Character Arrays
The most common type of array in C is the array of characters. To illus- trate the use of character arrays and functions to manipulate them, let's write a program that reads a set of text lines and prints the longest. The outline is sim- ple enough:
while (there'sanotherline)
if (it'slongerthanthepreviouslongest)
save it
save its length print longest line
This outline makes it clear that the program divides naturally into pieces. One piece gets a new line, another tests it, another saves it, and the rest controls the process.
Since things divide so nicely, it would be well to write them that way too. Accordingly, let us first write a separate function getline to fetch the next line of input. We will try to make the function useful in other contexts. At the minimum, getline has to return a signal about possible end of file; a more useful design would be to return the length of the line, or zero if end of file is encountered. Zero is an acceptable end-of-file return because it is never a valid line length. Every text line has at least one character; even a line containing only a newline has length 1.
When we find a line that is longer than the previous longest line, it must be saved somewhere. This suggests a second function, copy, to copy the new line to a safe place.
Finally, we need a main program to control getline and copy. Here is the result.

 SECTION 1.9 CHARACTER ARRAYS 29 #include <stdio.h>
Idefine MAXLINE 1000 1* maximum input line size *1 int getline{char line[], int maxline);
void copy{char to[], char from[]);
1* print longest input line *1 main{ )
{
int len;
int max;
char line[MAXLINE];
char longest[MAXLINE]; 1* longest line saved here *1
1* current line length *1
1* maximum length seen so far *1
max = 0; while{{len=getline(line,MAXLINE» >0)
if (len> max) { max = len;
copy{longest, line);
}
if (max> 0) 1* there was a line *1 printf{"%s", longest);
1* current input line *1
return 0; }
1* getline: read a line into s, return length*1 int getline{char s[], int lim)
{
int c, i;
for (i=O; i<lim-1 && (c=getchar{» I=EOF && cl='\n'; ++i)
sri] = c;
if (c == '\n') { sri] =c;
++i;
}
sri] = '\0'; return i;
}
1* copy: copy 'from' into 'to'; assume to is big enough*1 void copy{char tor], char from[])
{
}
int i;
i =0;
while {(to[i] = from[i]) 1= '\0')
++i;

 30 A TUTORIAL INTRODUCTION CHAPTER 1
The functions get1ine and copy are declared at the beginning of the pro- gram, which we assume is contained in one file.
main and get1ine communicate through a pair of arguments and a returned value. In get1ine, the arguments are declared by the line
int qetline(char s[], int lim)
whichspecifiesthatthefirstargument,s,isanarray,andthesecond,lim,is an integer. The purpose of supplying the size of an array in a declaration is to set aside storage. The length of the array s is not necessary in get1ine since itssizeissetinmain.get1ine usesreturn tosendavaluebacktothe caller, just as the function power did. This line also declares that getline returns an int; since int is the default return type, it could be omitted.
Some functions return a useful value; others, like copy, are used only for theireffectandreturnnovalue.Thereturntypeofcopyisvoid,whichstates explicitly that no value is returned.
getline puts the character ' \0' (the null character, whosevalue is zero) at the end of the array it is creating, to mark the end of the string of characters. This conventionis also used by the C language: when a string constant like
"hello\n"
appears in a C program, it is stored as an array of characters containing the characters of the string and terminated with a ' \0' to mark the end.
Ihie I1 I1 I0 I\n I\0 I
The%sformatspecificationinprintf expectsthecorrespondingargumentto beastringrepresentedinthisform.copyalsoreliesonthefactthatitsinput argumentisterminatedby,\0',anditcopiesthischaracterintotheoutput argument. (All of this implies that ' \0' is not a part of normal text.)
It is worth mentioning in passing that even a program as small as this one presentssomestickydesignproblems.Forexample,whatshouldmaindoifit encounters a line which is bigger than its limit? get1ine works safely, in that it stops collecting when the array is full, even if no newline has been seen. By testing the length and the last character returned, main can determine whether the line was too long, and then cope as it wishes. In the interests of brevity, we have ignored the issue.
There is no way for a user of get1 ine to know in advance how long an input line might be, so get1 ine checks for overflow. On the other hand, the user of copy already knows (or can find out) how big the strings are, so we have chosen not to add error checking to it.
Exercise 1-16. Revise the main routine of the longest-line program so it will correctly print the length of arbitrarily long input lines, and as much as possible of the text. 0

 SECTION 1.10 EXTERNAL VARIABLES AND SCOPE 31
Exercise 1-17. Write a program to print all input lines that are longer than 80 characters. 0
Exercise 1-18. Write a program to remove trailing blanks and tabs from each line of input, and to delete entirely blank lines. 0
Exercise 1-19. Write a function reverse (s) that reverses the character strings.Useittowriteaprogramthatreversesitsinputalineatatime.0
1.10 External Variables and Scope
Thevariablesinmain,suchasline, longest, etc.,areprivateorlocalto main. Because they are declared within main, no other function can have direct access to them. The same is true of the variables in other functions; for example, the variable i in getline is unrelated to the i in copy. Each local variable in a function comes into existence only when the function is called, and disappears when the function is exited. This is why such variables are usually known as automatic variables, following terminology in other languages. We will use the term automatic henceforth to refer to these local variables. (Chapter 4 discusses the static storage class, in which local variables do retain their values between calls.)
Because automatic variables come and go with function invocation, they do not retain their values from one call to the next, and must be explicitly set upon each entry. If they are not set, they will contain garbage.
As an alternative to automatic variables, it is possible to define variables that are external to all functions, that is, variables that can be accessed by name by any function. (This mechanism is rather like Fortran COMMON or Pascal vari- ables declared in the outermost block.) Because external variables are globally accessible, they can be used instead of argument lists to communicate data between functions. Furthermore, because external variables remain in existence permanently, rather than appearing and disappearing as functions are called and exited, they retain their values even after the functions that set them have returned.
An external variable must be defined, exactly once, outside of any function; this sets aside storage for it. The variable must also be declared in each func- tion that wants to access it; this states the type of the variable. The declaration may be an explicit extern statement or may be implicit from context. To make the discussionconcrete, let us rewrite the longest-lineprogram with line, longest, and max as external variables. This requires changing the calls, declarations, and bodies of all three functions.

 32 A TUTORIAL INTRODUCTION
CHAPTER 1
#include <stdio.h> #define MAXLINE 1000
1* maximum input line size *1
1* maximum length seen so far *1 1* current input line *1
1* print longest input line; specialized version *1 main ()
{
int max;
char line[MAXLINE];
char 10ngest[MAXLINE]; 1* longest line saved here *1
int getline(void); void copy(void);
int len;
extern int max; extern char longest[];
max = 0;
while «len = getline(» >0)
if (len> max) { max = len;
copy( );
}
if (max> 0) 1* there was a line *1 printf(n"s", longest);
return 0;
}
1*getline: specializedversion*1 int getline(void)
{
int c, i;
extern char line[];
for (i = 0; i < MAXLINE-1
&&(c=getchar(» 1=EOF&&c1='\n';++i)
line[i] = c; if (c == '\n') {
line[i] = c;
++i;
}
line[i]= \'0' ; return i;
}

 SECTION 1.10 EXTERNAL VARIABLES AND SCOPE 33
1* copy: specializedversion*1 void copy(void)
{
}
int i;
extern char line[], longest[];
i =0;
while « longest[i] = line[i]) 1= '\0')
++i;
Theexternalvariablesinmain,getline, andcopyaredefinedbythe first lines of the example above, which state their type and cause storage to be allocated for them. Syntactically, external definitions are just like definitions of local variables, but since they occur outside of functions, the variables are exter- nal. Before a function can use an external variable, the name of the variable must be made known to the function. One way to do this is to write an extern declarationinthefunction;thedeclarationisthesameasbeforeexcept for the added keyword extern.
In certain circumstances, the extern declaration can be omitted. If the definition of an external variable occurs in the source file before its use in a par- ticular function, then there is no need for an extern declaration in the func- tion.Theexterndeclarationsinmain,getlineandcopyarethusredun- dant. In fact, common practice is to place definitions of all external variables at thebeginningofthesourcefile,andthenomitallextern declarations.
Iftheprogramisinseveralsourcefiles,andavariableisdefinedinfilel andusedinfUe2andfile3,thenexterndeclarationsareneededinfile2and file3 to connect the occurrences of the variable. The usual practice is to collect
extern declarations of variables and functions in a separate file, historically called a header, that is included by #include at the front of each source file. The suffix •h is conventional for header names. The functions of the standard library, for example, are declared in headers like <stdio. h>. This topic is discussed at length in Chapter 4, and the library itself in Chapter 7 and Appen- dix B.
Since the specialized versions of getline and copy have no arguments, logic would suggest that their prototypes at the beginning of the file should be getline () and copy(). But for compatibility with older C programs the standard takes an empty list as an old-style declaration, and turns off all argu- ment list checking; the word void must be used for an explicitly empty list. We will discuss this further in Chapter 4.
You should note that we are using the words definition and declaration care- fully when we refer to external variables in this section. "Definition" refers to the place where the variable is created or assigned storage; "declaration" refers to places where the nature of the variable is stated but no storage is allocated.
By the way, there is a tendency to make everything in sight an extern vari- able because it appears to simplify communications-argument lists are short

 34 A TUTORIAL INTRODUCTION CHAPTER 1
and variables are always there when you want them. But external variables are always there even when you don't want them. Relying too heavily on external variables is fraught with peril since it leads to programs whose data connections are not at all obvious-variables can be changed in unexpected and even inad- vertent ways, and the program is hard to modify. The second version of the longest-line program is inferior to the first, partly for these reasons, and partly because it destroys the generality of two useful functions by wiring into them the names of the variables they manipulate.
At this point we have covered what might be called the conventional core of c. With this handful of building blocks, it's possible to write useful programs of considerable size, and it would probably be a good idea if you paused long enough to do so. These exercises suggest programs of somewhat greater com- plexity than the ones earlier in this chapter.
Exercise 1-20. Write a program detab that replaces tabs in the input with the proper number of blanks to space to the next tab stop. Assume a fixed set of tab stops, say every n columns. Should n be a variable or a symbolic parame- ter? 0
Exercise 1-21. Write a program entab that replaces strings of blanks by the minimum number of tabs and blanks to achieve the same spacing. Use the sametabstopsasfordetab. Wheneitherataborasingleblankwouldsuffice to reach a tab stop, which should be given preference? 0
Exercise 1-22. Write a program to "fold" long input lines into two or more shorter lines after the last non-blank character that occurs before the n-th column of input. Make sure your program does something intelligent with very long lines, and if there are no blanks or tabs before the specified column. 0
Exercise 1-23. Write a program to remove all comments from a C program. Don't forget to handle quoted strings and character constants properly. C com- ments do not nest. 0
Exercise 1-24. Write a program to check a C program for rudimentary syntax errors like unbalanced parentheses, brackets and braces. Don't forget about quotes, both single and double, escape sequences, and comments. (This pro- gram is hard if you do it in full generality.) 0

 CHAPTER 2: Types, Operators, and Expressions
Variables and constants are the basic data objects manipulated in a program. Declarations list the variables to be used, and state what type they have and perhaps what their initial values are. Operators specify what is to be done to them. Expressions combine variables and constants to produce new values. The type of an object determines the set of values it can have and what operations can be performed on it. These building blocks are the topics of this chapter.
The ANSI standard has made many small changes and additions to basic types and expressions. There are now signed and unsigned forms of all integer types, and notations for unsigned constants and hexadecimal character constants. Floating-point operations may be done in single precision;.there is alsoalongdoubletypeforextendedprecision.Stringconstantsmaybecon- catenated at compile time. Enumerations have become part of the language, formalizingafeatureoflongstanding. Objectsmaybedeclaredconst, which prevents them from being changed. The rules for automatic coercions among arithmetic types have been augmented to handle the richer set of types.
2.1 Variable Names
Although we didn't say so in Chapter 1, there are some restrictions on the names of variables and symbolic constants. Names are made up of letters and digits; the first character must be a letter. The underscore" _" counts as a letter; it is sometimes useful for improving the readability of long variable names. Don't begin variable names with underscore, however,since library rou- tines often use such names. Upper case and lower case letters are distinct, so x and X are two different names. Traditional C practice is to use lower case for variable names, and all upper case for symbolic constants.
At least the first 31 characters of an internal name are significant. For function names and external variables, the number may be less than 31, because external names may be used by assemblers and loaders over which the language has no control. For external names, the standard guarantees uniqueness only for 6 characters and a single case. Keywordslike if, else, int, float, etc.,
35

 36 TYPES, OPERATORSAND EXPRESSIONS CHAPTER 2
are reserved: you can't use them as variable names. They must be in lower case.
It's wise to choose variable names that are related to the purpose of the vari- able, and that are unlikely to get mixed up typographically. We tend to use short' names for local variables, especially loop indices, and longer names for external variables.
2.2 Data Types and Sizes
There are only a few basic data types in C:
char a single byte, capable of holding one character in the local character set.
int an integer, typically reflecting the natural size of integers on the host machine.
float single-precision floating point. double double-precision floating point.
In addition, there are a number of qualifiers that can be applied to these basic types. short and long apply to integers:
short int sh; long int counter;
The word int can be omitted in such declarations, and typically is.
The intent is that short and long should provide different lengths of integers where practical; int will normally be the natural size for a particular machine. short is often 16 bits, long 32 bits, and int either 16 or 32 bits. Each compiler is free to choose appropriate sizes for its own hardware, subject
only to the restriction that shorts and ints are at least 16 bits, longs are at least 32 bits, and short is no longer than int, which is no longer than long.
The qualifier signed or unsigned may be applied to char or any integer. unsiqned numbers are always positive or zero, and obey the laws of arithmetic modulo 211, where n is the number of bits in the type. So, for instance, if chars are 8 bits, unsigned char variables have values between 0 and 255, while siqned chars have values between -128 and 127 (in a two's complement machine). Whether plain chars are signed or unsigned is machine-dependent, but printable characters are always positive.
The type long double specifies extended-precision floating point. As with integers, the sizes of floating-point objects are implementation-defined; float, double and long double could represent one, two or three distinct sizes.
The standard headers <limits. h> and <float. h> contain symbolic con- stants for all of these sizes, along with other properties of the machine and com- piler. These are discussed in Appendix B.
Exercise 2-1. Write a program to determine the ranges of char, short, int,

 SECTION 2.3 CONSTANTS 37
and long variables, both signed and unsigned, by printing appropriate values from standard headers and by direct computation. Harder if you com- pute them: determine the ranges of the various floating-point types. 0
2.3 Constants
An integer constant like 1234 is an into A long constant is written with a terminal 1 (ell) or L, as in 123456789L; an integer too big to fit into an int will also be taken as a long. Unsigned constants are written with a terminal u or U,and the suffix ul or ULindicates unsigned long.
Floating-point constants contain a decimal point (123. 4) or an exponent (1e-2) or both; their type is double, unless suffixed. The suffixes f or F indi-
cate a float constant; 1 or L indicate a long double.
The value of an integer can be specified in octal or hexadecimal instead of
decimal. A leading 0 (zero) on an integer constant means octal; a leading Ox or oxmeans hexadecimal. For example, decimal 31 can be written as 037 in octal and Ox1f or OX1Fin hex. Octal and hexadecimal constants may also be followed by L to make them long and U to make them unsigned: OXFULis an unsigned long constant with value 15 decimal.
A character constant is an integer, written as one character within single quotes, such as ' x '. The value of a character constant is the numeric value of the character in the machine's character set. For example, in the ASCII charac- tersetthecharacterconstant'0'hasthevalue48,whichisunrelatedtothe numeric value O. If we write ' 0' instead of a numeric value like 48 that depends on character set, the program is independent of the particular value and easier to read. Character constants participate in numeric operations just as any other integers, although they are most often used in comparisons with other characters.
Certain characters can be represented in character and string constants by escape sequences like \n (newline); these sequences look like two characters, but represent only one. In addition, an arbitrary byte-sized bit pattern can be specified by
'\000'
where000 isonetothreeoctaldigits(0...7)orby
'\xhh'
where hh is one or more hexadecimal digits (0...9, a...f, A..F). SOwe might
write
#define VTAB '\013' 1* ASCII vertical tab *1 #define BELL '\007' 1* ASCII bell character *1
or, in hexadecimal,

 38 TYPES, OPERATORSAND EXPRESSIONS
#define VTAB '\xb' 1* ASCII vertical tab *1
#define BELL '\x7' 1* ASCII bell character *1 The complete set of escape sequences is
CHAPTER 2
\a alert (bell) character \b backspace
\f formfeed
\n newline
\\ backslash
\? question mark \' singlequote \" double,quote
\r carriage return \000 octal number
\t horizontal tab \xhh hexadecimal number \v vertical tab
The character constant ' \0'
null character. ' \ 0' is often written instead of 0 to emphasize the character nature of some expression, but the numeric value is just O.
A constant expression is an expression that involves only constants. Such expressions may be evaluated during compilation rather than run-time, and accordingly may be used in any place that a constant can occur, as in
#define MAXLINE 1000 char line[MAXLINE+1];
or
A string constant, or string literal, is a sequence of zero or more characters surrounded by double quotes, as in
"I am a string"
or
""
The quotes are not part of the string, but serve only to delimit it. The same escape sequences used in character constants apply in strings; \" represents the double-quote character. String constants can be concatenated at compile time:
"hello," " world"
is equivalent to
"hello, world"
This is useful for splitting long strings across several source lines.
Technically, a string constant is an array of characters. The internal representation of a string has a null character ' \0' at the end, so the physical storage required is one more than the number of characters written between the quotes. This representation means that there is no limit to how long a string can be, but programs must scan a string completely to determine its length.
The standard library function strlen (s) returns the length of its character
represents the character with value zero, the
#defineLEAP1 1*inleapyears*1
int days[31+28+LEAP+31+30+31+30+31+31+30+31+30+31];
1* the empty string *1

 SECTION 2.3
string argument s, excluding the terminal ' \ 0 '.
1* strlen: returnlengthofs*1 int strlen(char s[])
{
int i;
i =0;
while(s[i] I='0\')
++i; returni;
}
CONSTANTS 39 Here is our version:
strlen <string.h>.
Be careful to distinguish between a character constant and a string that con- tains a single character: ' x' is not the same as "x". The former is an integer, used to produce the numeric value of the letter x in the machine's character set. The latter is an array of characters that contains one character (the letter x) anda '\0'.
There is one other kind of constant, the enumeration constant. An enumeration is a list of constant integer values, as in
enum boolean { NO, YES };
The first name in an enum has value 0, the next 1, and so on, unless explicit valuesarespecified.Ifnotallvaluesarespecified,unspecifiedvaluescontinue the progression from the last specified value, as in the second of these examples:
enum escapes { BELL = '\a', BACKSPACE = '\b', TAB = '\t', NEWLINE = '\n', VTAB = '\v', RETURN = '\r' };
enum months { JAN = 1, FEB, MAR, APR, MAY, JUN, JUL, AUG, SEP, OCT, NOV, DEC };
1* FEB is 2, MAR is 3, etc.*1
Names in different enumerations must be distinct. Values need not be distinct in the same enumeration.
Enumerations provide a convenient way to associate constant values with names, an alternative to #define with the advantage that the values can be generated for you. Although variables of enum types may be declared, com- pilers need not check that what you store in such a variable is a valid value for the enumeration. Nevertheless, enumeration variables offer the chance of checking and so are often better than #defines. In addition, a debugger may be able to print values of enumeration variables in their symbolic form.
and other string functions are declared in the standard header

 40 TYPES, OPERATORS AND EXPRESSIONS CHAPTER 2 2.4 Declarations
All variables must be declared before use, although certain declarations can be made implicitly by context. A declaration specifies a type, and contains a list of one or more variables of that type, as in
int lower, upper, step; char c, line[1000];
Variables can be distributed among declarations in any fashion; the lists above could equally well be written as
int lower;
int upper;
int step;
char c;
char line[1000];
This latter form takes more space, but is convenient for adding a comment to each declaration or for subsequent modifications.
Avariablemayalsobeinitializedinitsdeclaration.Ifthenameisfollowed by an equals sign and an expression, the expression serves as an initializer, as in
char esc='\\';
int i=0;
int limit =MAXLINE+1; float eps =1.0e-5;
If the variable in question is not automatic, the initialization is done once only, conceptually before the program starts executing, and the initializer must be a constant expression. An explicitly initialized automatic variable is initial- ized each time the function or block it is in is entered; the initializer may be any expression. External and static variables are initialized to zero by default. Automatic variables for which there is no explicit initializer have undefined
(i.e., garbage) values.
The qualifier const can be applied to the declaration of any variable to
specifythatitsvaluewillnotbechanged.Foranarray,theconstqualifier says that the elements will not be altered.
const double e =2.71828182845905; const char msg[] ="warning: ";
Theconstdeclarationcanalsobeusedwitharrayarguments,toindicatethat the function does not change that array:
int strlen(const char[]);
Theresultisimplementation-definedifanattemptismadetochangeaconst.

 SECTION 2.6 RELATIONAL AND LOGICAL OPERATORS 41 2.5 Arithmetic Operators
The binary arithmetic operators are +, -, *, /, and the modulus operator %. Integer division truncates any fractional part. The expression
x"y
producestheremainderwhenxisdividedbyy,andthusiszerowhenydivides x exactly. For example, a year is a leap year if it is divisible by 4 but not by 100, except that years divisible by 400 are leap years. Therefore
if«year" 4==0&&year" 1001=0)::year%400==0) printf(lI"d is a leap year\nllt year);
else
printf(11%<1 isnotaleapyear\nIIt year);
The %operator cannot be applied to float or double. The direction of trun- cation for / and the sign of the result for % are machine-dependent for negative operands, as is the action taken on overflowor underflow.
The binary + and - operators have the same precedence, which is lower than the precedence of *, /, and %, which is in turn lower than unary + and -. Arithmetic operators associate left to right.
Table 2-1 at the end of this chapter summarizes precedence and associativity for all operators.
2.6 Relational and Logical Operators
The relational operators are > >= < <=
They all have the same precedence. Just below them in precedence are the equality operators:
-- 1=
Relational operators have lower precedence than arithmetic operators, so an expressionlikei<1im-1istakenasi<(lim-1),aswouldbeexpected.
More interesting are the logical operators ss, and 1I. Expressionsconnected by &.&. or I I are evaluated left to right, and evaluation stops as soon as the truth or falsehood of the result is known. Most C programs rely on these properties. Forexample,hereisaloopfromtheinputfunctiongetline thatwewrotein Chapter 1:
for (i=O; i<lim-1 && (c=getchar(» 1= '\n' && c 1= EOF; ++i) s[i] =c;
Before reading a new character it is necessary to check that there is room to storeitinthearrays,sothetesti<lim-1mustbemadefirst.Moreover,if this test fails, we must not go on and read another character.

 41 TYPES, OPERATORS AND EXPRESSIONS CHAPTER 2
Similarly, it would be unfortunate if c were tested against EOF before getchar is called; therefore the call and assignment must occur before the character in c is tested.
The precedence of &.&. is higher than that of I I, and both are lower than relational and equality operators, so expressions like
i<lim-1&&(c=getchar(» 1='\n'&&c1=EOF
need no extra parentheses. But since the precedence of I=is higher than assignment, parentheses are needed in
(c=getchar(» 1='\n'
toachievethedesiredresultofassignmenttocandthencomparisonwith'\n'. By definition, the numeric value of a relational or logical expression is 1 if
the relation is true, and 0 if the relation is false.
The unary negation operator I converts a non-zero operand into 0, and a
zero operand into 1. A common use of I is in constructions like if (Ivalid)
rather than
if (valid == 0)
It's hard to generalize about which form is better. Constructions like Ivalid read nicely ("if not valid"), but more complicated ones can be hard to under- stand.
Exercise 2-2. Write a loop equivalent to the for loop above without using &.&. or II. 0
2.7 Type Conversions
When an operator has operands of different types, they are converted to a common type according to a small number of rules. In general, the only automatic conversions are those that convert a "narrower" operand into a "wider" one without losing information, such as converting an integer to floating point in an expression like f + i. Expressions that don't make sense, like using a float as a subscript, are disallowed. Expressions that might lose infor- mation, like assigning a longer integer type to a shorter, or a floating-point type to an integer, may draw a warning, but they are not illegal.
A char is just a small integer, so chars may be freely used in arithmetic expressions. This permits considerable flexibility in certain kinds of character transformations. One is exemplified by this naive implementation of the func- tion atoi, which converts a string of digits into its numeric equivalent.

 SECTION 2.7
TYPE CONVERSIONS 43
1* atoi: convertstointeger*1 int atoi(char s[])
{
int i, n;
n =0;
for (i = 0; s[i] >= '0' && s[i] <= '9'; ++i)
n =10 * n + (s[i] - '0'); return n;
}
As we discussed in Chapter 1, the expression
s[i] - '0'
givesthenumericvalueofthecharacterstoredins[i],becausethevaluesof , 0 " ' 1 " etc., form a contiguous increasing sequence.
Anotherexampleofchartointconversionisthefunctionlower,which mapsasinglecharactertolowercasefortheASCIIcharacterset.Ifthechar- acter is not an upper case letter, lower returns it unchanged.
1* lower: convertctolowercase;ASCIIonly*1 int lower(int c)
{
}
if (c >= 'A' && c <= 'Z') return c + 'a' - 'A';
else
return c;
This works for ASCII because corresponding upper case and lower case letters are a fixed distance apart as numeric values and each alphabet is contiguous- there is nothing but letters between A and Z. This latter observation is not true of the EBCDIC character set, however, so this code would convert more than
just letters in EBCDIC. Thestandardheader<ctype.h>,describedinAppendixB,definesafamily
of functions that provide tests and conversions that are independent of character set. For example, the function tolower (c) returns the lower case value of c if c is upper case, so tolower is a portable replacement for the function
lower shownabove. Similarly, the test c >= '0'&&c <= '9'
can be replaced by
isdigit(c)
Wewillusethe <ctype .h> functionsfromnowon.
There is one subtle point about the conversionof characters to integers. The
language does not specify whether variables of type char are signed or unsigned quantities. When a char is converted to an int, can it ever produce a negative integer? The answer .varies from machine to machine, reflecting

 44 TYPES,OPERATORSAND EXPRESSIONS CHAPTER2
differences in architecture. On some machines a char whose leftmost bit is 1 will be converted to a negative integer ("sign extension"). On others, a char is promoted to an int by adding zeros at the left end, and thus is always positive.
The definition of C guarantees that any character in the machine's standard printing character set will never be negative, so these characters will always be positive quantities in expressions. But arbitrary bit patterns stored in 'character variables may appear to be negative on some machines, yet positive on others. For portability, specify signed or unsigned if non-character data is to be stored in char variables.
Relational expressions like .i > j and logical expressions connected by &.&. and I I are defined to have value 1 if true, and 0 if false. Thus the assignment
d=C >= '0'&&c <= '9'
sets d to 1 if c is a digit, and 0 if not. However, functions like isdigi t may return any non-zero value for true. In the test part of if, while, for, etc., "true" just means "non-zero," so this makes no difference.
Implicit arithmetic conversions work .much as expected. In general, if an operator like + or * that takes two operands (a binary operator) has operands of different types, the "lower" type is promoted to the "higher" type before the operation proceeds. The result is of the higher type. Section 6 of Appendix A statestheconversionrulesprecisely.Iftherearenounsigned operands,how- ever, the following informal set of rules will suffice:
If either operand is long double, convert the other to long double. Otherwise, if either operand is double, convert the other to double. Otherwise, if either operand is float, convert the other to float. Otherwise, convert char and short to into
Then, if either operand is long, convert the other to long.
Notice that floats in an expression are not automatically converted to double; this is a change from the original definition. In general, mathematical functions like those in <math. h> will use double precision. The main reason for using float is to save storage in large arrays, or, less often, to save time on machines where double-precision arithmetic is particularly expensive.
Conversion rules are more complicated when uns igned operands are involved. The problem is that comparisons between signed and unsigned values are' machine-dependent" because they depend on the sizes of the various integer types. For example, suppose that int is 16 bits and long is 32 bits. Then -1L < 1U,because 1U,which is an int, is promoted to a signed long. But -1L > 1UL, because -1L is promoted to unsigned long and thus appears to be a large positive number.
Conversions take place across assignments; the value of the right side is con- verted to the type of the left, which is the type of the result.

 SECTION 2.7 TYPE CONVERSIONS 4S
A character is converted to an integer, either by sign extension or not, as described above.
Longer integers are converted to shorter ones or to chars excesshigh-orderbits. Thusin
int i; char c;
i =c; c =i;
by dropping the
the value of c is unchanged. This is true whether or not sign extension is involved. Reversing the order of assignments might lose information, however.
Ifxisfloat andiisint, thenx=iandi=xbothcauseconversions; float to int causes truncation of any fractional part. When double is con- verted to float, whether the value is rounded or truncated is implementation-
dependent.
Since an argument of a function call is an expression, type conversions also
take place when arguments are passed to functions. In the absence of a func- tion prototype, char and short become int, and float becomes double. This is why we have declared function arguments to be int and double even when the function is called with char and f loa t.
Finally, explicit type conversions can be forced ("coerced") in any expres- sion, with a unary operator called a cast. In the construction
(type-name) expression
the expression is converted to the named type by the conversion rules above. The precise meaning of a cast is as if the expression were assigned to a variable of the specified type, which is then used in place of the whole construction. For example, the library routine sqrt expects a double argument, and will pro- duce nonsense if inadvertently handed something else. (sqrt is declared in
<math•h>.) Soifnisaninteger,wecanuse
sqrt«double) n)
to convert the value of n to double before passing it to sqrt. Note that the cast produces the value of n in the proper type; n itself is not altered. The cast operator has the same high precedence as other unary operators, as summarized in the table at the end of this chapter.
If arguments are declared by a function prototype, as they normally should be, the declaration causes automatic coercion of any arguments when the func- tion is called. Thus, given a function prototype for sqrt:
double sqrt(double);
the call
root2 =sqrt(2);
coerces the integer 2 into the double value 2.0 without any need for a cast.

 46 TYPES, OPERATORS AND EXPRESSIONS CHAPTER 2
The standard library includes a portable implementation of a pseudo-random number generator and a function for initializing the seed; the former illustrates a cast:
unsigned long int next = 1;
1* rand: returnpseudo-randomintegeron0..32767*1 int rand(void)
{
next =next * 1103515245 + 1234S;
return (unsigned int)(next/65536) " 32768;
}
1* srand: setseedforrand()*1 void srand(unsigned int seed)
{
next =seed;
}
Exercise2·3.Writethefunctionhtoi(s),whichconvertsastringofhexa- decimal digits (including an optional Ox or ox) into its equivalent integer value. Theallowabledigitsare0through9,athroughf,andAthroughF.0
2.8 Increment and Decrement Operators
C provides two unusual operators for incrementing and decrementing vari- ables. The increment operator ++ adds 1 to its operand, while the decrement operator -- subtracts 1. We have frequently used ++ to increment variables, as in
if (c == \'n') ++nl;
The unusual aspect is that ++ and -- may be used either as prefix operators (before the variable, as in ++n), or postfix (after the variable: n++). In both cases,theeffectistoincrementn. Buttheexpression+-nincrementsnbefore its value is used, while n« + increments n after its value has been used. This means that in a context where the value is being used, not just the effect, ++n
andn++aredifferent.Ifnis5,then x =n++;
sets x to 5, but
x =++n;
sets x to 6. In both cases, n becomes 6. The increment and decrement opera- torscanonlybeappliedtovariables;anexpressionlike(i+j)++isillegal.

 SECTION 2.8 INCREMENT AND DECREMENT OPERA TORS 47 In a context where no value is wanted, just the incrementing effect, as in
if (c == ' \n') nl++;
prefix and postfix are the same. But there are situations where one or the other is specifically called for. For instance, consider the function squeeze (S, C), which removes all occurrences of the character c from the string s.
1* squeeze: delete all c from s *1 void squeeze(char s[], int c)
{
}
Each time a non-e occurs, it is copied into the current j position, and only then is j incremented to be ready for the next character. This is exactly equivalent to
if (s[i] 1= c) { s[j] = s[i];
j++;
}
Another example of a similar construction comes from the get! ine func- tion that we wrote in Chapter 1, where we can replace
if (c -- '\n') { s[i] = c;
++i;
}
by the more compact
if (c == \'n') s[i++] =c;
As a third example, consider the standard function strcat (s, t), which concatenates the string t to the end of the string s. strcat assumes that there is enough space in s to hold the combination. As we have written it,
strcat returns no value; the standard library version returns a pointer to the resulting string.
int i, j;
for (i =j = 0; s[i] 1= '\0'; i++) if (s[i] 1=c)
s[j++] =s[i]; s[j] = '\0';

 48
TYPES, OPERATORSAND EXPRESSIONS CHAPTER 2
1* strcat: concatenate t to end of s; s must be big enough *1 void strcat(char s[], char t[])
{
} Aseachcharacteriscopiedfromttos,thepostfix++isappliedtobothiand
j to make sure that they are in position for the next pass through the loop. Exercise 2-4. Write an alternate version of squeeze (s 1,s2) that deletes
each character in s 1 that matches any character in the string s2. 0
Exercise2-5. Writethefunctionany(s1,s2), whichreturnsthefirstlocation in the string s 1 where any character from the string s2 occurs, or -1 if s 1 contains no characters from s2. (The standard library function strpbrk does the same job but returns a pointer to the location.) 0
2.9 Bitwise Operators
C provides six operators for bit manipulation; these may only be applied to integral operands, that is, char, short, int, and long, whether signed or unsigned.
s, bitwise AND
bitwise inclusive OR
bitwise exclusive OR << left shift
>> right shift
one's complement (unary)
The bitwise AND operator & is often used to mask off some set of bits; for example,
n =n & 0177;
sets to zero all but the low-order 7 bits of n.
The bitwise OR operator. I is used to turn bits on: x=x ISET_ON;,
sets to one in x the bits that are set to one in SET_ON.
The bitwise exclusive OR operator ,. sets a one in each bit position where its
operands have different bits, and zero where they are the same.
int i, j;
i = j = 0;
while (s[i] 1= '\0') 1* find end of s *1
i++;
while «s[i++] = t[j++]) 1= '\0') 1* copy t *1

 SECTION 2.9 BITWISE OPERATORS 49
One must distinguish the bitwise operators & and from the logical opera- tors && and I I, which imply left-to-right evaluation of a truth value. For example,ifxisIandyis2,thenx &yiszerowhilex &&yisone.
The shift operators « and » perform left and right shifts of their left operand by the number of bit positions given by the right operand, which must be positive. Thus x < < 2 shifts the value of x left by two positions, filling vacated bits with zero; this is equivalent to multiplication by 4. Right shifting an unsigned quantity always fills vacated bits with zero. Right shifting a signed quantity will fill with sign bits ("arithmetic shift") on some machines and with O-bits ("logical shift") on others.
The unary operator - yields the one's complement of an integer; that is, it converts each I-bit into a O-bit and vice versa. For example,
x =x&-077
sets the last six bits of x to zero. Note that x & - 077 is independent of word length, and is thus preferable to, for example, x & 0177700, which assumes that x is a 16-bit quantity. The portable form involves no extra cost, since
- 077 is a constant expression that can be evaluated at compile time.
As an illustration of some of the bit operators, consider the function getbi ts ( x , p , n ) that returns the (right adjusted) n-bit field of x that begins
at position p. We assume that bit position 0 is at the right end and that nand p are sensible positive values. For example, getbi ts (x, 4 , 3) returns the three bits in bit positions 4, 3 and 2, right adjusted.
1*getbits:getnbitsfrompositionp*1 unsigned getbits(unsigned x, int p, int n)
{
return (x » (p+1-n» & -(-0 « n); }
The expression x > > (p+ 1-n) moves the desired field to the right end of the word. - 0 is all l-bits; shifting it left n bit positions with - 0 < <n places zeros in the rightmost n bits; complementing that with - makes a mask with ones in the rightmost n bits.
Exercise 2-6. Write a function setbits(x,p,n,y) that returns x with the n bits that begin at position p set to the rightmost n bits of y, leaving the other bits unchanged. 0
Exercise 2-7. Write a function invert(x,p,n) that returns x with the n bits that begin at position p inverted (i.e., I changed into 0 and vice versa), leaving the others unchanged. 0
Exercise 2-8. Write a function rightrot(x,n) that returns the value of the integer x rotated to the right by n bit positions. 0

 50 TYPES, OPERATORS AND EXPRESSIONS CHAPTER 2
2.10 Assignment Operators and Expressions
Expressionssuch as i=i+2
in which the variable on the left hand side is repeated immediately on the right, can be written in the compressed form
i += 2
The operator +=is called an assignment operator.
Most binary operators (operators like + that have a left and right operand)
have a corresponding assignment operator op =, where op is one of +*I"«»
Ifexpr,andexpr2areexpressions,then expr , op =expr2
is equivalent to
expr , = iexpr i ) op (expr2)
except that expr , is computed only once. Notice the parentheses around expr-:
x *= y + 1 means
x =x * (y + 1) rather than
Asanexample,thefunctionbitcount countsthenumberofl-bitsinits integer argument.
1* bitcount: count 1 bits in x *1 int bitcount(unsigned x)
{
int b;
for(b=0;x1=0;x»= 1) if (x s, 01)
b++; return b;
}
Declaringtheargumentxtobeunsigned ensuresthatwhenitisright-shifted, vacated bits will be filled with zeros, not sign bits, regardless of the machine the program is run on.
Quite apart from conciseness, assignment operators have the advantage that they correspond better to the way people think. We say "add 2 to i" or

 SECTION 2.11 CONDITIONAL EXPRESSIONS 51
"increment i by 2," not "take i, add 2, then put the result back in i." Thus theexpressioni+=2ispreferabletoi=i+2.Inaddition,foracomplicated expression like
yyval[yypv[p3+p4] + yypv[p1+p2]] += 2
the assignment operator makes the code easier to understand, since the reader doesn't have to check painstakingly that two long expressions are indeed the same, or to wonder why they're not. And an assignment operator may even help a compiler to produce efficient code.
We have already seen that the assignment statement has a value and can occur in expressions; the most common example is
while «c = getchar(» 1=EOF)
The other assignment operators (+=, -=, etc.) can also occur in expressions, although this is less frequent.
In all such expressions, the type of an assignment expression is the type of its left operand, and the value is the value after the assignment.
Exercise 2-9. In a two's complement number system, x &.= (x-1) deletes the rightmost l-bit in x. Explain why. Use this observation to write a faster ver- sionof bitcount. 0
2.11 Conditional Expressions
The statements
if (a > b) z =a',
else
z =b;
compute in z the maximum of a and b. The conditional expression, written withtheternaryoperator"?:",providesanalternatewaytowritethisand similar constructions. In the expression
exprI ? expr2 : expr3
theexpressionexpr1isevaluatedfirst.Ifitisnon-zero(true),thentheexpres- sion expr-. is evaluated, and that is the value of the conditional expression. Otherwise expr , is evaluated, and that is the value. Only one of expr- and expr3isevaluated.Thustosetztothemaximumofaandb,
z=(a> b)?a:b; 1* z=max(a,b) *1
Itshouldbenotedthattheconditionalexpressionisindeedanexpression, and it can be used wherever any other expression can be. If expr-. and expr3

 52 TYPES, OPERA TORS AND EXPRESSIONS CHAPTER 2
are of different types, the type of the result is determined by the conversion rulesdiscussedearlierinthischapter.Forexample,iffisafloatandnisan int, then the expression
(n>0)? f : n
isoftypefloat regardlessofwhethernispositive.
Parentheses are not necessary around the first expression of a conditional
expression,sincetheprecedenceof?:isverylow,justaboveassignment.They are advisable anyway, however, since they make the condition part of the expression easier to see.
The conditional expression often leads to succinct code. For example, this loop prints n elements of an array, 10 per line, with each column separated by one blank, and with each line (including the last) terminated by a newline.
for (i = 0; i < n; i++)
printf( ""6d"c", a[i], (i%10==9 :: i==n-1) ? '\n' : ' ');
A newline is printed after every tenth element, and after the n-th. All other elements are followed by one blank. This might look tricky, but it's more com- pactthantheequivalentif-else. Anothergoodexampleis
printf("You have %d item%s.\n", · n, n==1 ? "" : "s"); Exercise2-10.Rewritethefunctionlower,whichconvertsuppercaseletters
tolowercase,withaconditionalexpressioninsteadofif-else. 0
2. 12 Precedence and Order of Evaluation
Table 2-1 summarizes the rules for precedence and associativity of all opera- tors, including those that we have not yet discussed. Operators on the same line have the same precedence; rows are in order of decreasing precedence, so, for example, *, I, and" all have the same precedence, which is higher than that of binary + and -. The "operator" () refers to function call. The operators -> and • are used to access members of structures; they will be covered in Chapter 6, along with sizeof (size of an object). Chapter 5 discusses * (indirection through a pointer) and &. (address of an object), and Chapter 3 discusses the comma operator.
Note that the precedenceof the bitwise operators &, ''', and I falls below == and I =. This implies that bit-testing expressions like
if « x & MASK) == 0) ...
must be fully parenthesized to give proper results.
C, like most languages, does not specify the order in which the operands of
anoperatorareevaluated.(Theexceptionsaress,II,?:,and','.)For example, in a statement like

 SECTION 2.12
PRECEDENCE AND ORDER OF EVALUATION 53
TABLE 2-1.
PRECEDENCE AND ASSOCIATIVITYOF OPERATORS
( ) .. [ ] ->
++ -- + - * s, (type)
sizeof
*
+ «»
I"
< <= > >=
-- &.
&&
II II
?:
1=
OPERATORS
ASSOCIATIVITY
left to right right to left left to right left to right left to right left to right left to right Ieit to right left to right left to right left to right left to right right to left right to left left to right
=+=-= *= 1=%=&=A=1=«= »=
Unary +, -, and * have higher precedence than the binary forms. x = f() + g();
f may be evaluated before g or vice versa; thus if either f or g alters a variable on which the other depends, x can depend on the order of evaluation. Inter- mediate results can be stored in temporary variables to ensure a particular sequence.
Similarly, the order in which function arguments are evaluated is not speci- fied, so the statement
printf (""d %d\n", ++n, power(2, n»; 1* WRONG *1
can produce different results with different compilers, depending on whether n
is incremented before power is called. The solution, of course, is to write
++n;
printf( ""d %d\n", n, power(2, n»;
Function calls, nested assignment statements, and increment and decrement operators cause "side effects" -some variable is changed as a by-product of the evaluation of an expression. In any expression involving side effects, there can be subtle dependencies on the order in which variables taking part in the expres- sion are updated. One unhappy situation is typified by the statement
a[i] = i++;
The question is whether the subscript is the old value of i or the new.

 54 TYPES, OPERATORS AND EXPRESSIONS CHAPTER 2
Compilers can interpret this in different ways, and generate different answers depending on their interpretation. The standard intentionally leaves most such matters unspecified. When side effects (assignment to variables) take place within an expression is left to the discretion of the compiler, since the best order depends strongly on machine architecture. (The standard does specify that all side effects on arguments take. effect before a function is called, but that would nothelpinthecalltoprintf above.)
The moral is that writing code that depends on order of evaluation is a bad programming practice in any language. Naturally, it is necessary to know what things to avoid, but if you don't know how they are done on various machines, you won't be tempted to take advantage of a particular implementation.

 CHAPTER 3: Control Flow
The control-flow statements of a language specify the order in which compu- tations are performed. We have already met the most common control-flow constructions in earlier examples; here we will complete the set, and be more precise about the ones discussed before.
3.1 Statements and Blocks
An expressionsuch as x = 0 or i++ or printf (...) becomesa statement
when it is followedby a semicolon,as in
x =0; i++; printf (...);
In C, the semicolonis a statement terminator, rather than a separator as it is in languages like Pascal.
Braces { and} are used to group declarations and statements together into a compound statement, or block, so that they are syntactically equivalent to a single statement. The braces that surround the statements of a function are one obviousexample;bracesaroundmultiplestatementsafteranif,else,while, orfor areanother. (Variablescanbedeclaredinsideanyblock;wewilltalk about this in Chapter 4.) There is no semicolon after the right brace that ends a block.
3.2 If-Else
Theif-else statementisusedtoexpressdecisions.Formally,thesyntaxis
if (expression) statement 1
else
statement 2
55

 56 CONTROL FLOW CHAPTER 3
where the else part is optional. The expression is evaluated; if it is true {that is,if>expressionhasanon-zerovalue},statement1isexecuted.Ifitisfalse {expression is zero} and if there is an else part, statement 2 is executed
instead.
Since an if simply tests the numeric value of an expression, certain coding
shortcuts are possible. The most obvious is writing if ( expression)
instead of
if (expression 1= 0)
Sometimes this is natural and clear; at other times it can be cryptic.
Because the else part of an if-else is optional, there is an ambiguity when an else is omitted from a nested if sequence. This is resolved by asso-
ciating the else with the closest previous else-less if. For example, in
if (n > 0) if(a> b)
z =a; else
z =b; theelsegoeswiththeinnerif,aswehaveshownbyindentation.Ifthatisn't
what you want, braces must be used to force the proper association:
if (n > 0) {
if (a>b)
z =a; }
else
z =b;
The ambiguity is especially pernicious in situations like this:
if(n>= 0)
for (i =0; i < n; i++)
if (s[i] >0) { printf( "..n.);
return i;
}
printf("error -- n is neqative\n");
The indentation shows unequivocally what you want, but the compiler doesn't get the message, and associates the else with the inner if. This kind of bug can be hard to find; it's a good idea to use braces when there are nested ifs.
By the way, notice that there is a semicolon after z =a in

 SECTION 3.3 ELSE·IF 57
if (a> b) z =a;
else
z =b;
Thisisbecausegrammatically,astatementfollowstheif,andanexpression statement like "z =a;" is always terminated by a semicolon.
3.3 Else-If
The construction
if (expression) statement
else if (expression) statement
else if (expression) statement
else if (expression) statement
else
statement
occurssooftenthatitisworthabriefseparatediscussion.Thissequenceofif statements is the most general way of writing a multi-way decision. The expressions are evaluated in order; if any expression is true, the statement asso- ciated with it is executed, and this terminates the whole chain. As always, the code for each statement is either a single statement, or a group in braces.
Thelastelseparthandlesthe"noneoftheabove"ordefaultcasewhere none of the other conditions is satisfied. Sometimes there is no explicit action for the default; in that case the trailing
else
statement
can be omitted, or it may be used for error checking to catch an "impossible" condition.
To illustrate a three-way decision, here is a binary search function that decides if a particular value x occurs in the sorted array v. The elements of v must be in increasing order. The function returns the position (a number between 0 and n-1) if x occurs in v, and -1 if not.
Binary search first compares the input value x to the middle element of the arrayv. Ifxislessthanthemiddlevalue,searchingfocusesonthelowerhalf of the table, otherwise on the upper half. In either case, the next step is to com- pare x to the middle element of the selected half. This process of dividing the range in two continues until the value is found or the range is empty.

 58 CONTROL FLOW CHAPTER 3
1*binsearch:findxinv[O]<=v[1]<= ••• <=v[n-1]*1 int binsearch(int x, int v[], int n)
{
int low, high, mid;
low =0;
high =n - 1;
while (low <= high) {
mid =(low+high) I 2; if (x < v[mid])
high = mid - 1; else if (x > v[mid])
low =mid + 1;
else 1* foundmatch *1
return mid; return-1; 1*nomatch*1
} }
The fundamental decision is whether x is less than, greater than, or equal to the middleelementv[mid]ateachstep;thisisanaturalforelse-if.
Exercise 3-1. Our binary search makes two tests inside the loop, when one would suffice (at the price of more tests outside). Write a version with only one test inside the loop and measure the difference in run-time. 0
3.4 Switch
Theswitchstatementisamulti-waydecisionthattestswhetheranexpres- sion matches one of a number of constant integer values, and branches accord- ingly.
switch (expression) case const-expr: case const-expr i
{
statements statements
default: statements }
Each case is labeled by one or more integer-valued constants or constant expres- sions.Ifacasematchestheexpressionvalue,executionstartsatthatcase.All caseexpressionsmustbedifferent.Thecaselabeleddefaultisexecutedif noneoftheothercasesaresatisfied.Adefault isoptional;ifitisn'tthere and if none of the cases match, no action at all takes place. Cases and the default clause can occur in any order.
In Chapter 1 we wrote a program to count the occurrences of each digit, white space, and all other characters, using a sequence of if ... else if ... else. Hereisthesameprogramwithaswitch:

 SECTION 3.4
SWITCH 59
#include <stdio.h>
main() 1*countdigits,whitespace,others*1 {
int c, i, nwhite, nother, ndigit[10];
nwhite =nother = 0;
for (i =0; i < 10; i++)
ndigit[i] =0;
while «c = getchar(» 1= EOF) {
switch (c) {
case '0': case '1': case '2': case '3': case '4': case '5': case '6': case '7': case '8': case '9':
ndigit[c-'O']++;
bre_k; case, '.
case '\n': case '\t':
nwhite++;
break; default:
} }
nother++;
break;
printf("digits =");
for (i =0; i < 10; i++)
printf(n %dn, ndigit[i]);
print~(n, whit:espace =%d, other =%d\n",
nwhite, nother); return 0;
}
The break statement causes an immediate exit from the switch. Because
cases serve just as labels, after the code for one case is done, execution falls through to the next unless you take explicit action to escape. break and returnarethemostcommonwaystoleaveaswitch.Abreakstatement can also be used to force an immediate exit from while, for, and do loops,as will be discussed later in this chapter.
Falling through cases is a mixed blessing. On the positive side, it allows several cases to be attached to a single action, as with the digits in this example. But it also implies that normally each case must end with a break to prevent falling through to the next. Falling through from one case to another is not robust, being prone to disintegration when the program is modified. With the exception of multiple labels for a single computation, fall-throughs should be used sparingly, and commented.
As a matter of good form, put a break after the last case (the default here) even though it's logically unnecessary. Some day when another case gets added at the end, this bit of defensive programming will save you.

 60 CONTROL FLOW CHAPTER 3
Exercise 3-2. Write a function escape (s, t) that converts characters like newlineandtabintovisibleescapesequenceslike\nand\tasitcopiesthe string t to s. Use a switch. Write a function for the other direction as well, converting escape sequences into the real characters. 0
3.5 Loops-While and For Wehavealreadyencounteredthewhileandfor loops.In
while (expression) statement
theexpressionisevaluated.Ifitisnon-zero,statementisexecutedandexpres- sion is re-evaluated. This cycle continues until expression becomes zero, at which point execution resumes after statement.
The for statement
for (exprl; exprs ; exprc)
statement
is equivalent to
expri ;
while (expr2) {
statement
expr3;
}
except for the behavior of continue, which is described in Section 3.7. Grammatically, the three components of a for loop are expressions. Most commonly, expr 1 and expr 3 are assignments or function calls and expr 2 is a relational expression. Any of the three parts can be omitted, although the semi- colonsmustremain.Ifexpr,orexpr,isomitted,itissimplydroppedfromthe
expansion.Ifthetest,expr2,isnotpresent,itistakenaspermanentlytrue,so for (;;) {
}
isan"infinite"loop,presumablytobebrokenbyothermeans,suchasabreak or return.
Whethertousewhileorforislargelya.matterofpersonalpreference. For example, in
while «c. getchar(» ==" II e == '\n' II c =='\t') I.skipwhitespacecharacters.1
thereisnoinitializationorre-initialization,sothewhileismostnatural.
The for is preferable when there is a simple initialization and increment, since it keeps the loop control statements close together and visible at the top of

 SECTION 3.S LOOPS- WHILE AND FOR 61 the loop. This is most obvious in
for(i=0;i<n; i++)
which is the C idiom for processing the first n elements of an array, the analog oftheFortranDOlooporthePascalfor. Theanalogyisnotperfect,however, sincetheindexandlimitofaCforloopcanbealteredfromwithintheloop, and the index variable i retains its value when the loop terminates for any rea- son.Becausethecomponentsoftheforarearbitraryexpressions,forloops are not restricted to arithmetic progressions. Nonetheless, it is bad style to force unrelated computations into the initialization and increment of a for, which are better reserved for loop control operations.
Asalargerexample,hereisanotherversionofatoi forconvertingastring to its numeric equivalent. This one is slightly more general than the one in Chapter 2; it copes with optional leading white space and an optional + or - sign. (Chapter 4 shows atof, which does the same conversion for floating- point numbers.)
The structure of the program reflects the form of the input:
skip white space, if any
get sign, if any
get integer part and convert it
Each step does its part, and leaves things in a clean state for the next. The whole process terminates on the first character that could not be part of a number.
#include <ctype.h>
1* atoi: convert s to integer; version 2 *1 int atoi(char s[])
{
int i, n, sign;
for (i =0; isspace(s[i]); i++) 1* skip white space *1
sign=(s[i]==#_#)? -1 : 1;
if (s[i] =-#+# I I s[i] ==#_#) 1* skip sign *1
i++;
for (n - 0; isdigit(s[i]); i++)
n=10*n+ (s[i]-#0#); return sign * n;
}
The standard library providesa more elaborate function strtol of strings to long integers; see Section 5 of Appendix B.
for conversion
The advantages of keeping loop control centralized are even more obvious when there are several nested loops. The following function is a Shell sort for sorting an array of integers. The basic idea of this sorting algorithm, which was

 62 CONTROL FLOW CHAPTER 3
invented in 1959 by D. 1.. Shell, is that in early stages, far-apart elements are compared, rather than adjacent ones as in simpler interchange sorts. This tends to eliminate large amounts of disorder quickly, so later stages have less work to do. The interval between compared elements is gradually decreased to one, at which point the sort effectively becomes an adjacent interchange method.
I. shellsort: sort v[0]...v[n-1] into increasing order*1 void shellsort(int v[], int n)
{
}
int gap, i, j, temp;
for (gap = n/2; gap> 0; gap 1= 2) for (i = gap; i < n; i++)
for (j=i-gap; j>=O && v[j]>v[j+gap]; j-=gap) { temp = v[j];
v[j] = v[j+gap];
v[j+gap] = temp;
}
There are three nested loops. The outermost controls the gap between com- pared elements, shrinking it from n/2 by a factor of two each pass until it becomes zero. The middle loop steps along the elements. The innermost loop compareseachpairofelementsthatisseparatedbygapandreversesanythat are out of order. Since gap is eventually reduced to one, all elements are even- tuallyorderedcorrectly.Noticehowthegeneralityoftheformakestheouter loop fit the same form as the others, even though it is not an arithmetic progres- sion.
One final C operator is the comma " , ", which most often finds use in the forstatement.Apairofexpressionsseparatedbyacommaisevaluatedleftto right, and the type and value of the result are the type and value of the right
operand. Thus in a for statement, it is possibleto place multiple expressionsin the various parts, for example to process.two indices in parallel. This is illus- trated in the function reverse (s ), which reversesthe string s in place.
#include <string.h>
1*reverse: reversestringsinplace*1 void reverse(char s[])
{
} }
int e, i, j;
for (i = 0, j = strlen(s)-1; i < j; i++, j--) { c =s[i];
8[1]=s[j];
s[j] =c;

 SECTION 3.6 LooPS-OO-WHILE 63
The commas that separate function arguments, variables in declarations, etc., are not comma operators, and do not guarantee left to right evaluation.
Comma operators should be used sparingly. The most suitable uses are for constructs strongly related to each other, as in the for loop in reverse, and in macros where a multistep computation has to be a single expression. A comma expression might also be appropriate for the exchange of elements in reverse, where the exchange can be thought of as a single operation:
for (i =0, j =strlen(s)-1; i < j; i++, j--) C =s[i], s[i] =s[j], s[j] =c;
Exercise 3-3. Write a function expand (s 1,s2) that expands shorthand nota- tions like a - z in the string s 1 into the equivalent complete list abc ... xyz in s2. Allow for letters of either case and digits, and be prepared to handle cases like a-b-c and a-zO-9 and -a-z. Arrange that a leading or trailing - is taken literally. 0
3.6 Loops-Do-whlle
As we discussed in Chapter 1, the while and for loops test the termination condition at the top. By contrast, the third loop in C, the do-while, tests at the bottom after making each pass through the loop body; the body is always executed at least once.
The syntax of the do is
do
statement
whi 1 e ( expression) ;
The statement is executed, then expression is evaluated.
is evaluated again, and so on. When the expression becomes false, the loop ter- minates. Except for the sense of the test, do-while is equivalent to the Pascal repeat-until statement.
Experience shows that do-while is much less used than while and for. Nonetheless, from time to time it is valuable, as in the following function i toa, which converts a number to a character string (the inverse of atoi). The job is slightly more complicated than might be thought at first, because the easy methods of generating the digits generate them in the wrong order. We have chosen to generate the string backwards, then reverse it.
If it is true, statement

 64 CONTROL FLOW
CHAPTER 3
1* itoa: convert n to characters in s*1 void itoa(int n, char s[])
{
}
int i, sign;
if «sign =n) < 0) 1* record sign *1
n =-n; 1* make n positive *1
i =0;
do { 1* generate digits in reverse order *1
s[i++] =n % 10 + '0'; }while «n 1= 10) > 0); if (sign < 0)
s[i++] = '-'; s[i] ='\0';
reverse(s);
1* get next digit *1 1*delete it*1
Thedo-while isnecessary,oratleastconvenient,sinceatleastonecharacter must be installed in the array s, even if n is zero. We also used braces around the single statement that makes up the body of the do-while, even though they are unnecessary, so the hasty reader will not mistake the while part for the beginning of a whi1e loop.
Exercise 3-4. In a two's complement number representation, our version of i toa does not handle the largest negative number, that is, the value of n equal to _(2wordsize-l). Explain why not. Modify it to print that value correctly,
regardless of the machine on which it runs. 0
Exercise3-5.Writethefunctionitob(n,s,b) thatconvertstheintegern into a base b character representation in the string s. In particular, i tob ( n , s, 16) formats n as a hexadecimal integer in s. 0
Exercise 3-6. Write a version of i toa that accepts three arguments instead of two. The third argument is a minimum field width; the converted number must be padded with blanks on the left if necessary to make it wide enough. 0
3.7 Break and Continue
Itissometimesconvenienttobeabletoexitfromaloopotherthanbytest- ing at the top or bottom. The break statement provides an early exit from for, while, and do, just as from switch. A break causes the innermost enclosingloopor switch to be exited immediately.
Thefollowingfunction,trim,removestrailingblanks,tabs,andnewlines fromtheendofastring,usingabreak toexitfromaloopwhentherightmost non-blank, non-tab, non-newline is found.

 SECTION 3.8 GOTO AND LABELS 65
1*trim: removetrailingblanks,tabs,newlines*1 int trim(char s[])
{
int n;
for (n = strlen(s)-1; n >= 0; n--)
if(s[n]I= ' , &&s[n]I= '\t'&&s[n]I= '\n')
break; s[n+1] = '\0';
return n;
}
strlen
scans backwards looking for the first character that is not a blank or tab or newline. The loop is broken when one is found, or when n becomes negative
(that is, when the entire string has been scanned). You should verify that this is correct behavior even when the string is empty or contains only white space characters.
The continue statement is related to break, but less often used; it causes the next iteration of the enclosing for, while, or do loop to begin. In the while and do, this means that the test part is executed immediately; in the for, control passes to the increment step. The continue statement applies only to loops, not to switch. A continue inside a switch inside a loop causes the next loop iteration.
As an example, this fragment processes only the non-negative elements in the array a; negative values are skipped.
for(i=0;i< n;i++){
if (a[i] < 0) 1* skip negative elements *1
continue;
1* do positive elements *1
}
The continue statement is often used when the part of the loop that followsis complicated, so that reversing a test and indenting another level would nest the program too deeply.
3.8 Goto and Labels
C provides the infinitely-abusable goto statement, and labels to branch to. Formally, the goto is never necessary, and in practice it is almost always easy to write code without it. We have not used goto in this book.
Nevertheless, there are a few situations where gotos may find a place. The most common is to abandon processing in some deeply nested structure, such as breaking out of two or more loops at once. The break statement cannot be used directly since it only exits from the innermost loop. Thus:
returns the length of the string. The for loop starts at the end and

 66 CONTROL FLOW
for ( ...)
for ( ...) {
if (disaster) goto error;
}
clean up the mess
CHAPTER 3
error:
This organization is handy if the error-handling code is non-trivial, and if errors can occur in several places.
A label has the same form as a variable name, and is followedby a colon. It can be attached to any statement in the same function as the qoto. The scope of a label is the entire function.
As another example, consider the problem of determining whether two arrays a and b have an element in common. One possibility is
for (i =0; i < n; i++) for (j=0; j < m; j++)
if (a[i] ==b[j]) goto found;
1* didn't find any common element *1 found:
1*gotone: a[i]==b[j]*1
Code involvinga qoto can always be written without one, though perhaps at the price of some repeated tests or an extra variable. For example, the array search becomes
found =0;
for (i = 0; i < n && Ifound; i++)
for(j=0;j< m&&Ifound;j++) if (a[i] ==b[j])
found =1;
1*gotone: a[i-1]==b[j-1]*1
else
1* didn't find any common element *1
With a few exceptions like those cited here, code that relies on qoto state- ments is generally harder to understand and to maintain than code without qotos. Although we are not dogmatic about the matter, it does seem that qotostatementsshouldbeusedrarely,ifatall.
if (found)

 CHAPTER 4: Functions and Program Structure
Functions break large computing tasks into smaller ones, and enable people to build on what others have done instead of starting over from scratch. Appropriate functions hide details of operation from parts of the program that don't need to know about them, thus clarifying the whole, and easing the pain of making changes.
C has been designed to make functions efficient and easy to use; C programs generally consist of many small functions rather than a few big ones. A pro- gram may reside in one or more source files. Source files may be compiled separately and loaded together, along with previously compiled functions from libraries. We will not go into that process here, however, since the details vary from system to system.
Function declaration and.definition is the area where the ANSI standard has made the most visible changes to C. As we saw first in Chapter 1, it is now possible to declare the types of arguments when a function is declared. The syntax of function definition also changes, so that declarations and definitions match. This makes it possible for a compiler to detect many more errors than it could before. Furthermore, when arguments are properly declared, appropriate type coercions are performed automatically.
The standard clarifies the rules on the scope of names; in particular, it requires that there be only one definition of each external object. Initialization is more general: automatic arrays and structures may now be initialized.
The C preprocessor has also been enhanced. New preprocessor facilities include a more complete set of conditional compilation directives, a way to create quoted strings from macro arguments, and better control over the macro expansion process.
4.1 Basicsof Functions
To begin, let us design and write a program to print each line of its input that contains a particular "pattern" or string of characters. (This is a special case of the UNIX program grep.) for example, searching for the pattern of
67

 68 FUNCTIONS AND PROGRAM STRUCTURE letters "ould"in the set of lines
Ah Lovel could you and I with Fate conspire To grasp this sorry Scheme of Things entire, Would not we shatter it to bits -- and then Re-mould it nearer to the Heart's DesireI
will produce the output
Ah Lovel could you and I with Fate conspire Would not we shatter it to bits -- and then Re-mould it nearer to the Heart's DesireI
The job falls neatly into three pieces:
while (there'sanotherline)
if (the line contains the pattern)
print it
CHAPTER 4
Although it's certainly possible to put the code for all of this in main, a better way is to use the structure to advantage by making each part a separate function. Three small pieces are easier to deal with than one big one, because irrelevant details can be buried in the functions, and the chance of unwanted interactions is minimized. And the pieces may even be useful in other pro- grams.
"While there's another line" is getline, a function that we wrote in Chapter1,and"printit"isprintf,whichsomeonehasalreadyprovidedfor us. This means we need only write a routine to decide whether the line contains an occurrence of the pattern.
We can solve that problem by writing a function strindex (s ,t) that returnsthepositionorindexinthestringswherethestringtbegins;.or-1if sdoesn'tcontaint. BecauseCarraysbeginatpositionzero,indexeswillbe zeroorpositive,andsoanegativevaluelike-1isconvenientforsignaling failure. When we later need more sophisticated pattern matching, we only have to replace strindex; the rest of the codecartremain the same. (Thestandard library providesa function strstr that is similar to strindex, except that it returns a pointer instead of an index.)
Given this much design, filling in the details of the program is straightfor- ward. Here is the whole thing, so you can see how the pieces fit together. For now, the pattern to be searched for is a literal string, which is not the most gen- eral of mechanisms. We will return shortly to a discussion of how to initialize character arrays, and in Chapter 5 will show how to make the pattern a param- eter that is set when the program is run. There is also a slightly different.ver- sion of getline; you might find it instructive to compare it to the one in Chapter 1.

 SECTION 4.1 BASICS OF FUNCTIONS 69 #include <stdio.h>
#define MAXLINE 1000 1* maximum input line length *1 int getline(char line[], int max);
int strindex(char source[], char searchfor[]);
char pattern[] = "ould"; 1* pattern to search for *1
1* find all lines matching pattern *1 main( )
{
char line[MAXLINE]; int found = 0;
while (getline(line, MAXLINE) > 0)
if (strindex(line, pattern) >= 0) {
printf("%s", line);
found++;
}
return found;
}
1* getline: get line into s, return length*1 int getline(char s[], int lim)
{
int c, i;
i =0;
while (--lim> 0 && (c=getchar(» 1= EOF && c 1= '\n')
s[i++] = c; if(c == '\n')
s[i++] = c; s[i] ='\0';
return i;
}
1*strindex: returnindexoftins,-1 ifnone*1 int strindex(char s[], char t[])
{
int i, j, k;
for (i = 0; s[i] 1= '\0'; i++) {
for (j=i, k=O; t[k]I='\O' && s[j]==t[k]; j++, k++)
;
if (k > 0&&t[k] == '\0') return i;
}
return -1;
}
Each function definition has the form

 70 FUNCTIONS AND PROGRAM STRUCTURE
CHAPTER 4
return-type function-name (argument declarations)
{
}
Various parts may be absent; a minimal function is
dummy() {}
which does nothing and returns nothing. A do-nothing function like this is sometimes useful as a place holder during program development. If the return type is omitted, int is assumed.
A program is just a set of definitions of variables and functions. Communi- cation between the functions is by arguments and values returned by the func- tions, and through external variables. The functions can occur in any order in the source file, and the source program can be split into multiple files, so long as no function is split.
The returh statement is the mechanism for returning a value from the called function to its caller. Any expressioncan followreturn:
return expression;
The expression will be converted to the return type of the function if necessary. Parentheses are often used around the expression, but they are optional.
The calling function is free to ignore the returned value. Furthermore, there need be no expression after return; in that case, no value is returned to the caller. Control also returns to the caller with no value when execution "falls off theend"ofthefunctionbyreachingtheclosingrightbrace. Itis.notillegal, but probably a sign of trouble, if a function returns a value from one place and no value from another. In any case, if a function fails to return a value, its "value" is certain to be garbage.
The pattern-searching program returns a status from main,the number of matches found. This value is available for use by the environment that called the program.
The mechanics of how to compile and load a C program that resides on mul- tiple source files vary from one system to the next. On the UNIX system, for example, the cc command mentioned in Chapter 1 does the job. Suppose that the three functions are stored in three files called main.c, qetline. c, and strindex. c. Then the command
cc main.c getline.c strindex.c
compilesthethreefiles,placingtheresultingobjectcodeinfilesmain.0, qetline.o, and strindex. 0, then loads them all into an executable file calleda.out. Ifthereisanerror,sayinmain.c,thatfilecanberecompiled by itself and the result loaded with the previous object files, with the command
cc main.c qetline.o strindex.o
declarations and statements
Thecccommandusesthe"•c"versus".0" namingconventiontodistinguish

 SECTION 4.2 FUNCTIONS RETURNING NON-INTEGERS 71
source files from object files.
Exercise 4-1. Write the function strrindex (s, t), which returns the position
of the rightmost occurrence of t in s, or - 1 if there is none. 0
4.2 Functions Returning Non-Integers
So far our examples of functions have returned either no value (void) or an into What if a function must return some other type? Many numerical func- tions like sqrt, sin, and cos return double; other specialized functions return other types. To illustrate how to deal with this, let us write and use the function atof (s), which converts the string s to its double-precision floating- point equivalent. atof is an extension of atoi, which we showed versions of in Chapters 2 and 3. It handles an optional sign and decimal point, and the pres-
ence or absence of either integer part or fractional part. Our version is not a high-quality input conversion routine; that would take more space than we care to use. The standard library includes an atof; the header <stdlib. h> declares it.
First, atof itself must declare the type of value it returns, since it is not into The type name precedes the function name:
#include <ctype.h>
1* atof: convertstringstodouble*1 double atof(char s[])
{
double val, power; int i, sign;
for(i=0;isspace(s[i]);i++) 1* skipwhitespace*1
sign =(s[i] == '-')? -1 : 1; if (s[i] == '+' I I sri] == '-')
i++;
for (val = 0.0; isdigit(s[i]); i++)
val =10.0 * val + (s[i] - '0'); if (s[i] == '.')
i++;
for (power =1.0; isdigit(s[i]); i++) {
val =10.0 * val + (s[i] - '0');
power *= 10.0;
}
return sign * val I power; }
Second, and just as important, the calling routine must know that atof returns a non-int value. One way to ensure this is to declare atof explicitly

 71 FUNCTIONS AND PROGRAM STRUCTURE CHAPTER 4
in the calling routine. The declaration is shown in this primitive calculator (barely adequate for check-book balancing), which reads one number per line, optionally preceded by a sign, and adds them up, printing the running sum after
each input:
#include <stdio.h> #define MAXLINE 100
1* rudimentary calculator *1 main( )
{
}
The declaration
double sum, atof(char []);
says that sumis a double variable, and that atof is a function that takes one char [ ] argument and returns a double.
The function atof must be declared and defined consistently. If atof itselfandthecalltoitinmainhaveinconsistenttypesinthesamesourcefile, the error will be detected by the compiler. But if (as is more likely) atof were compiled separately, the mismatch would not be detected, atof would return a double that main would treat as an int, and meaningless answers would result.
In the light of what we have said about how declarations must match defini- tions, this might seem surprising. The reason a mismatch can happen is that if there is no function prototype, a function is implicitly declared by its first appearance in an expression, such as
sum += atof(line)
Ifanamethat has.notbeenpreviouslydeclaredoccursinanexpressionandis followed by a left parenthesis, it is declared by context to be a function name, the function is assumed to return an int, and nothing is assumed about its arguments. Furthermore,ifafunctiondeclarationdoesnotincludearguments, as in
double atof();
that too is taken to mean that nothing is to be assumed about the arguments of atof; all parameter checking is turned off. This special meaning of the empty
double sum, atof(char []);
char line[MAXLINE];
int qetline(char liner], int max);
sum =0;
while (qetline(line, MAXLINE) > 0)
printf("\t"q\n", sum += atof(line»; return 0;

 SECTION 4.3 EXTERNAL VARIABLES 73
argument list is intended to permit older C programs to compile with new com- pilers. But it's a bad idea to use it with new programs. If the function takes arguments,declarethem;ifittakesnoarguments,usevoid.
Given atof, properly declared, we could write atoi (convert a string to int) intermsofit:
1*atoi:convertstringstointegerusingatof*1 int atoi(char s[])
{
double atof(char s[]); return (int) atof(s);
}
Notice the structure of the declarations and the return statement. The value of the expression in
return expression;
is converted to the type of the function before the return is taken. Therefore, the value of atof, a double, is converted automatically to int when it appears in this return, since the function atoi returns an into This opera- tion does potentially discard information, however, so some compilers warn of it. The cast states explicitly that the operation is intended, and suppresses any warning.
Exercise4-2. Extendatof tohandlescientificnotationoftheform
123.45e-6
where a floating-point number may be followed by e or E and an optionally signed exponent. 0
4.3 External Variables
A C program consists of a set of external objects, which are either variables or functions. The adjective "external" is used in contrast to "internal," which describes the arguments and variables defined inside functions. External vari- ables are defined outside of any function, and are thus potentially available to many functions. Functions themselves are always external, because C does not allow functions to be defined inside other functions. By default, external vari- ables and functions have the property that all references to them by the same name, even from functions compiled separately, are references to the same thing. (The standard calls this property external linkage.) In this sense, exter- nal variables are analogous to Fortran COMMON blocks or variables in the outermost block in Pascal. We will see later how to define external variables and functions that are visible only within a single source file.

 74 FUNCTIONS AND PROGRAM STRUCTURE CHAPTER 4
Because external variables are globally accessible, they provide an alternative to function arguments and return values for communicating data between func- tions. Any function may access an external variable by referring to it by name, if the name has been declared somehow.
If a large number of variables must be shared among functions, external variables are more convenient and efficient than long argument lists. As pointed out in Chapter 1, however, this reasoning should be applied with some caution, for it can have a bad effect on program structure, and lead to programs with too many data connections between functions.
External variables are also useful because of their greater scope and lifetime. Automatic variables are internal to a function; they come into existence when the function is entered, and disappear when it is left. External variables, on the other hand, are permanent, so they retain values from one function invocation to the next. Thus if two functions must share some data, yet neither calls the other, it is often most convenient if the shared data is kept in external variables rather than passed in and out via arguments.
Let us examine this issue further with a larger example. The problem is to write a calculator program that provides the operators +, -, *, and I. Because it is easier to implement, the calculator will use reverse Polish notation instead of infix. (Reverse Polish is used by some pocket calculators, and in languages like Forth and Postscript.)
In reverse Polish notation, each operator follows its operands; an infix expression like
(1 - 2) * (4 + 5) is entered as
12-45+ *
Parentheses are not needed; the notation is unambiguous as long as we know how many operands each operator expects.
The implementation is simple. Each operand is pushed onto a stack; when an operator arrives, the proper number of operands (two for binary operators) is popped, the operator is applied to them, and the result is pushed back onto the stack. In the example above, for instance, 1 and 2 are pushed, then replaced by theirdifference,-1. Next,4and5arepushedandthenreplacedbytheirsum, 9. The product of -1 and 9, which is -9, replaces them on the stack. The value on the top of the stack is popped and printed when the end of the input line is encountered.
The structure of the program is thus a loop that performs the proper opera- tion on each operator and operand as it appears:

 SECTION 4.3 EXTERNAL VARIABLES 75
while (nextoperatororoperandisnotend-of-file indicator) if (number)
push it
else if (operator)
pop operands do operation push result
else if (newline)
pop and print top of stack
else
error
The operations of pushing and popping a stack are trivial, but by the time error detection and recovery are added, they are long enough that it is better to put each in a separate function than to repeat the code throughout the whole program. And there should be a separate function for fetching the next input operator or operand.
The main design decision that has not yet been discussed is where the stack is, that is, which routines access it directly. One possibility is to keep it in main, and pass the stack and the current stack position to the routines that push and pop it. But main doesn't need to know about the variables that con- trol the stack; it only does push and pop operations. So we have decided to store the stack and its associated information in external variables accessible to the push and pop functions but not to main.
Translating this outline into code is easy enough. If for now we think of the program as existing in one source file, it will look like this:
'includes
.'defines
function declarations for main
main() { ... }
external variables for push and pop void push(double f) { ... }
double pop(void) { ... } int getop(char s[]) { ... }
routines called by getop
Later we will discuss how this might be split into two or more source files.
The function main is a loop containing a big switch on the type of opera- tor or operand; this is a more typical use of switch than the one shown in Sec-
tion 3.4.

 76 FUNCTIONS AND PROGRAM STRUCTURE CHAPTER 4
#include <stdio.h> #include <stdlib.h>
#define MAXOP 100 #define NUMBER '0'
int getop(char []); void push(double); double pop(void);
1* for atof() *1
1* max size of operand or operator *1
1* signal that a number was found *1
1* reverse Polish calculator *1 maine )
{
}
int type; double op2;' char s[MAXOP];
while «type = getop(s» 1= EOF) { switch (type) {
case NUMBER: push(atof(s»;
break; case '+' :
push(pop() + pope»~;
break; case '*':
push(pop() * pope»~;
break; case '-':
op2 =pop(); push(pop() - op2); break;
case 'I':
op2 = pop();
if (op2 1=0.0) push(pop() lop2);
else
printf(nerror: zero divisor\nn);
break; case '\n':
printf(n\t".8g\nn, pop());
break; default:
} }
return 0;
printf(nerror: unknown command "s\nn, s);
break;

 SECTION 4.3 EXTERNAL VARIABLES 77
Because + and * are commutative operators, the order in which the popped operands are combined is irrelevant, but for - and / the left and right operands must be distinguished. In
push(pop() - pOp(»;
the order in which the two calls of pop are evaluated is not defined. To guarantee the right order, it is necessary to pop the first value into a temporary variable as we did in main.
#defineMAXVAL 100 1*maximumdepthofvalstack*1 int sp = 0; 1* next free stack position *1
double val[MAXVAL]; 1* value stack *1
1* push: push f onto value stack*1 void push(double f)
{
}
1* pop: pop and return top value from stack*1 double pop(void)
{
if (sp > 0)
return val[--sp]; else {
printf("error: stack empty\n");
return 0.0;
}
A variable is external if it is defined outside of any function. Thus the stack and stack index that must be shared by push and pop are defined outside of these functions. But main itself does not refer to the stack or stack position- the representation can be hidden.
Let us now turn to the implementation of getop, the function that fetches the next operator or operand. The task is easy. Skip blanks and tabs. If the next character is not a digit or a decimal point, return it. Otherwise, collect a string of digits (which might include a decimal point), and return NUMBER, the signal that a number has been collected.
}
if (sp < MAXVAL) val[sp++] =f;
else
printf("error: stack full, can't push "9'\n",f);

 78 FUNCTIONS AND PROGRAM STRUCTURE #include <ctype.h>
int getch(void); void ungetch(int);
1* getop: get next operator or numeric operand *1 int getop(char s[])
{
int i, c; while«s[O]=c=getch(»--, , II II
8[1] ='\0';
if (Iisdigit(c) && c 1= '.')
CHAPTER 4
c =='\t')
if (isdigit(c» 1* collect integer part *1 while (isdigit(s[++i] =c =getch(»)
,
if (c == '.') 1* collect fraction part *1 while (isdigit(s[++i] =c =getch()})
,
s[i] ='\0'; if (c 1= EOF)
ungetch(c); return NUMBER;
}
return c; 1* not a number *1 i =0;
What are getch and ungetch? It is often the case that a program cannot determine that it has read enough input until it has read too much. One instance is collecting the characters that make up a number: until the first non- digit is seen, the number is not complete. But then the program has read one character too far, a character that it is not prepared for.
The problem would be solved if it were possible to "un-read" the unwanted character. Then, every time the program reads one character too many, it could push it back on the input, so the rest of the code could behave as if it had never been read. Fortunately, it's easy to simulate un-getting a character, by writing a pair of cooperating functions. getch delivers the next input character to be considered;ungetch remembersthecharactersputbackontheinput,sothat subsequentcallstogetch willreturnthembeforereadingnewinput.
How they work together is simple. unqe cch puts the pushed-back charac- ters into a shared buffer-a character array. getch reads from the buffer if there is anything there, and calls getc~ar if the buffer is empty. There must also be an index variable that records the Position of the current character in the buffer.
Since the buffer and the index are shared by getch and ungetch and must retain their values between calls, they must be external to both routines. Thus we can write getch, ungetch, and their shared variables as:

 SECTION 4.3 EXTERNAL VARIABLES 79
#define BUFSIZE 100
charbuf[BUFSIZE]; I. bufferforungetch.1
intbufp=0; I.nextfreepositioninbuf.1
intgetch(void)I. geta(possiblypushedback)character.1 {
return (bufp > 0) ? buf[--bufp] : getchar(); }
voidungetch(intc)I. pushcharacterbackoninput.1 {
if (bufp >= BUFSIZE)
printf("ungetch: too many characters\n");
else
buf[bufp++] =c;
}
The standard library includes a function ungetc that provides one character of pushback; we will discuss it in Chapter 7. We have used an array for the push- back, rather than a single character, to illustrate a more general approach.
Exercise 4-3. Given the basic framework, it's straightforward to extend the cal- culator. Add the modulus (%) operator and provisions for negative numbers. 0
Exercise 4-4. Add commands to print the top element of the stack without pop- ping, to duplicate it, and to swap the top two elements. Add a command to clear the stack. 0
Exercise 4-5. Add access to library functions like sin, exp, and pow. See <math •h> in Appendix B, Section 4. 0
Exercise 4-6. Add commands for handling variables. (It's easy to provide twenty-six variables with single-letter names.) Add a variable for the most recently printed value. 0
Exercise 4-7. Write a routine ungets (s) that will push back an entire string onto the input. Should ungets know about buf and bufp, or should it just use ungetch? 0
Exercise 4-8. Suppose that there will never be more than one character of pushback. Modify getch and ungetch accordingly. 0
Exercise 4-9. Our getch and ungetch do not handle a pushed-back EOF correctly. Decide what their properties ought to be if an EOFis pushed back, then implement your design. 0
Exercise 4-10. An alternate organization uses getline to read an entire input line; this makes getch and ungetch unnecessary. Revise the calculator to use this approach. 0

 80 FUNCTIONS AND PROGRAM STRUCTURE CHAPTER 4
4.4 Scope Rules
The functions and external variables that make up a C program need not all be compiled at the same time; the source text of the program may be kept in several files, and previously compiled routines may be loaded from libraries. Among the questions of interest are
• How are declarations written so that variables are properly declared during compilation?
• How are declarations arranged so;that all the pieces will be properly con- nected when the program is loaded?
• How are declarations organized so there is only one copy?
• How are external variables initialized?
Let us discuss these topics by reorganizing the calculator program into several files. As a practical matter, the calculator is too small to be worth splitting, but it is a fine illustration of the issues that arise in larger programs.
The scope of a name is the part of the program within which the name can be used. For an automatic variable declared at the beginning of a function, the scope is the function in which the name is declared. Local variables of the same name in different functions are unrelated. The same is true of the parameters of the function, which are in effect local variables.
The scope of an external variable or a function lasts from the point at which itisdeclaredtotheendofthefilebeingcompiled.Forexample,ifmain,sp, val, push, and pop are defined in one file, in the order shownabove,that is,
main() { ...}
int sp =0;
double val[MAXVAL];
void push(double f) { ... } double pop(void) { ...}
then the variables sp and val may be used in push and pop simply by nam- ing them; no further declarations are needed. But these names are not visible in main,norarepushandpopthemselves.
On the other hand, if an external variable is to be referred to before it is defined, or if it is defined in a different source file from the one where it is beingused,thenanexterndeclarationismandatory.
It is important to distinguish between the declaration of an external variable and its definition. A declaration announces the properties of a variable (pri- marilyitstype);adefinitionalsocausesstoragetobesetaside.Ifthelines
int sp;
double val[MAXVAL];
appear outside of any function, they define the external variables sp and val,

 SECTION 4.5 HEADER FILES 81
cause storage to be set aside, and also serve as the declaration for the rest of that source file. On the other hand, the lines
extern int sp; extern double vall];
declare for the rest of the source file that sp is an int and that val is a double array (whose size is determined elsewhere), but they do not create the variables or reserve storage for them.
There must be only one definition of an external variable among all the files that make up the source program; other files may contain extern declarations to access it. (There may also be extern declarations in the file containing the definition') Array sizes must be specified with the definition, but are optional with an extern declaration.
Initialization of an external variable goes only with the definition.
Although it is not a likely organization for this program, the functions push and pop could be defined in one file, and the variables val and sp defined and initialized in another. Then these definitions and declarations would be neces- sary to tie them together:
Infilel:
extern int sp; extern double vall];
void push(double f) { }
double pop(void) { ...}
Infile2:
int sp = 0;
double val[MAXVAL];
Because the extern declarations in file} lie ahead of and outside the function
definitions, they apply to all functions; one set of declarations suffices for all of file}. This same organization would also be needed if the definitions of sp and
val followed their use in one file.
4.5 Header Flies
Let us now consider dividing the calculator program into several source files, as it might be if each of the components were substantially bigger. The main function would go in one file, which we will call main.c;push,pop,and their variables go into a second file, stack. c; getop goes into a third, getop. c. Finally, getch and ungetch go into a fourth file, getch. c; we separate them from the others because they would come from a separately-compiled library in a realistic program.

 82 FUNCTIONS AND PROGRAM STRUCTURE CHAPTER 4
There is one more thing to worry about-the definitions and declarations shared among the files. As much as possible, we want to centralize this, so that there is only one copy to get right and keep right as the program evolves. Accordingly,wewillplacethiscommonmaterialinaheaderfile,calc.h, whichwillbeincludedasnecessary. (The#include lineisdescribedinSec-
tion 4.11.)
The resulting program then looks like this:
main.c:
#include <stdio.h> #include <stdlib.h> #include "calc.h" #define MAXOP 100 main() {
}
calc.h:
#define NUMBER '0' void push(double); double pop(void); int getop(char []); int getch(void); void ungetch(int);
getop.c:
#include <stdio.h> #include <ctype.h> 'include "calc.h" getop()
getch.c:
'include <stdio.h> #define BUFSIZE 100 char buf[BUFSIZE]; int bufp = 0;
int getchtvoid)
void ungetch(int)
stack.c:
'include <stdio.h> 'include "calc.h" #define MAXVAL 100 int sp = 0;
double val[MAXVAL]; void push(double) {
double pop(void)
There is a tradeoff between the desire that each file have access only to the information it needs for its job and the practical reality that it is harder to maintain more header files. Up to some moderate program size, it is probably best to have one header file that contains everything that is to be shared between any two parts of the program; that is the decision we made here. For a much larger program, more organization and more headers would be needed.

 SECTION 4.7 REGISTER VARIABLES 83 4.6 Static Variables
The variables sp and val in stack. c, and buf and bufp in getch. c, are for the private use of the functions in their respective source files, and are not meant to be accessed by anything else. The static declaration, applied to an external variable or function, limits the scope of that object to the rest of the source file being compiled. External static thus provides a way to hide names like buf and bufp in the getch-ungetch combination, which must be external so they can be shared, yet which should not be visible to users of getch and ungetch.
Static storage is specified by prefixing the normal declaration with the word static. If the two routines and the two variables are compiled in one file, as
in
then no other routine will be able to access buf and bufp, and those names will not conflict with the same names in other files of the same program. In the same way, the variables that push and pop use for stack manipulation can be hidden, by declaring sp and val to be static.
The external static declaration is most often used for variables, but it can be applied to functions as well. Normally, function names are global, visible to any part of the entire program. If a function is declared static, however, its name is invisible outside of the file in which it is declared.
The static declaration can also be applied to internal variables. Internal static variables are local to a particular function just as automatic variables are, but unlike automatics, they remain in existence rather than coming and
going each time the function is activated. This means that internal static variables provide private, permanent storage within a single function.
Exercise 4-11. Modify getop so that it doesn't need to use ungetch. Hint: use an internal static variable. 0
4.7 RegisterVariables
A register declaration advises the compiler that the variable in question will be heavily used. The idea is that register variables are to be placed in machine registers, which may result in smaller and faster programs. But com- pilers are free to ignore the advice.
staticcharbuf[BUFSIZE]; 1*bufferforungetch*1 staticintbufp=0; 1*nextfreepositioninbuf*1
int getch(void) { ...} void ungetch (int c) { ...}
The register declaration looks like

 84 FUNCTIONS AND PROGRAM STRUCTURE CHAPTER 4 register int X;
register char c;
andsoon.Theregisterdeclarationcanonlybeappliedtoautomaticvari- ables and to the formal parameters of a function. In this latter case, it looks like
f{register unsigned m, register long n)
{
}
In practice, there are restrictions on register variables, reflecting the realities of underlying hardware. Only a few variables in each function may be kept in registers, and only certain types are allowed. Excess register declarations are harmless,however,sincethewordregisterisignoredforexcessordisallowed declarations. And it is not possible to take the address of a register variable (a topic to be covered in Chapter 5), regardless of whether the variable is actually placed in a register. The specific restrictions on number and types of register variables vary from machine to machine.
4.8 Block Structure
C is not a block-structured language in the sense of Pascal or similar languages, because functions may not be defined within other functions. On the other hand, variables can be defined in a block-structured fashion within a func- tion. Declarations of variables (including initializations) may follow the left brace that introduces any compound statement, not just the one that begins a function. Variables declared in this way hide any identically named variables in outer blocks, and remain in existence until the matching right brace. For exam- ple, in
if (n > 0) {
int i; 1* declare a new i *1
for (i = 0; i < n; i++) }
thescopeofthevariableiisthe"true"branchoftheif;thisiisunrelatedto any i outside the block. An automatic variable declared and initialized in a blockisinitializedeachtimetheblockisentered. Astatic variableisinitial- ized only the first time the block is entered.
Automatic variables, including formal parameters, also hide external vari- ables and functions of the same name. Given the declarations
register int i;

 SECTION 4.9
INITIALIZATION 85
int X; int y;
f(double x)
{
}
then within the function f, occurrences of x refer to' the parameter, which is a double; outside of f, they refer to the external into The same is true of the variable y.
As a matter of style, it's best to avoid variable names that conceal names in an outer scope; the potential for confusion and error is too great.
4.9 Initialization
Initialization has been mentioned in passing many times so far, but always peripherally to some other topic. This section summarizes some of the rules, now that we have discussed the various storage classes.
In the absence of explicit initialization, external and static variables are guaranteed to be initialized to zero; automatic and register variables have unde- fined (i.e., garbage) initial values.
Scalar variables may be initialized when they are defined, by following the name with an equals sign and an expression:
int x=1;
char squote = '\"; longday=1000L*60L*60L*24L;/*milliseconds/day*/
For external and static variables, the initializer must be a constant expression; the initialization is done once, conceptually before the program begins execution. For automatic and register variables, it is done each time the function or block is entered.
For automatic and register variables, the initializer is not restricted to being a constant: it may be any expression involving previously defined values, even function calls. For example, the initializations of the binary search program in Section 3.3 could be written as
int binsearch(int x, int v[], int n)
{
} instead of
double y;
int low =0;
int high =n - 1; int mid;

 86 FUNCTIONS AND PROGRAM STRUCTURE CHAPTER 4
int low, high, mid;
low = 0;
high = n - 1;
In effect, initializations of automatic variables are just shorthand for assignment statements. Which form to prefer is largely a matter of taste. We have gen- erally used explicit assignments, because initializers in declarations are harder to see and further away from the point of use.
An array may be initialized by following its declaration with a list of initial- izers enclosed in braces and separated by commas. For example, to initialize an array days with the number of days in each month:
int days[] ={ 31,28,31,30,31,30,31,31,30,31,30,31};
When the size of the array is omitted, the compiler will compute the length by counting the initializers, of which there are 12 in this case.
If there are fewer initializers for an array than the number specified, the missing elements will be zero for external, static, and automatic variables. It is an error to have too many initializers. There is no way to specify repetition of an initializer,' nor to initialize an element in the middle of an array without sup- plying all the preceding values as well. '
Character arrays are a special case of initialization; a string may be used instead of the braces and commas notation:
char pattern [] = "ould";
is a shorthand for the longer but equivalent
char pattern[] = { '0', 'u', '1', 'd', '\0' };
In this case, the array size is five (four characters plus the terminating , \ 0' ).
4.10 Recursion
C functions may be used recursively; that is, a function may call itself either directly or indirectly. Consider printing a number as a character string. As we mentioned before, the digits are generated in the wrong order: low-order digits are available before high-order digits, but they have to be printed the other way around.
There are two solutions to this problem. One is to store the digits in an array as they are generated, then print them in the reverse order, as we did with i toa in Section 3.6. The alternative is a recursive solution, in which printd first calls itself to cope with any leading digits, then prints the trailing digit. Again, this version can fail on the largest negative number.

 SECTION 4.10
RECURSION 87
linclude <stdio.h>
/* printd: print n in decimal*/ void printd(int n)
{
if(n<0) (
putchar('-'); n = -n;
if (n / 10) printd(n / 10);
putchar(n % 10 + '0');
When a function calls itself recursively, each invocation gets a fresh set of all the automatic variables, independent of the previous set. Thus in printd (123) thefirstprintd receivestheargumentn =123. Itpasses12 to a secondprintd, which in tum passes 1 to a third. The third-levelprintd prints 1, then returns to the second level. That printd prints 2, then returns to the first level. That one prints 3 and terminates.
Another good example of recursion is quicksort, a sorting algorithm developed by C. A. R. Hoare in 1962. Given an array, one element is chosen and the others are partitioned into two subsets-those less than the partition ele- ment and those greater than or equal to it. The same process is then applied recursively to the two subsets. When a subset has fewer than two elements, it doesn't need any sorting; this stops the recursion.
Our version of quicksort is not the fastest possible, but it's one of the sim- plest. We use the middle element of each subarray for partitioning.
/* qsort: sort v[left]...v[right] into increasing order*/ void qsort(int v[], int left, int right)
(
int i, last;
void swap(int v[], int i, int j);
if(left>=right) /*donothingifarraycontains*/ return; /* fewer than two elements */
swap(v, left, (left + right)/2); /* move partition elem */ last = left; /* to v[O] */
for (i = left+1; i <= right; i++) /* partition */
if (v[i] < v[left]) swap(v, ++last, i);
swap(v, left, last); /* restore partition elem */ qsort(v, left, last-1);
qsort(v, last+1, right);
We moved the swapping operation into a separate function swapbecause it occurs three times in qsort.

 88 FUNCTIONS AND PROGRAM STRUCTURE
CHAPTER 4
1*swap:interchangev[i]andv[j]*1 void swap(int v[], int i, int j)
{
}
int temp;
temp =v[i]; v[i] = v[j]; v[j] =temp;
The standard library includes a version of qsort type.
that can sort objects of any
Recursion may provide no saving in storage, since somewhere a stack of the values being processed must be maintained. Nor will it be faster. But recursive code is more compact, and often much easier to write and understand than the non-recursive equivalent. Recursion is especially convenient for recursively defined data structures like trees; we will see a nice example in Section 6.5.
Exercise 4-12. Adapt the ideas of printd to write a recursive version of i toa; that is, convert an integer into a string by calling a recursive routine. 0
Exercise 4-13. Write a recursive version of the function reverse (s), which reverses the string s in place. 0
4. 11 The C Preprocessor
C provides certain language facilities by means of a preprocessor, which is conceptually a separate first step in compilation. The two most frequently used features are #include, to include the contents of a file during compilation, and #define, to replace a token by an arbitrary sequence of characters. Other features described in this section include conditional compilation and macros with arguments.
4~11.1 File Inclusion
File inclusion makes it easy to handle collections of #def ines and declara- tions (among other things). Any source line of the form
#include "filename" or
#include «filename»
is replaced by the contents of the file filename. If the filename is quoted, searching for the file typically begins where the source program was found; if it is not found there, or if the name is enclosed in < and >, searching follows an implementation-defined rule to find the file. An included file may itself contain

 SECTION 4.11 THE C PREPROCESSOR 89
#include lines.
There are often several #include lines at the beginning of a source file, to
include common #define statements and extern declarations, or to access the function prototype declarations for library functions from headers like <stdio. h>. (Strictly speaking, these need not be files; the details of how
headers are accessed are implementation-dependent.)
#include is the preferred way to tie the declarations together for a large
program.Itguaranteesthatallthesourcefileswillbesuppliedwiththesame definitions and variable declarations, and thus eliminates a particularly nasty kind of bug. Naturally, when an included file is changed, all files that depend on it must be recompiled.
4.11.2 Macro Substitution
A definition has the form
#define name replacement text
It calls for a macro substitution of the simplest kind-subsequent occurrences of the token name will be replaced by the replacement text. The name in a #define has the same form as a variable name; the replacement text is arbi- trary. Normally the replacement text is the rest of the line, but a long defini- tion may be continued onto several lines by placing a \ at the end of each line to be continued. The scope of a name defined with #define is from its point of definition to the end of the source file being compiled. A definition may use previous definitions. Substitutions are made only for tokens, and do not take placewithinquotedstrings. Forexample,ifYESisadefinedname,therewould be no substitution in printf ("YES") or in YESMAN.
Any name may be defined with any replacement text. For example, #define forever for (;;) 1* infinite loop *1
defines a new word, forever, for an infinite loop. Itisalsopossibletodefinemacroswitharguments,sothereplacementtext
can be different for different calls of the macro. As an example, define a macro called max:
#define max(A, B) «A) > (B) ? (A) : (B»
Although it looks like a function call, a use of max expands into in-line code. Each occurrence of a formal parameter (here A or B) will be replaced by the corresponding actual argument. Thus the line
x =max(p+q, r+s); will be replaced by the line
x = «p+q) > (r+s) ? (p+q) : (r+s»;
So long as the arguments are treated consistently, this macro will serve for any

 90 FUNCTIONS AND PROGRAM STRUCTURE CHAPTER 4
data type; there is'no need for different kinds of max for different data types, as there would be with functions.
If you examine the expansion of max, you will notice some pitfalls. The expressions are evaluated twice; this is bad if they involve side effects like incre- ment operators or input and output. For instance,
max(i++,j++) /*WRONG*/
will increment the larger value twice. Some care also has to be taken with parentheses to make sure the order of evaluation is preserved; consider what happens when the macro
#definesquare(x)x*x /*WRONG*/
isinvoked as square (z+1).
Nonetheless, macros are valuable. One practical example comes from
<stdio. h>, in which getchar and putchar are often defined as macros to avoid the run-time overhead of a function call per character processed. The functions in <ctype. h> are also usually implemented as macros.
Names may be undefined with #unde£, usually to ensure that a routine is really a function, not a macro:
#undef getchar
int getchar (void) { ...}
Formal parameters are not replaced within quoted strings. If, however, a parameter name is preceded by a # in the replacement text, the combination will be expanded into a quoted string with the parameter replaced by the actual argument. This can be combined with string concatenation to make, for exam- ple, a debugging print macro:
#define dprint(expr) printf(#expr" =~\n", expr)
When this is invoked, as in
dprint (x/y);
the macro is expanded into
printf("x/y" " = "g\n", x/y);
and the strings are concatenated, so the effect is J?rintf("x/y ="g\n", x/y);
Within the actual argument, each " is replaced by v" and each \ by \ \, so the result is a legal string constant.
The preprocessor operator ## provides a way to concatenate actual argu- ments during macro expansion. If a parameter in the replacement text is adja- cent to a ##, the parameter is replaced by the actual argument, the ## and sur- rounding white space are removed, and the result is re-scanned. For example, the macro paste concatenates its two arguments:

 SECTION 4.11 THE C PREPROCESSOR 91
#define paste(front, back) front ## back
sopaste(name,1)createsthetokenname1. Therulesfornestedusesof##arearcane;furtherdetailsmaybefoundin
Appendix A.
Exercise4-14.Defineamacroswap(t,x,y) thatinterchangestwoarguments
oftypet.(Blockstructurewillhelp.)0 4.11.3 Conditional Inclusion
Itispossibletocontrolpreprocessingitselfwithconditionalstatementsthat are evaluated during preprocessing. This provides a way to include code selec- tively, depending on the value of conditions evaluated during compilation.
The#if lineevaluatesaconstantintegerexpression(whichmaynotinclude sizeof, casts, or enum constants). If the expression is non-zero, subsequent lines until an #endif or #elif or #else are included. (The preprocessor
statement #elif is like else if.) The expressiondefined(name) in a #if is 1 if the name has been defined, and 0 otherwise.
For example, to make sure that the contents of a file hdr. h are included only once, the contents of the file are surrounded with a conditional like this:
#if Idefined(HDR) #define HDR
1* contents of hdr.h go here *1 #endif
Thefirstinclusionofhdr.hdefinesthenameHDR;subsequentinclusionswill find the name defined and skip down to the #e~dif. A similar style can be used to avoid including files multiple times. If this style is used consistently, then each header can itself include any other headers on which it depends, without the user of the header having to deal with the interdependence.
This sequence tests the name SYSTEM to decide which version of a header to include:
#if SYSTEM == SYSV #define HDR "sysv.h"
#elif SYSTEM == BSD #define HDR "bsd.h"
#elif SYSTEM == MSDOS #define HDR "msdos.h"
#else
#define HDR "default.h"
#endif #include HDR
The #ifdef and #ifndef lines are specialized forms that test whether a

 92 FUNCTIONS AND PROGRAM STRUCTURE CHAPTER 4 nameisdefined. Thefirstexampleof#if abovecouldhavebeenwritten
#ifndef HDR #define HDR
1* contents of hdr.h go here .1 #endif

 CHAPTER 5: Pointers and Arrays
A pointer is a variable that contains the address of a variable. Pointers are much used in C, partly ,because they are sometimes the only way to express a computation, and partly because they usually lead to more compact and effi- cient code than can be obtained in other ways. Pointers and arrays are closely related; this chapter also explores this relationship and shows how to exploit it.
Pointershavebeenlumpedwiththegotostatementasamarvelouswayto create impossible-to-understand programs. This is certainly true when they are used carelessly, and it is easy to create pointers that point somewhere unex- pected. With discipline, however, pointers can also be used to achieve clarity and simplicity. This is the aspect that we will try to illustrate.
The main change in ANSI C is to make explicit the rules about how pointers can be manipulated, in effect mandating what good programmers already prac- ticeandgoodcompilersalreadyenforce.Inaddition,thetypevoid*(pointer to void) replaces char * as the proper type for a generic pointer.
5. 1 Pointers and Addresses
Let us begin with a simplified picture of how memory is organized. A typi- cal machine has an array of consecutively numbered or addressed memory cells that may bemanipulated individually or in contiguous groups. One common situationisthatanybytecanbeachar,apairofone-bytecellscanbetreated as a short integer, and four adjacent bytes form a long. A pointer is a group of cells (often two or four) that can hold an address. So if c is a char and p is a pointer that points to it, we could represent the situation this way:
The unary operator &. gives the address of an object, so the statement 93

 94 POINTERS AND ARRAYS CHAPTER 5 p =&.c;
assignstheaddressofctothevariablep,andpissaidto"pointto"c.The& operator only applies to objects in memory: variables and array elements. It cannotbeappliedtoexpressions,constants,orregister variables.
The unary operator * is the indirection or dereferencing operator; when applied to a pointer, it accesses the object the pointer points to. Suppose that x and yare integers and ip is a pointer to into This artificial sequence shows how to declare a pointer and how to use & and *:
int x =1, y =2, z[10];
int *ip;
ip =&.x;
y =*ip; *ip =0; ip = &.z[O];
1* ip is a pointer to int *1
1* ip now points to x *1 1* y is now 1 *1
1* x is now 0 *1
1* ip now points to z[O] *1
The declarations of x, y, and z are what we've seen all along. The declaration ofthe pointer ip,
int dp;
isintendedasamnemonic;itsaysthattheexpression*ipisanintoThesyn- tax of the declaration for a variable mimics the syntax of expressions in which the variable might appear. This reasoning applies to function declarations as well. For example,
double *dp, atof(char *);
says that in an expression *dp and atof (s) have values of type double, and that the argument of atof is a pointer to char.
You should also note the implication that a pointer is constrained to point to a particular kind of object: every pointer points to a specific data type. (There isoneexception:a"pointertovoid"isusedtoholdanytypeofpointerbut cannot be dereferenced itself. We'll come back to it in Section 5.11.)
If ip points to the integer x, then *ip can occur in any context where x could, so
increments *ip by 10.
The unary operators * and & bind more tightly than arithmetic operators, so
the assignment
y =*ip + 1
takes whatever ip points at, adds 1, and assigns the result to y, while increments what ip points to, as do

 SECTION 5.2 POINTERS AND FUNCTION ARGUMENTS 95
and
The parentheses are necessary in this last example; without them, the expression wouldincrementipinsteadofwhatitpointsto,becauseunaryoperatorslike* and ++ associate right to left.
Finally, since pointers are variables, they can be used without dereferencing. Forexample,ifiqisanotherpointertoint,
iq =ip
copiesthecontentsofipintoiq,thusmakingiqpointtowhateverippointed to.
5.2 Pointers and Function Arguments
Since C passes arguments to functions by value, there is no direct way for the called function to alter a variable in the calling function. For instance, a sorting routine might exchange two out-of-order elements with a function called
swap. Itisnotenoughtowrite swap(a, b);
where the swap function is defined as
voidswap(intx,inty) 1*WRONG*1 {
int temp;
temp =x;
x =y;
y =temp;
Because of call by value, swap can't affect the arguments a and b in the rou- tinethatcalledit.Thefunctionaboveonlyswapscopiesofaandb.
The way to obtain the desired effect is for the calling program to pass pointers to the values to be changed:
swap(&'a,&'b);
Since the operator &produces the address of a variable, &a is a pointer to a. In swap itself, the parameters are declared to be pointers, and the operands are
accessed indirectly through them.
(dp)++

 96 POINTERS AND ARRAYS CHAPTER 5
} Pictorially:
voidswap(int*px,int*py)1*interchange*pxand*py*1 {
int temp;
temp =*px; *px =*py; *py =temp;
in caller:
in swap:
Pointer arguments enable a function to access and change objects in the functionthatcalledit.Asanexample,considerafunctiongetintthatper- forms free-format input conversion by breaking a stream of characters into integer values, one integer per call. getint has to return the value it found and also signal end of file when there is no more input. These values have to be passed back by separate paths, for no matter what value is used for EOF, that could also be the value of an input integer.
Onesolutionistohavegetint returntheendoffilestatusasitsfunction value, while using a pointer argument to store the converted integer back in the callingfunction.Thisistheschemeusedbyscanfaswell;seeSection7.4.
Thefollowingloopfillsanarraywithintegersbycallstogetint:
int n, array[SIZE], getint(int *);
for (n = 0; n < SIZE && getint(&array[n]) 1= EOF; n++)
Eachcallsetsarray[n] tothenextintegerfoundintheinputandincrements n. Notice that it is essential to pass the address of array[n] to getint. Otherwisethereisnowayforgetint tocommunicatetheconvertedinteger back to the caller.
Ourversionofgetint returnsEOFforendoffile,zeroifthenextinputis not a number, and a positive value if the input contains a valid number.

 SECTION 5.3 POINTERS AND ARRAYS 97
#include <ctype.h>
int getch(void); void ungetch(int);
1* getint: get next integer from input into *pn*1 int getint(int *pn)
{
int c, sign;
while (isspace(c = getch(») 1* skip white space *1
if (Iisdigit(c)&&c 1=EOF&&c 1='+'&&c 1='-'){ ungetch(c); 1* it's not a number *1
return 0;
}
sign=(c=='-')? -1 : 1; if(c == +'' II c == '-')
c = getch(); for(*pn=0;isdigit(c);c=getch(»
*pn=10**pn+ (c - '0'); *pn *= sign;
if (c 1= EOF) ungetch (c) ;
return c;
}
Throughout getint, *pn is used as an ordinary int variable. We have also usedgetchandungetch(describedinSection4.3)sotheoneextracharacter that must be read can be pushed back onto the input.
Exercise 5-1. As written, getint treats a + or - not followedby a digit as a valid representation of zero. Fix it to push such a character back on the input. o
Exercise 5-2. Write getfloat, the floating-point analog of getint. What type does getfloat return as its function value? 0
5.3 Pointers and Arrays
In C, there is a strong relationship between pointers and arrays, strong enough that pointers and arrays should be discussed simultaneously. Anyopera- tion that can be achieved by array subscripting can also be done with pointers. The pointer version will in general be faster but, at least to the uninitiated, somewhat harder to understand.
The declaration

 98 POINTERS AND ARRAYS CHAPTER S int a[ 10];
defines an array a of size 10, that is, a block of 10 consecutive objects named a[O], a[ 1], ... , a[9].
a:
a[0]a[1] a[9]
The notation a [i] refers to the i-th element of the array. If pa is a pointer to an integer, declared as
int *pa; then the assignment
pa =&'a[O];
sets pa to point to element zero of a; that is, pa contains the address of a [ 0 ].
pa:
~~~~----r------"'1
a: ~I_ ~~
a[O]
Now the assignment
~ __ ~ ~
willcopythecontentsofa[0] intox.
If pa points to a particular element of an array, then by definition pa+ 1
points to the next element, pa+i points i elements after pa, and pa-i points i elements before. Thus, if pa points to a [ 0 ], -
*(pa+1 )
refers to the contents of a[1], pa+i is the address of a[i ], and *(pa+i) is the contents of a [i ].
pa~1:\ pa7 a: I I I I
a[O]
These remarks are true regardless of the type or size of the variables in the array a. The meaning of "adding 1 to a pointer," and by extension, all pointer arithmetic, is that pa+ 1 points to the next object, and pa+i points to the i-th

 SECTION 5.3 POINTERS AND ARRAYS 99
objectbeyondpa.
The correspondence between indexing and pointer arithmetic is very close.
By definition, the value of a variable or expression of type array is the address of element zero of the array. Thus after the assignment
pa =&a[O];
paandahaveidenticalvalues.Sincethenameofanarrayisasynonymfor thelocationoftheinitialelement,theassignmentpa=&a[0] canalsobewrit- ten as
pa =a;
Rather more surprising, at least at first sight, is the fact that a reference to a[i] can also be written as *(a+i). In evaluating a[i], C converts it to *(a+i) immediately;thetwoformsareequivalent. Applyingtheoperator&to bothpartsofthisequivalence,itfollowsthat&a[i] arida+i arealsoidentical: a+i istheaddressofthed-thelementbeyonda. Astheothersideofthiscoin, ifpaisapointer,expressionsmayuseitwithasubscript;pa[i] isidenticalto *(pa+i). Inshort,anarray-and-indexexpressionisequivalenttoonewritten
as a pointer and offset.
There is one difference between an array name and a pointer that must be
kept in mind. A pointer is a variable, so pa=a and pa++ are legal. But an arraynameisnotavariable;constructionslikea=paanda++areillegal.
When an array name is passed to a function, what is passed is the location of the initial element. Within the called function, this argument is a local vari- able, and so an array name parameter is a pointer, that is, a variable containing anaddress.Wecanusethisfacttowriteanotherversionofstrlen,which computes the length of a string.
1* strlen: return length of string s*1 int strlen(char *s)
{
int n;
for (n = 0; *s 1= '\0'; s++) n++;
return n;
}
Since s is a pointer, incrementing it is perfectly legal; s + -+ has no effect on the character string in the function that called strlen, but merely increments
strlen's privatecopyofthepointer. That meansthat callslike
strlen("hello, world"); 1* string constant *1 strlen(array); 1* char array[100]; *1 strlen(ptr); 1* char *ptr; *1
all work.
As formal parameters in a function definition,

 100 POINTERS AND ARRAYS CHAPTER 5 char s[];
and
char *s;
are equivalent; we prefer the latter because it says more explicitly that the parameter is a pointer. When an array name is passed to a function, the func- tion can at its convenience believe that it has been handed either an array or a pointer, and manipulate it accordingly. It can even use both notations if it seems appropriate and clear.
It is possible to pass part of an array to a function, by passing a pointer to the beginning of the subarray. For example, if a is an array,
£(&a[2])
and
both pass to the function f the address of the subarray that starts at a [ 2 ]. Within f, the parameter declaration can read
£(int arr[]) { ... }
or
£(int *arr) { ... }
So as far as f is concerned, the fact that the parameter refers to part of a larger array is of no consequence.
If one is sure that the elements exist, it is also possible to index backwards in anarray;p[-1I,p[-2],andsoonaresyntacticallylegal,andrefertotheele- ments that immediately precede p [ 0 ]. Of course, it is illegal to refer to objects that are not within the array bounds. .
5.4 Address Arithmetic
If p is a pointer to some element of an array, then p++ increments p to point to the next element, and p+=i increments it to point i elements beyond where it currently does. These and similar constructions are the simplest forms of pointer or address arithmetic.
C is consistent and regular in its approach to address arithmetic; its integra- tion of pointers, arrays, and address arithmetic is one of the strengths of the language. Let us illustrate by writing a rudimentary storage allocator. There are two routines. The first, a 110c (n ), returns a pointer p to n .consecutive character positions,which can be used by the caller of a110c for storing char- acters. The second, afree (p ), releases the storage thus acquired so it can be re-used later. The routines are "rudimentary" because the calls to afree must bemadeintheoppositeordertothecallsmadeona110c. Thatis,thestorage
£(a+2)

 SECTION 5.4 ADDRESS ARITHMETIC 101
managed by alloc and afree is a stack, or last-in, first-out list. The stand- ardlibraryprovidesanalogousfunctionscalledmallocandfreethathaveno such restrictions; in Section 8.7 we will show how they can be implemented.
.The easiest implementation is to have alloc hand out pieces of a large character array that we will call allocbuf. This array is private to alloe and afree. Since they deal in pointers, not array indices, no other routine need know the name of the array, which can be declared static in the source filecontainingallocandafree,andthusbeinvisibleoutsideit.Inpractical implementations, the array may well not even have a name; it might instead be obtainedbycallingmallocorbyaskingtheoperatingsystemforapointerto some unnamed block of storage.
The other information needed is how much of allocbuf has been used. We use a pointer, called allocp, that points to the next free element. When alloc isaskedforncharacters,itcheckstoseeifthereisenoughroomleftin allocbuf. If so, alloc returns the current value of allocp (i.e., the begin- ning of the free block), then increments it by n to point to the next free area. If there is no room, alloc returns zero. afree (p) merely sets allocp to p if p is inside allocbuf.
before call to alloc: allocbuf:
4--- inuse--.4--- free after call to alloc:
allocbuf:
allocp:"
III I
in use free
allocp:"
III
#define ALLOCSIZE 10000 1* size of available space *1 staticcharallocbuf[ALLOCSIZE]; 1*storageforalloc*1
static char ~allocp = allocbuf; 1* next free position *1
char *alloc(int n) 1* return pointer to n characters *1 {
if (allocbuf + ALLOCSIZE - allocp >= n) { 1* it fits *1 allocp += n;
return allocp - n; 1* old p *1 } else 1* not enough room *1
return 0;
}

 102
POINTERS AND ARRAYS CHAPTER 5
void afree(char *p) 1* free storage pointed to by p *1 {
if (p >= allocbuf && p < allocbuf + ALLOCSIZE) allocp =p;
}
In general a pointer can be initialized just as any other variable can, though normally the only meaningful values are zero or an expression involving the addresses of previously defined data of appropriate type. The declaration
static char *allocp =allocbuf;
definesallocp tobeacharacterpointerandinitializesittopointtothebegin- ningofallocbuf, whichisthenextfreepositionwhentheprogramstarts. This could have also been written
static char *allocp = &allocbuf[O];
since the array name is the address of the zeroth element.
The test
checks if there's enough room to satisfy a request for n characters. If there is, the new value of al10cp would be at most one beyond the end of al1ocbuf. Iftherequestcanbesatisfied,al10creturnsapointertothebeginningofa blockofcharacters(noticethedeclarationofthefunctionitself).Ifnot,alloc must return some signal that no space is left. C guarantees that zero is n~ver a valid address for data, so a return value of zero can be used to signal an abnor- mal event, in this case, no space.
Pointers and integers are not interchangeable. Zero is the sole exception: the constant zero may be assigned to a pointer, and a pointer may be compared with the constant zero. The symbolic constant NULL is often used in place of zero, as a mnemonic to indicate more clearly that this is a special value for a pointer. NULL isdefinedin <stdio.h>. WewilluseNULL henceforth.
Tests like
and
if (allocbuf + ALLOCSIZE - allocp >= n) { 1* it fits *1
if (p >= allocbuf && p < allocbuf + ALLOCSIZE)
if (allocbuf + ALLOCSIZE - allocp >= n) { 1* it fits *1
show several important facets of pointer arithmetic. First, pointers may be com- pared under certain circumstances. If p and q point to members of the same array, then relations like ==, 1=, <, >=, etc., work properly. For example,
p<q
is true if p points to an earlier member of the array than q does. Any pointer can be meaningfully compared for equality or inequality with zero. But the behavior is undefined for arithmetic or comparisons with pointers that do not

 SECTION 5.4 ADDRESS ARITHMETIC 103
point to members of the same array. (There is one exception: the address of the first element past the end of an array can be used in pointer arithmetic')
Second, we have already observed that a pointer and an integer may be added or subtracted. The construction
p+n
means the address of the n-th object beyond the one p currently points to. This is true regardless of the kind of object p points to; n is scaled according to the size of the objects p points to, which is determined by the declaration of p. If an int is four bytes, for example, the int will be scaled by four.
Pointer subtraction is also valid: if p and q point to elements of the same array, and p<q, then q-p+ 1 is the number of elements from p to q inclusive. This fact can be used to write yet another version of strlen:
1*strlen:returnlengthofstrings*1 int strlen(char *s)
{
char *p =s;
while (*p 1= '\0') p++;
return p - s;
}
In its declaration, p is initialized to s, that is, to point to the first character of the string. In the while loop, each character in turn is examined until the , '0' at the end is seen. Because p points to characters, p++ advances p to the next character each time, and p- s gives the number of characters advanced over, that is, the string length. (The number of characters in the string could be too large to store in an into The header <stddef. h> defines a type ptrdiff _t that is large enough to hold the signed difference of two pointer values. If we were being very cautious, however, we would use size_ t for the return type of strlen, to match the standard library version. size_tis the
unsigned integer type returned by the sizeof operator.)
Pointer arithmetic is consistent: if we had been dealing with floats, which
occupy more storage than chars, and if p were a pointer to f loa t, p+ + would advance to the next float. Thus we could write another version of alloc that maintains floats instead of chars, merely by changing char to float throughout alloc and afree. All the pointer manipulations automatically take into account the size of the object pointed to.
The valid pointer operations are assignment of pointers of the same type, adding or subtracting a pointer and an integer, subtracting or comparing two pointers to members of the same array, and assigning or comparing to zero. All otherpointerarithmeticisillegal.Itisnotlegaltoaddtwopointers,ortomul- tiply or divide or shift or mask them, or to add float or double to them, or even, except for void *, to assign a pointer of one type to a pointer of another type without a cast.

 104 POINTERS AND ARRAYS CHAPTER 5
5.5 Character Pointers and Functions
A string constant, written as "I am a string"
is an array of characters. In the internal representation, the array is terminated withthenullcharacter'\0'sothatprogramscanfindtheend.Thelengthin storage is thus one more than the number of characters between the double quotes.
Perhaps the most common occurrence of string constants is as arguments to functions, as in
printf( "hello, world\n");
When a character string like this appears in a program, access to it is through a character pointer; printf receives a pointer to the beginning of the character array. That is, a string constant is accessed by a pointer to its first element.
String constants need not be function arguments. If pmessaqe is declared as
char *pmessage;
then the statement
pmessage = "now is the time";
assigns to pmessaqe a pointer to the character array. This is not a string copy; only pointers are involved. C does not provide any operators for process- ing an entire string of characters as a unit.
There is an important difference between these definitions: charamessage[]="nowisthetime"; 1*anarray*1
char *pmessage ="now is the time"; 1* a pointer *1
amessaqe is an array, just big enough to hold the sequence of characters and ,\0'thatinitializesit.Individualcharacterswithinthearraymaybechanged but amessaqe will always refer to the same storage. On the other hand, pmessaqe is a pointer, initialized to point to a string constant; the pointer may subsequently be modified to point elsewhere, but the result is undefined if you
try to modify the string contents.
pmessage:G~--.nIowisthetime\OI amessage: Inow is the time\O I
We will illustrate more aspects of pointers and arrays by studying versions of two useful functions adapted from the standard library. The first function is strcpy (s,t), whichcopiesthestringt tothestrings. Itwouldbenicejust to say s=t but this copies the pointer, not the characters. To copy the

 SECTION 5.5 CHARACTER POINTERS AND FUNCTIONS lOS characters, we need a loop. The array version is first:
1* strcpy: copy t to s; array subscript version*1 void strcpy(char *s, char *t)
{
}
For contrast, here is a version of strcpy with pointers:
/* strcpy: copy t to s; pointer version 1 *1 void strcpy(char *s, char *t)
{
}
}
int i;
i =0;
while({s[i] =t[i])1='\0')
i++;
while «*s = *t) 1= '\0') { s++;
t++;
Because arguments are passed by value, strcpy
t in any way it pleases. Here they are conveniently initialized pointers, which are marched along the arrays a character at a time, until the ' \0' that ter- minates t has been copied to s.
In practice, strcpy would not be written as we showed it above. Experi- enced C programmers would prefer
1*strcpy: copyttoS;pointerversion2*1 void strcpy(char *s, char *t)
{
whi1e«*s++ =*t++) 1= '0\') }
This moves the increment of sand t into the test part of the loop. The value of *t++ is the character that t pointed to before t was incremented; the postfix ++ doesn't change t until after this character has been fetched. In the same way, the character is stored into the old s position before s is incremented.
This character is also the value that is compared against ' \0' to control the loop. The net effect is that characters are copied from t to s, up to and includ- ing the terminating' \0'.
As the final abbreviation, observe that a comparison against ' \0' is redun- dant, since the question is merely whether the expression is zero. So the func- tion would likely be written as
can use the parameters sand

 106 POINTERS AND ARRAYS
CHAPTER 5
1* strcpy: copy t to s; pointer version 3*1 void strcpy(char *s, char *t)
{
}
Although this may seem cryptic at first sight, the notational convenienceis con- siderable, and the idiom should be mastered, because you will see it frequently in C programs.
The strcpy in the standard library «string. h» returns the target string as its function value.
The second routine that we will examine is strcmp( s, t), which compares the character strings sand t, and returns negative, zero or positive if s is lexi- cographically less than, equal to, or greater than t. The value is obtained by subtracting the characters at the first position where sand t disagree.
1* strcmp: return <0 if s<t, 0 if s==t, >0 if s>t*1 int strcmp(char *s, char *t)
{
int i;
for (i = 0; s[i] == t[i]; i++) if (s[i] == '\0')
return 0; return s[i] - t[i];
}
The pointer version of strcmp:
1* strcmp: return <0 if s<t, 0 if s==t, >0 if s>t*1 int strcmp(char *s, char *t)
{
for ( ; *s == *t; s++, t++) if (*s == '\0')
return 0; return *s - *t;
}
Since ++ and -- are either prefix or postfix operators, other combinations of
* and ++ and -- occur, although less frequently. For example,
decrements p before fetching the character that p points to. In fact, the pair of
expressions
*p++ = val; 1* push val onto stack *1
val = *--p; 1* pop top of stack into val *1
are the standard idioms for pushing and popping a stack; see Section 4.3.
The header <string. h> contains declarations for the functions mentioned
while (*s++ = *t++)

 SECTION 5.6 POINTER ARRAYS; POINTERS TO POINTERS 107
in this section, plus a variety of other string-handling functions from the stand- ard library.
Exercise5-3.Writeapointerversionofthefunctionstrcat thatweshowed in Chapter 2: strca t (s ,t) copiesthe string t to the end of s. 0
Exercise 5-4. Write the function strend (s ,t ), which returns 1 if the string t occurs at the end of the string s, and zero otherwise. 0
Exercise 5-5. Write versionsof the library functions strncpy, strncat, and strncmp;whichoperateonatmostthefirstncharactersoftheirargument strings. For example, strncpy ( s,t ,n) copiesat most n characters of t to s.
Full descriptions are in Appendix B. 0
Exercise 5-6. Rewrite appropriate programs from earlier chapters and exercises with pointers instead of array indexing. Good possibilities include getline
(Chapters 1 and 4), atoi, i toa, and their variants (Chapters 2, 3, and 4), reverse (Chapter 3), and strindex and getop (Chapter 4). 0
5.6 Pointer Arrays; Pointers to Pointers
Since pointers are variables themselves, they can be stored in arrays just as other variables can. Let us illustrate by writing a program that will sort a set of text lines into alphabetic order, a stripped-down version of the UNIX program
sort.
In Chapter 3 we presented a Shell sort function that would sort an array of
integers, and in Chapter 4 we improved on .it with a quicksort. The same algo- rithms will work, except that now we have to deal with lines of text, which are of different lengths, and which, unlike integers, can't be compared or moved in a single operation. We need a data representation that will cope efficiently and conveniently with variable-length text lines.
Thisiswherethearrayofpointersenters.Ifthelinestobesortedarestored end-to-end in one long character array, then each line can be accessed by a pointer to its first character. The pointers themselves can be stored in an array. Twolinescanbecomparedbypassingtheirpointerstostrcmp.Whentwo out-of-order lines have to be exchanged, the pointers in the pointer array are exchanged, not the text lines themselves.
This eliminates the twin problems of complicated storage management and high overhead that would go with moving the lines themselves.

 108 POINTERS AND ARRAYS CHAPTER S The sorting process has three steps:
read all the lines of input sort them
print them in order
As usual, it's best to divide the program into functions that match this natural division, with the main routine controlling the other functions. Let us defer the sorting step for a moment, and concentrate on the data structure and the input and output.
The input routine has to collect and save the characters of each line, and buildanarrayofpointerstothelines.Itwillalsohavetocountthenumberof input lines, since that information is needed for sorting and printing. Since the input function can only cope with a finite number of input lines, it can return someillegallinecountlike-1iftoomuchinputispresented. .
The output routine only has to print the lines in the order in which they appear in the array of pointers.
#include <stdio.h> #include <strinq.h>
#define MAXLINES 5000 1* max Ilines to be sorted *1
char *lineptr[MAXLINES]; 1* pointers to text lines *1
int readlines(char *lineptr[], int nlines); void writelines(char *lineptr[], int nlines);
void qsort(char *lineptr[], int left, int right);
1* sort input lines *1 maine )
{
} }
int nlines; 1* number of input lines read *1
if «nlines = readlines(lineptr, MAXLINES» >= 0) { qsort(lineptr, 0, nlines-1);
writelines(lineptr, nlines);
return 0;
} else {
printf("error: input too big to sort\n"); return 1;

 SECTION 5.6 POINTER ARRAYS; POINTERS TO POINTERS 109
#define MAXLEN 1000 1* max length of any input line*1 int getline(char *, int);
char *alloc(int);
1*readlines: readinputlines*1
int readlines(char *lineptr[], int maxlines) {
int len, nlines;
char *p, line[MAXLEN];
nlines =0;
while «len =getline(line, MAXLEN» > 0)
if (nlines >= maxlines I I (p = a110c(len» -- NULL) return -1;
else {
line[len-1]='\0'; 1*deletenewline*1 strcpy(p, line);
lineptr[nlines++] =p;
}
return nlines;
}
1*writelines: writeoutputlines*1
void writelines(char *lineptr[], int nlines)
{
}
The function getline is from Section 1.9.
The main new thing is the declaration for lineptr:
char *lineptr[MAXLINES]
says that 1ineptr is an array of MAXLINES elements, each element of which is a pointer to a char. That is, lineptr [i] is a character pointer, and *lineptr [i] is the character it points to, the first character of the i-th saved text line. .
Since lineptr is itself the name of an array, it can be treated as a pointer
}
int i;
for (i =0; i < nlines; i++) printf("~s\n", lineptr[i]);
in the same manner as in our earlier examples, and wri telines ten instead as
1*writelines: writeoutputlines*1
void writelines(char *lineptr[], int nlines)
{
can be writ-
while (nlines-- > 0) printf("~s\n", *lineptr++);

 110 POINTERS AND ARRAYS CHAPTER 5
Initially *lineptr points to the first line; each increment advances it to the nextlinepointerwhilenlines iscounteddown.
With input and output under control, we can proceed to sorting. The quick- sort from Chapter 4 needs minor changes: the declarations have to be modified, andthecomparisonoperationmustbedonebycallingstrcmp. Thealgorithm remains the same, which gives us some confidencethat it will still work.
1*qsort: sortv[left]...v[rightliI?-tioncreasingorder*1 void qsort(char *v[], int left, int right)
{
int i, last;
void swap(char *v[], int i, int j);
if (left >= right) 1* do nothing if array contains *1 returp; 1* fewer than two elements *1
swap(v, left, (left + right)/2); last =left;
for (i = ~eft+1; i <= right; i++)
if (strcmp(v[i], v[left]) < 0) swap(v, ++last, i);
swap(v, left, last); qsort(v, left, last-1); qsort(v, last+1, right);
}
Similarly, the swap routine needs only trivial changes:
1*swap: interchangev[i]andv[j]*1 void swap(char *v[], int i, int j)
{
}
Sinceanyindividualelementofv(aliaslineptr) isacharacterpointer,temp must be also, so one can be copied to the other.
Exercise5-7.Rewritereadlines tostorelinesinanarraysuppliedbymain, rather than calling alloc to maintain storage. How much faster is the pro- gram? 0
5.7 Multi-dimensionalArra~s
C provides rectangular multi-dimensional arrays, although in practice they are much less used than arrays of pointers. In this section, we will show some of their properties.
char *temp;
temp =v[i]; v[i] = v[j]; v[j] =temp;

 SECTION 5.7 MULTI-DIMENSIONAL ARRAYS III
Consider the problem of date conversion, from day of the month to day of the year and vice versa. For example, March 1 is the 60th day of a non-leap year, and the 61st day of a leap year. Let us define two functions to do the conversions: day_of _year_ converts the month and day into the day of the year, and month_day converts the day of the year into the month and day. Since this latter function computes two values, the month and day arguments will be pointers:
month_day(1988, 60, &m, &d)
sets m to 2 and d to 29 (February 29th).
These functions both need the same information, a table of the number of
days in each month ("thirty days hath September ..."). Since the number of days per month differs for leap years and non-leap years, it's easier to separate them into two rows of a two-dimensional array than to keep track of what hap- pens to February during computation. The array and the functions for perform- ing the transformations are as follows:
static char daytab[2][13] = {
to, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31}, to, 31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31}
};
1*day_of_year:setdayofyearfrommonth&day*1 int day_of_year(int year, int month, int day)
{
int i, leap;
leap = year~4 == °&& year%100 1= 0 I I year~400 __ 0; for (i = 1; i < month; i++)
day += daytab[leap][i]; return day;
}
{
}
Recall that the arithmetic value of a logical expression, such as the one for leap, is either zero (false) or one (true), so it can be used as a subscript of the
array day tab.
The array day tab has to be external to both day _of_year and
1*month_day:setmonth,dayfromdayofyear*1
void month_day(int year, int yearday, int *pmonth, int *pday)
int i, leap;
leap=year~4==0&&year~1001=0IIyear~400__0; for (i = 1; yearday> daytab[leap][i]; i++)
yearday -= daytab[leap][i]; *pmonth = i;
*pday = yearday;

 112 POINTERS AND ARRAYS CHAPTER 5
month_day, so they can both use it. We made it char to illustrate a legiti- mate use of char for storing small non-character integers.
day tab is the first two-dimensionalarray we have dealt with. In C, a two- dimensional array is really a one-dimensional array, each of whose elements is an array. Hence subscripts are written as
daytab[i][j] 1* [row][col] *1 rather than
daytab[i,j] 1* WRONG *1
Other than this notational distinction, a two-dimensionalarray can be treated in much the same way as in other languages. Elements are stored by rows, so the rightmost subscript, or column, varies fastest as elements are accessed in storage order.
An array is initialized by a list of initializers in braces; each row of a two- dimensional array is initialized by a corresponding sub-list. We started the array day tab with a column of zero so that month numbers can run from the natural 1 to 12 instead of 0 to 11. Since space is not at a premium here, this is clearer than adjusting the indices.
If a two-dimensional array is to be passed to a function, the parameter declaration in the function must include the number of columns; the number of rows is irrelevant, since what is passed is, as before, a pointer to an array of rows, where each row is an array of 13 ints. In this particular case, it is a pointer to objects that are arrays of 13 ints. Thus if the array day tab is to bepassedtoafunctionf,thedeclarationoffwouldbe
f (int daytab [2][13]) { ... } It could also be
f (int daytab [][13]) { ... }
since the number of rows is irrelevant, or it could be
f (int (*daytab)[13]) { ... }
which says that the parameter is a pointer to an array of 13 integers. The parentheses are necessary since brackets [] have higher precedence than *. Without parentheses, the declaration
int *daytab[13]
is an array of 13 pointers to integers. More generally, only the first dimension (subscript) of an array is free; all the others have to be specified.
Section 5.12 has a further discussion of complicated declarations.
Exercise 5-8. There is no error checking in day_of _year or month_ day. Remedy this defect. 0

 SECTION 5.9 POINTERS VS.MULTI-DIMENSIONAL ARRAYS III 5.8 Initialization of Pointer Arrays
Consider the problem of writing a function month_name (n), which returns a pointer to a character string containing the name of the n-th month. This is an ideal application for an internal static array. month_name contains a private array of character strings, and returns a pointer to the proper one when called. This section shows how that array of names is initialized.
The syntax is similar to previous initializations:
1* month_name: return nameof n-th month *1 char *month_name(int n)
{
static char *name[] = {
"Illegal month",
"January", "February", "March", "April", "May", "June",
"July", "August", "September", "October", "November", "December"
};
return (n < 1 II n > 12) .? name[0] : name[n];
}
The declaration of name, which is an array of character pointers, is the same as 1ineptr in the sorting example. The initializer is a list of character strings; each is assigned to the corresponding position in the array. The characters of the i-th string are placed somewhere, and a pointer to them is stored in name [ i ]. Since the size of the array name is not specified, the compiler
counts the initializers and fills in the correct number.
5.9 Pointers vs. Multi-dimensional Arrays
Newcomers to C are sometimes confused about the difference between a two-dimensional array and an array of pointers, such as name in the example above. Given the definitions
int a[10][20]; int *b[10];
then a [ 3 ] [4] and b [ 3 ] [4] are both syntactically legal references to a single into But a is a true two-dimensional array: 200 int-sized locations have been set aside, and the conventional rectangular subscript calculation 20xrow+col is used to find the element a I[row Hcol]. For b, however, the definition only allo- cates 10 pointers and does not initialize them; initialization must be done expli- citly, either statically or with code. Assuming that each element of b does point to a twenty-element array, then there will be 200 ints set aside, plus ten cells for the pointers. The important advantage of the pointer array is that the rows
of the array may be of different lengths. That is, each element of b need not

 114 POINTERS AND ARRAYS CHAPTER 5
point to a twenty-element vector; some may point to two elements, some to fifty, and some to none at all.
Although we have phrased this discussion in terms of integers, by far the most frequent use of arrays of pointers is to store character strings of diverse lengths, as in the function month_name. Compare the declaration and picture for an array of pointers:
char *name[] = { "Illegal month", "Jan, "Feb", "Mar" }; name:
montihxo
with those for a two-dimensionalarray:
char aname[] [15] = { "Illegal month", "Jan", "Feb", "Mar" };
aname:
IIllegal month\o Jan\o Feb\o Mar\o
0 15 30 45
Exercise5-9. Rewrite the routines day_of_year and month_day with
pointers instead of indexing. 0
5.10 Command-line Arguments
In environments that support C, there is a way to pass command-line argu- ments or parameters to a program when it begins executing. When main is called, it is called with two arguments. The first (conventionallycalled argc, for argument count) is the number of command-line arguments the program was invoked with; the second (argv, for argument vector) is a pointer to an array of character strings that contain the arguments, one per string. We cus- tomarily use multiple levels of pointers to manipulate these character strings.
The simplest illustration is the program echo, which echoes its command- line arguments on a single line, separated by blanks. That is, the command
echo hello, world prints the output
hello, world

 SECTION 5.10 COMMAND-LINE ARGUMENTS 115
By convention, argv [ 0] is the name by which the program was invoked, so argc is at least 1. If argc is 1, there are no command-line arguments after the program name. In the example above, argc is 3, and argv [0I, argv [ 1], and argv[2] are "echo", "hello, ", and "world" respectively. The first optional argument is argv[ 1] and the last is argv[argc-1]; additionally, the standard requires that argv[ argc] be a null pointer.
o
The first version of echo treats argvas an array of character pointers:
'include <stdio.h>
1*echocommand-linearguments;1stversion*1 main(int argc, char *argv[])
{
}
Since argv is a pointer to an array of pointers, we can manipulate the pointer rather than index the array. This next variation is based on incrementing argv, which is a pointer to pointer to char, while argc is counted down:
int i;
for(i= 1;i<argc;i++)
printf(""s"s", argv[i], (i < argc-1) ? "" "");
printf ("\n");
return 0;
'include <stdio.h>
1*echocommand-linearguments;2ndversion*1 ~ain(int argc, char *argv[])
{
}
Since argv
menting it by 1 (++argv) makes it point at the original argv [ 1] instead of argv [ 0 ]. Each successive increment moves it along to the next argument; *argv is then the pointer to that argument. At the same time, argc is decre- mented; when it becomes zero, there are no arguments left to print.
while (--argc > 0)
printf(""8"8", *++argv, (argc > 1) ? ""
printf( "\n");
return 0;
"" ) ;
is a pointer to the beginning of the array of argument strings, incre-
Alternatively, we could write the printf statement as

 116 POINTERS AND ARRAYS CHAPTER 5 printf((argc>1)? ""s":""s",*++arqv);
Thisshowsthattheformatargumentofprintf canbeanexpressiontoo.
As a second example, let us make some enhancements to the pattern-finding program from Section 4.1. If you recall, we wired the search pattern deep into the program, an obviously unsatisfactory arrangement. Following the lead of the UNIX program grep, let us change the program so the pattern to be
matched is specified by the first argument on the command line.
#include <stdio.h> #include <string.h> #define MAXLINE 1000
int getline(char *line, int max);
1*find:printlinesthatmatchpatternfrom1starg*1 main(int argc, char *arqv[])
{
char line[MAXLINE]; int found =0;
if (argo 1= 2)
printf("Usage: find pattern\n");
else
while (getline(line, MAXLINE) > 0)
if (strstr(line, arqv[1]) 1= NULL) { printf(""s", ~ine);
found++;
}
return found;
}
The standard library function strstr (s, t) returns a pointer to the first occurrence of the string t in the string s, or NULL if there is none. It is declaredin<string. h>.
The model can now be elaborated to illustrate further pointer constructions. Suppose we want to allow two optional arguments. One says "print all lines except those that match the pattern;" the second says "precede each printed line by its line number."
A common convention for C programs on UNIX systems is that an argument that begins with a minus sign introduces an optional flag or parameter. If we choose-x{for"except"}tosignaltheinversion,and-n{"number"}torequest line numbering, then the command
find -x -n pattern
will print each line that doesn't match the pattern, preceded by its line number. Optional arguments should be permitted in any order, and the rest of the program should be independent of the number of arguments that were present. Furthermore, it is convenient for users if option arguments can be combined, as

 SECTION 5.10
COMMAND-LINE ARGUMENTS 117
in
find -nx pattern Here is the program:
#include <stdio.h> #include <string.h> #define MAXLINE 1000
int getline(char *line, int max);
1*find:printlinesthatmatchpatternfrom1starg*1 main(int argc, char *argv[])
{
char line[MAXLINE];
long lineno = 0;
int c, except = 0, number = 0, found = 0;
while (--argc > 0 && (*++argv)[O] == '-') while (c = *++argv[O])
switch (c) { case 'x':
except = 1;
break; case 'n':
number = 1 •,
break; default:
printf("find: illegal option "c\n", c); argc =0;
found =-1;
break;
}
if (argc 1= 1)
p!;'int(f"~sa9'e:find -x -n pattern\n");
else
while (getline(line, MAXLINE) > 0) {
lineno++;
if «strstr(line, *argv) 1= NULL) 1= except) {
} }
return found;
if (number)
printf(""ld:", lineno);
printf("%s", line);
found++;
}
argo is decremented and argv is incremented before each optional argu- ment. Attheendoftheloop,iftherearenoerrors,argotellshowmanyargu- ments remain unprocessed and argv points to the first of these. Thus argo

 118 POINTERS AND ARRAYS CHAPTER 5
should be 1 and *argV should point at the pattern. Notice that *++argv is a pointer to an argument string, so (*++argv) [0] is its first character. (An alternate valid form would be **++argv.) Because [] binds tighter than * and ++, the parentheses are necessary; without them the expression would be taken as *++(argv [0] ). In fact, that is what we used in the inner loop, where the task is to walk along a specific argument string. In the inner loop, the expression *++argv[ 0 1increments the pointer argv[ O]!
Itisrarethatoneusespointerexpressionsmorecomplicatedthanthese;in such cases, breaking them into two or three steps will be more intuitive.
Exercise 5-10. Write the program expr, which evaluates a reverse Polish expression from the command line, where each operator or operand is a separate argument. For example,
~xpr 2 3 4 + * evaluates 2 x (3+4). 0
Exercise 5-11. Modify the programs entab and detab (written as exercisesin Chapter 1) to accept a list of tab stops as arguments. Use the default tab set- tings if there are no arguments. 0
Exercise5-12.Extendentabanddetabtoaccepttheshorthand entab -m +n
to mean tab stops every n columns, starting at column m. Choose convenient (for the user) default behavior. 0
Exercise 5-13. Write the program tail, which prints the last n lines of its input. By default, n is 10, let us say, but it can be changed by an optional argument, so that
tail -n
prints the last n lines. The program should behave rationally no matter how unreasonable the input or the value of n. Write the program so it makes the best use of available storage; lines should be stored as in the sorting program of Section 5.6, not in a two-dimensional array of fixed size. 0
5.11 Pointers to Functions
In C, a function itself is not a variable, but it is possible to define pointers to functions, which can be assigned, placed in arrays, passed to functions, returned by functions, and so on. We will illustrate this by modifying the sorting pro- cedure written earlier in this chapter so that if the optional argument -n is given; it will sort the input lines numerically instead of lexicographically.
A sort often consists of three parts-a comparison that determines the

 SECTION 5.11 POINTERS TO FUNCTIONS 119
ordering of any pair of objects, an exchange that reverses their order, and a sorting algorithm that makes comparisons and exchanges until the objects are in order. The sorting algorithm is independent of the comparison and exchange operations, so by passing different comparison and exchange functions to it, we can arrange to sort by different criteria. This is the approach taken in our new sort.
Lexicographiccomparisonoftwolinesisdonebystrcmp, asbefore;wewill also need a routine numcmpthat compares two lines on the basis of numeric value and returns the same kind of condition indication as strcmp does. These functions are declared ahead of main and a pointer to the appropriate one is passed to qsort. We have skimped on error processing for arguments, so as to concentrate on the main issues.
'include <stdio.h> 'include <string.h>
'define MAXLINES 5000 1* max #lines to be sorted *1 char*lineptr[MAXLINES]; 1*pointerstotextlines*1
int readlines(char *lineptr[], int nlines); void writelines(char *lineptr[], int nlines);
void qsort(void *lineptr[], int left, int right, int (*comp)(void *, void *»;
int numcmp(char *, char *);
1* sort input lines *1 main(int argc, char *argv[])
{
int nlines; 1* number of input lines read *1 int numeric = 0; 1* 1 if numeric sort *1
if (argc > 1&.&.strcmp(argv[1], "-n") == 0) numeric = 1;
if «nlines = readlines(lineptr, MAXLINES» >= 0) { qsort«void **)lineptr,0,nlines-1,
(int (*)(void*,void*»(numeric ? numcmp : strcmp»; writelines(lineptr, nlines);
return 0;
} else {
printf("input too big to sort\n"); return 1;
} }
In the call to qsort, strcmp and numcmpare addresses of functions. Since they are known to be functions, the & operator is not necessary, in the same way that it is not needed before an array name.
We have written qsort so it can process any data type, not just character

 110 POINTERS AND ARRAYS CHAPTER 5
strings. As indicated by the function prototype, qsort expects an array of pointers, two integers, and a function with two pointer arguments. The generic pointer type void * is used for the pointer arguments. Any pointer can be cast to void * and back again without loss of information, so we can call qsort by casting arguments to void *. The elaborate cast of the function argument casts the arguments of the comparison function. These will generally have no effect on actual representation, but assure the compiler that all is well.
1*qsort: sortv[left]•..v[right]intoincreasingorder*1 void qsort(void *v[], int left, int right,
{
int (*comp)(void *, void *»
int i, last;
void swap(void *v[], int, int);
if(left>=right) 1*donothingifarraycontains*1 return; 1* fewer than two elements *1
swap(v, left, (left + right)/2); last =left;
for (i = left+1; i <= right; i++)
if «*comp)(v[i], v[left]) < 0) swap(v, ++last, i);
swap(v, left, last);
qsort(v, left, last-1, comp); qsort(v, last+1, right, comp);
}
The declarations should be studied with some care. The fourth parameter of qsort is
int (*comp)(void *, void *)
which says that compis a pointer to a function that has two void * arguments and returns an into
The use of compin the line
if «*comp)(v[i], v[left]) < 0)
is consistent with the declaration: compis a pointer to a function, *compis the function, and
(*comp)(v[i], v[left])
is the call to it. The parentheses are needed so the components are correctly associated; without them,
int *comp(void *, void *) 1* WRONG *1
says that compis a function returning a pointer to an int, which is very dif- ferent.
We have already shown strcmp, which compares two strings. Here is numcmp,which compares two strings on a leading numeric value, computed by

 SECTION 5.11 POINTERS TO FUNCTIONS 121 calling atof:
#include <stdlib.h>
1*numcmp:compares1ands2numerically*1 int numcmp(char *s1, char *s2)
{
double v1, v2;
v1 = atof(s1); v2 =atof(s2); if (v1 < v2)
return -1; else if (v1 > v2)
return 1; else
return 0;
}
The swap function, which exchanges two pointers, is identical to what we presented earlier in the chapter, except that the declarations are changed to void *.
void swap(void *v[], int i, int j)
{
}
A variety of other options can be added to the sorting program; some make challenging exercises.
Exercise5-14.Modifythesortprogramtohandlea-rflag,whichindicates sorting in reverse (decreasing) order. Be sure that -r works with =n, 0
Exercise5-15.Addtheoption-ftofoldupperandlowercasetogether,sothat case distinctions are not made during sorting; for example, a and A compare equal. 0
Exercise5-16.Addthe-d("directoryorder")option,whichmakescomparis- ons only on letters, numbers and blanks. Make sure it works in conjunction with-f. 0
Exercise 5-17. Add a field-handling capability, so sorting may be done on fields within lines, each field sorted according to an independent set of options. (The indexforthisbookwassortedwith-dffortheindexcategoryand-nforthe page numbers') 0
void *temp;
temp =veil; veil = v[j]; v[j] =temp;

 112 POINTERS AND ARRAYS CHAPTER 5 5.12 Complicated Declarations
C is sometimes castigated for the syntax of its declarations, particularly ones that involve pointers to functions. The syntax is an attempt to make the declaration and the use agree; it works well for simple cases, but it can be confusing for the harder ones, because declarations cannot be read left to right, and because parentheses are over-used. The difference between
int *f(); 1* f: function returning pointer to int *1 and
int (*pf)(); 1* pf: pointer to function returning int *1
illustrates the problem: * is a prefix operator and it has lower precedence than ( ), so parentheses are necessary to force the proper association.
Although truly complicated declarations rarely arise in practice, it is impor- tant to know how to understand them, and, if necessary, how to create them. Onegoodwaytosynthesizedeclarationsisinsmallstepswithtypede£,which is discussed in Section 6.7. As an alternative, in this section we will present a pair of programs that convert from valid C to a word description and back again. The word description reads left to right.
Thefirst,del,isthemorecomplex.ItconvertsaCdeclarationintoaword description, as in these examples:
char **argv
argv: pointer to pointer to char
int (*daytab)[13]
daytab: pointer to array[13] of int
int *daytab[13]
daytab: array[13] of pointer to int
void *comp()
comp: function returning pointer to void
void (*comp)()
comp: pointer to function returning void
char (*(*x(»[])()
x: function returning pointer to array[] of pointer to function returning char
char (*(*x[3])(»[S]
x: array[3] of pointer to function returning pointer to array[S] of char
delisbasedonthegrammarthatspecifiesadeclarator,whichisspelledout precisely in Appendix A, Section 8.5; this is a simplified form:
del: optional *'s direct-del direct-dcl: name
(del)
direct-dcl ( )
direct-del [optional size]
In words, a del is a direct-del, perhaps preceded by *'s. A direct-del is a

 SECTION 5.12 COMPLICATED DECLARATIONS 123
name, or a parenthesized del, or a direct -dcl followed by parentheses, or a direct -del followedby brackets with an optional size.
This grammar can be used to parse declarations. For instance, consider this declara tor:
(*pfa[])()
pf a will be identified as a name and thus as a direct -del. Then pf a (] is also a direct-del. Then *pfa [] is a recognized as a del, so (*pfa [ ]) is a direct- del. Then (*pfa [ ] ) ( ) is a direct-del and thus a del, We can also illustrate
the parse with a parse tree like this (where direct-del dir-dcl):
has been abbreviated to
.. ()
}
*
pfa [] I
name
I
dir-dcl
I
dir-del
I
del
I
dir-dcl
I
dir-dcl
I
del
The heart ofthe dcl program isa pair offunctions,dcl and dirdcl, that parse a declaration according to this grammar. Because the grammar is recur- sively defined, the functions call each other recursively as they recognize pieces of a declaration; the program is called a recursive-descent parser.
1*dcl:parseadeclarator*1 void dcl(void)
{
int ns;
for(ns=0;qettoken()--'*'; 1*count*'s*1 ns++;
dirdcl();
while (ns-- > 0)
strcat(out, " pointer to");

 124 POINTERS AND ARRAYS
CHAPTER 5
1*dirdcl: parseadirectdeclarator*1 void dirdcl{void)
{
int type;
if (tokentype == '(') { dcl ();
1* ( dcl ) *1
if (tokentype 1= ')') printf{"error: missing )'n");
} else if (tokentype == NAME) 1* variable name *1 strcpy{name, token);
else
printf("error: expected name or (dcl)'n");
while«type=gettoken(» ==PARENSIItype==BRACKETS) if (type == PARENS)
strcat(out,II functionreturning"); else {
strcat(out,II array"); strcat(out, token); strcat(out,II of"J;
Since the programs are intended to be illustrative, not bullet-proof, there are significantrestrictionsondel. Itcanonlyhandleasimpledatatypelikechar or into It does not handle argument types in functions, or qualifiers like const. Spurious blanks confuse it. It doesn't do much error recovery, so invalid declarations will also confuse it. These improvements are left as exer- cises.
Here are the global variables and the main routine:
'include <stdio.h> 'include <string.h> 'include <ctype.h>
#define MAXTOKEN 100
enum { NAME, PARENS, BRACKETS } ;
void dcl(void); void dirdcl(void);
int gettoken(void);
int tokentype;
char token[MAXTOKEN];
char name[MAXTOKEN];
chardatatype[MAXTOKEN]; 1*datatype=char,int,etc.*1 char out[1000] ; 1* output string *1
} }
1*typeoflasttoken*1 1* last token string *1 1* identifier name *1

 SECTION 5.12 COMPLICATED DECLARATIONS 125
maine) 1* convert declaration to words *1
{
while(gettoken()1=EOF){ 1*1sttokenonline*1
strcpy(datatype, token); 1* is the datatype *1 out[0] = \'0' ;
dcl(); 1* parse rest of line *1
if (tokentype 1= '\n')
printf("syntax error\n");
printf(""s: "S"s\n", name, out, datatype);
}
return 0;
}
The function gettoken skips blanks and tabs, then finds the next token in the input; a "token" is a name, a pair of parentheses, a pair of brackets perhaps including a number, or any other single character.
intgettoken(void) 1*returnnexttoken*1 {
int c, getch(void); void ungetch(int); char *p =token;
while«c=getch(» --, , II c =='\t')
if(c == '(') {
if «c = getch(» == ')') {
strcpy(token, "()");
return tokentype =PARENS; } else {
ungetch (c) ;
return tokentype = '('; }
}elseif(c== '[') {
for (*p++ = c; (*p++ = getch(»
;
*p='\0';
return tokentype =BRACKETS; }elseif(isalpha(c» {
1= ']'; )
for (*p++ =c; isalnum(c =getch(»; *p++ =c;
*p = '\0';
ungetch (c) ;
return tokentype =NAME;
} else
return tokentype =c;
}
getch and ungetch were discussed in Chapter 4.
Going in the other direction is easier, especially if we do not worry about
generating redundant parentheses. The program undcl converts a word

 126 POINTERS ANI) ARRAYS CHAPTER 5
description like "x is a function returning a pointer to an array of pointers to functions returning char," which we will express as
x ()* []* ()char
to
char (*(*x(»[])()
The abbreviated input syritax lets us .reuse the gettoken uses the same external variables asdcl does.
function. undcl also
1*undcl:convertworddescriptiontodeclaration*1 maine )
{
int type;
char tellip[JUXTOKEN];
while (qettoken() 1= EOF) {
strcpy(out, token);
while « type =qettoken(» 1= '\n')·
if (type =~ PARENS I I type == BRACKETS) strcat(out, token);
else if (type == '*') { sprintf(temp, "(*"s)", out); strcpy(out, temp);
} else if (type == NAME) { sprintf(temp, ""s "s", token, out); strcpy(out, temp);
} else
printf("invalid input at "s\n", token);
printf(""s\n", out);
}
return 0;
}
Exercise 5-18. Make dcl recover from input errors. 0
Exercise 5-19. Modify undcl so that it does not add redundant parentheses to
declarations. 0
Exercise5-20. Expand dcl to handle declarations with function argument types, qualifiers like const, and so on. 0

 CHAPTER 6: Structures
A structure is a collection of one or more variables, possibly of different types, grouped together under a single name for convenient handling. (Struc- tures are called "records" in some languages, notably Pascal.) Structures help to organize complicated data, particularly in large programs, because they per- mit a group of related variables to be treated as a unit instead of as separate entities.
One traditional example of a structure is the payroll record: an employee is described by a set of attributes such as name, address, social security number, salary, etc. Some of these in turn could be structures: a name has several com- ponents, as does an address and even a salary. Another example, more typical for C, comes from graphics: a point is a pair of coordinates, a rectangle is a pair of points, and so on.
The main change made by the ANSI standard is to define structure assignment-structures may be copied and assigned to, passed to functions, and returned by functions. This has been supported by most compilers for many years, but the properties are now precisely defined. Automatic structures and arrays may now also be initialized.
6. 1 Basics of Structures
Let us create a few structures suitable for graphics. The basic object is a point, which we will assume has an x coordinate and a y coordinate, both integers.
y
(0,0)
127
• (4,3)

 128 STRUCTURES
The two components can be placed in a structure declared like this:
struct point { int X;
int y; };
CHAPTER 6
The keyword struct introduces a structure declaration, which is a list of declarations enclosed in braces. An optional name called a structure tag may followthe word struct (as with point here). The tag names this kind of structure, and can be used subsequently as a shorthand for the part of the declaration in braces.
The variables named in a structure are called members. A structure member or tag and an ordinary (i.e., non-member) variable can have the same name without conflict, since they can always be distinguished by context. Furthermore, the same member names may occur in different structures, although as a matter of style one would normally use the same names only for closelyrelated objects.
Astructdeclarationdefinesatype.Therightbracethatterminatesthe list of members may be followed by a list of variables, just as for any basic type. That is,
struct{...}x,y, Z; is syntactically analogous to
int x, y, Z;
in the sense that each statement declares x, y and z to be variables of the named type and causes space to be set aside for them.
A structure declaration that is not followed by a list of variables reserves no storage; it merely describes a template or the shape of a structure. If the declaration is tagged, however, the tag can be used later in definitions of instancesofthestructure. Forexample,giventhedeclarationofpointabove,
struct point pt;
definesavariableptwhichisastructureoftypestructpoint. Astructure can be initialized by.followingits definition with a list of initializers, each a con- stant expression, for the members:
struct point maxpt = {320, 200 };
An automatic structure may also be initialized by assignment or by calling a function that returns a structure of the right type.
A member of a particular structure is referred to in an expression by a con- struction of the form
structure-name. member
The structure member operator "." connects the structure name and the membername.Toprintthecoordinatesofthepointpt,forinstance,

 SECTION 6.2 STRUCTURES AND FUNCTIONS 129
printf(1I~,~n, pt.X, pt.y);
or to compute the distance from the origin (0,0) to pt,
double dist, sqrt(double);
dist =sqrt«double)pt.x * pt.x + (double)pt.y * pt.y);
Structures can be nested. One representation of a rectangle is a pair of points that denote the diagonally opposite corners:
y
D Pt2
pt1 --+-----------~x
struct rect {
struct point pt1; struct point pt2;
};
The rect structure contains two point structures. If we declare screen as
struct rect screen;
then
refers to the x coordinate of the pt 1 member of screen.
6.2 Structures and Functions
The only legal operations on a structure are copying it or assigning to it as a unit, taking its address with &, and accessing its members. Copy and assign- ment include passing arguments to functions and returning values from func- tions as well. Structures may not be compared. A structure may be initialized by a list of constant member values; an automatic structure may also be initial- ized by an assignment.
Let us investigate structures by writing some functions to manipulate points and rectangles. There are at least three possible approaches: pass components separately, pass an entire structure, or pass a pointer to it. Each has its good points and bad points.
Thefirstfunction,makepoint,willtaketwointegersandreturnapoint structure:
screen.pt1.x

 130 STRUCTURES CHAPTER 6
1* makepoint: make a point from x and y components *1 struct point makepoint(int x, int y)
{
struct point temp;
temp.x =x; temp.y =y; return temp;
}
Notice that there is no conflict between the argument name and the member with the same name; indeed the re-use of the names stresses the relationship.
makepointcannowbeusedtoinitializeanystructuredynamically,orto provide structure arguments to a function:
struct rect screen;
struct point middle;
struct point makepoint(int, int);
screen.pt1 =makepoint(O, 0);
screen.pt2 =makepoint(XMAX, YMAX);
middle =makepoint((screen.pt1.x + screen.pt2.x)/2,
(screen.pt1.y + screen.pt2.y)/2);
The next step is a set of functions to do arithmetic on points. For instance,
1* addpoint: add two points *1
struct point addpoint(struct point p1, struct point p2) {
p1.x += p2.x; p1.y += p2.y; return p1;
}
Here both the arguments and the return value are structures. We incremented the components in p 1 rather than using an explicit temporary variable to emphasize that structure parameters are passed by value like any others.
As another example, the function ptinrect tests whether a point is inside a rectangle, where we have adopted the convention that a rectangle includes its left and bottom sides but not its top and right sides:
1*ptinrect: return1ifpinr,0ifnot*1 int ptinrect(struct point p, struct rect r)
{
return p.x >= r.pt1.x && p.x < r.pt2.x && p.y >= r.pt1.y && p.y < r.pt2.y;
}
This assumes that the rectangle is represented in a standard form where the pt 1 coordinates are less than the pt2 coordinates. The following function. returns a rectangle guaranteed to be in canonical form:

 SECTION 6.2 STRUCTURES AND FUNCTIONS 131
'define min(a, b) «a) < (b) ? (a) (b) #definemax(a,b) «a)>(b) ?(a) (b))
/* canonrect: canonicalize coordinates struct rect canonrect(struct rect r)
{
struct rect temp;
temp.pt1.x =min(r.pt1.x, r.pt2.x); temp.pt1.y =min(r.pt1.y, r.pt2.y); temp.pt2.x =max(r.pt1.x, r.pt2.x); temp.pt2.y =max(r.pt1.y, r.pt2.y); return temp;
}
of rectangle */
Ifalargestructureistobepassedtoafunction,itisgenerallymoreefficient to pass a pointer than to copy the whole structure. Structure pointers are just like pointers to ordinary variables. The declaration
struct point *pp;
says that pp is a pointer to a structure of type struct point. If pp points to a point structure, *pp is the structure, and (*pp). x and (*pp). yare the members.Tousepp,wemightwrite,forexample,
struct point origin, *pp;
pp =&origin;
printf("origin is (%d,%d)\n", (*pp).x, (*pp).y);
The parentheses are necessary in <*pp). x because the precedence of the struc- turememberoperator.ishigherthan*.Theexpression*pp.xmeans *(pp.x), whichisillegalherebecausex isnotapointer.
Pointers to structures are so frequently used that an alternative notation is providedasashorthand.Ifpisapointertoastructure,then
p->member-of-structure
referstotheparticularmember.(Theoperator->isaminussignimmediately followed by >.) So we could write instead
printf("origin is (%d,%d)\n", pp->x, pp->y);
Both•and-> associatefromlefttoright,soifwehave struct rect r, *rp =&r;
then these four expressionsare equivalent:
      r.pt1.x
      rp->pt1.x
(r. pt1).x (rp->pt1).x

 131 STRUCTURES CHAPTER 6
The structure operators. and ->, together with () for function calls and [] for subscripts, are at the top of the precedence hierarchy and thus bind very tightly. For example, given the declaration
struct { int len;
char *str; } *p;
then
increments len, not p, because the implied parenthesization is ++(p->len). Parentheses can be used to alter the binding: (++p)->len increments p before accessing len,· and (p++)- >1en increments p afterward. (This last set of parentheses is unnecessary.)
In the same way, *p->str fetches whatever str points to; *p->str++ increments str after accessing whatever it points to (just like *s++); (*p->str )++ increments whatever str points to; and *p++->str increments
pafteraccessingwhateverstr pointsto.
6.3 Arrays of Structure.
Consider writing a program to count the occurrences of each C keyword. We need an array of character strings to hold the names, and an array of integersforthecounts. Onepossibilityistousetwoparallelarrays,keyword and keycount, as in
char *keyword[NKEYS]; int keycount[NKEYS];
But the very fact that the arrays are parallel suggests a different organization, an array of structures. Each keyword entry is a pair:
char *word; int count;
and there is an array of pairs. The structure declaration
struct key { char *word;
int count; } keytab[NKEYS];
declares a structure type key, defines an array keytab of structures of this type, and sets aside storage for them. Each element of the array is a structure. This could also be written
++p->len

 SECTION 6.3
ARRAYS OF STRUCTURES 133
struct key { char *word;
int count;
};
struct key keytab[NKEYS];
Sincethestructurekeytabcontainsaconstantsetofnames,itiseasiestto make it an external variable and initialize it once and for all when it is defined. The structure initialization is analogous to earlier ones-the definition is fol- lowed by a list of initializers enclosed in braces:
struct key { char *word;
int count; }keytab[]= {
"auto", ,0, "break", 0, "case", 0, "char", 0, "const", 0, "continue", 0, "default", 0,
1* ••. *1
"unsigned", 0, "void", 0, "volatile"°, 0, "while",
};
Theinitializersarelistedinpairscorrespondingtothestructuremembers.It would be more precise to enclose initializers for each "row" or structure in braces, as in
{ "auto", ° }, { "break", ° }, { "case", ° },
but the inner braces are not necessary when the initializers are simple variables or character strings, and when all are present. As usual, the number of entries inthearraykeytabwillbecomputedifinitializersarepresentandthe[]is left empty.
Thekeyword-countingprogrambeginswiththedefinitionofkeytab. The main routine reads the input by repeatedly calling a function getword that fetchesonewordatatime.Eachwordislookedupinkeytabwithaversion of the binary search function that we wrote in Chapter 3. The list of keywords must be sorted in increasing order in the table.

 134 STRUCTURES
CHAPTER 6
#include <stdio.h> #include <ctype.h> #include <string.h>
#define MAXWORD 100
int getword(char *, int);
int binsearch(char *, struct key *, int);
1* countCkeywords*1 maine )
{
int n;
char word[MAXWORD];
while (getword(word, MAXWORD) 1= EOP) if (isalpha(word[O]»
if «n = binsearch(word, keytab, NKEYS» >= 0) keytab[n].count++;
for (n = 0; n < NKEYS; n++) if (keytab[n].count > 0)
printf("%4d "s\n",
keytab[n].count, keytab[n].word);
return 0;
}
1* binsearch: findwordintab[0]...tab[n-1]*1 int binsearch(char *word, struct key tab[], int n) {
int cond;
int low, high, mid;
low = 0;
high = n - 1;
while (low <= high) {
mid = (low+high) I 2;
if «cond = strcmp(word, tab[mid].word» < 0)
high = mid - 1; else if (cond > 0) low = mid + 1;
else
return mid;
}
return -1;
}
We will show the function getword in a moment; for now it suffices to say that each call to getword finds a word, which is copied into the array named as its first argument.
ThequantityNKEYSisthenumberofkeywordsinkeytab. Althoughwe

 SECTION 6.3 ARRAYS OF STRUCTURES 135
could count this by hand, it's a lot easier and safer to do it by machine, espe- cially if the list is subject to change. One possibility would be to terminate the list of initializers with a null pointer, then loopalong keytab until the end is found.
But this is more than is needed, since the size of the array is completely determined at compile time. The size of the array is the size of one entry times the number of entries, so the number of entries is just
size of keytab / size of struct key
C provides a compile-time unary operator called sizeof
compute the size of any object. The expressions
sizeof object and
sizeof(type name)
that can be used to
yield an integer equal to the size of the specified object or type in bytes. (Strictly, sizeof produces an unsigned integer value whose type, size_ t, is defined in the header <stddef. h>.) An object can be a variable or array or
structure. A type name can be the name of a basic type like int or double, or a derived type like a structure or a pointer.
In our case, the number of keywords is the size of the array divided by the size of one element. This computation is used in a #define statement to set the value of NKEYS:
#define NKEYS (sizeofkeytab/sizeof(structkey»
Another way to write this is to divide the array size by the size of a specific ele- ment:
#define NKEYS (sizeofkeytab/sizeofkeytab[O])
This has the advantage that it does not need to be changed if the type changes. A sizeof can not be used in a #if line, because the preprocessordoes not parse type names. But the expressionin the #define is not evaluated by the
preprocessor, so the code here is legal.
Nowforthefunctiongetword. Wehavewrittenamoregeneralgetword
than is necessary for this program, but it is not complicated. getword fetches the next "word" from the input, where a word is either a string of letters and digits beginning with a letter, or a single non-white space character. The func- tion value is the first character of the word, or EOF for end of file, or the char- acter itself if it is not alphabetic.

 136 STRUCTURES CHAPTER 6
1* getword: get next word or character from input*1 int getword(char *word, int lim)
{
int c, getch(void); void ungetch(int); char *w =word;
while (isspace(c =getch(»)
if (c 1= EOF) *w++ = c;
if (Iisalpha(c)) { *w= '\0';
return c,; }
for(;--lim> 0;w++) if(Iisalnum(*w=getch(») {
ungetch (*w) ;
break;
}
*w = '\0';
return word[O];
}
getword uses the getch and ungetch that we wrote in Chapter 4. When the collectionofan alphanumeric tokenstops,getword hasgoneonecharacter too far. The call to ungetch pushes that character back on the input for the next call. getword also uses isspace to skip white space, isalpha to iden- tify letters, and isalnum to identify letters and digits; all are from the stand- ard header <ctype .h>.
Exercise6-1. Our version of getword does not properly handle underscores, string constants, comments, or preprocessor control lines. Write a better ver- sion. 0
6.4 Pointer. to Structure.
To illustrate some of the considerations involvedwith pointers to and arrays of structures, let us write the keyword-counting program again, this time using pointers instead of array indices.
The external declaration of keytab need not change, but main and binsearch do need modification.

 SECTION 6.4
POINTERS TO STRUCTURES 137
#include <stdio.h> #include <ctype.h> #include <string.h> #define MAXWORD 100
int getword(char *, int);
struct key *binsearch(char *, struct key *, int);
1*countCkeywords;pointerversion*1 maine )
{
char word[MAXWORD]; struct key *p;
while (getword(word, MAXWORD) 1= EOF) if (isalpha(word[O]»
if«p=binsearch(word, keytab,NKEYS» 1=NULL) p->count++;
for (p = keytab; p < keytab + NKEYS; p++) if (p->count > 0)
printf(""4d "s\n", p->count, p->word); return 0;
}
1*binsearch:findwordintab[0]•.•tab[n-1]*1
struct key *binsearch(char *word, struct key *tab, int n) {
int cond;
struct key *low = &tab[O]; struct key *high = &tab[n]; struct key *mid;
while (low < high) {
mid = low + (high-low) I 2;
if «cond = strcmp(word, mid->word» < 0)
high = mid; else if (cond > 0) low = mid + 1;
else
return mid;
}
return NULL;
}
There are several things worthy of note here. First, the declaration of binsearch must indicate that it returns a pointer to struct key instead of an integer; this is declared both in the function prototype and in binsearch. If binsearch finds the word, it returns a pointer to it; if it fails, it returns NULL.
Second, the elements of keytab are now accessed by pointers. This

 138 STRUCTURES CHAPTER 6
requires significant changes in binsearch.
The initializers for low and high are now pointers to the beginning and just
past the end of the table.
The computation of the middle element can no longer be simply
mid =(low+high) I 2 1* WRONG *1
because the addition of two pointers is illegal. Subtraction is legal, however, so
high-low is the number of elements, and thus
mid =low + (high-low) I 2
setsmidtopointtotheelementhalfwaybetweenlowandhigh.
The most important change is to adjust the algorithm to make sure that it does not generate an illegal pointer or attempt to access an element outside the array.Theproblemisthat&.tab[-1]and&.tab[n]arebothoutsidethelim- its of the array tab. The former is strictly illegal, and it is illegal to derefer- ence the latter. The language definition does guarantee, however, that pointer arithmetic that involves the first element beyond the end of an array (that is,
&t.ab [n]) willworkcorrectly. In main wewrote
for (p =keytab; p < keytab + NKEYS; p++)
Ifpisapointertoastructure,arithmeticonptakesintoaccountthesizeofthe structure, so p+ + increments p by the correct amount to get the next element of the array of structures, and the test stops the loop at the right time.
Don't assume, however, that the size of a structure is the sum of the sizes of its members. Because of alignment requirements for different objects, there may be unnamed "holes" in a structure. Thus, for instance, if a char is one byte and an int four bytes, the structure
struct { char c;
int i;
};
might well require eight bytes, not five. The sizeof proper value.
operator returns the
Finally, an aside on program format: when a function returns a complicated type like a structure pointer, as in
struct key *binsearch(char *word, struct key *tab, int n)
the function name can be hard to see, and to find with a text editor. Accord- ingly an alternate style is sometimes used:
struct key *
binsearch(char *word, struct key *tab, int n)
This is a matter of personal taste; pick the form you like and hold to it.

 SECTION 6.5 SELF-REFERENTIAL STRUCTURES 139
6.5 Self-referential Structures
Suppose we want to handle the more general problem of counting the occurrences of all the words in some input. Since the list of words isn't known in advance, we can't conveniently sort it and use a binary search. Yet we can't do a linear search for each word as it arrives, to see if it's already been seen; the program would take too long. (More precisely, its running time is likely to grow quadratically with the number of input words') How can we organize the data to cope efficiently with a list of arbitrary words?
One solution is to keep the set of words seen so far sorted at all times, by placing each word into its proper position in the order as it arrives. This shouldn't be done by shifting words in a linear array, though- that also takes too long. Instead we will use a data structure called a binary tree.
The tree contains one "node" per distinct word; each node contains
a pointer to the text of.the word
a count of the number of occurrences a pointer to the left child node
a pointer to the right child node
No node may have more than two children; it might have only zero or one.
The nodes are maintained so that at any node the left subtree contains only words that are lexicographically less than the word at the node, and the right subtree contains only words that are greater. This is the tree for the sentence "now is the time for all good men to come to the aid of their party", as built by
inserting each word as it is encountered:
now
is/" the
fo! ~n o( "time
/\\/\ all good party their to
/\ aid come
To find out whether a new word is already in the tree, start at the root and compare the new word to the word stored at that node. If they match, the ques- tion is answered affirmatively. If the new word is less than the tree word, con- tinuesearchingattheleftchild,otherwiseattherightchild.Ifthereisnochild in the required direction, the new word is not in the tree, and in fact the empty slot is the proper place to add the new word. This process is recursive, since the search from any node uses a search from one of its children. Accordingly, recursive routines for insertion and printing will be most natural.
Going back to the description of a node, it is conveniently represented as a structure with four components:

 140 STRUCTURES struct tnode {
CHAPTER 6
1* the tree node: *1
1* points to the text *1 1* number of occurrences *1 1* left child *1
char *word;
int eountj
struct tnode *left;
struct tnode *right; 1* right child *1
};
This recursive declaration of a node might look chancy, but it's correct. It is
illegal for a structure to contain an instance of itself, but
struct tnode *left;
declares left to be a pointer to a tnode, not a tnode itself.
Occasionally, one needs a variation of self-referential structures: two struc-
tures that refer to each other. The way to handle this is:
struct t { struct s *p;
};
struct s {
struct t *q;
1* p points to an s*1
1* q points to a t*1
};
The code for the whole program is surprisingly small, given a handful of sup- porting routines like getword that we have already written. The main routine readswordswithgetwordandinstallstheminthetreewithaddtree.
#include <stdio.h> #include <ctype.h> #include <string.h>
#define MAXWORD 100
struct tnode *addtree(struct tnode *, char *); void treeprint(struct tnode *);
int getword(char *, int);
1* word frequency count *1 maine )
{
}
struct tnode *root; char word[MAXWORD];
root :I: NULL;
while (getword(word, MAXWORD) 1= EOP)
if (isalpha(word[O]»
root :I: addtree(root, word);
treeprint(root);
return 0;

 SECTION 6.5 SELF·REFERENTIAL STRUCTURES 141
Thefunctionaddtree isrecursive.Awordispresentedbymaintothetop level (the root) of the' tree. At each stage, that word is compared to the word already stored at the node, and is percolated down to either the left or right sub- treebyarecursivecalltoaddtree. Eventuallythewordeithermatchessome- thing already in the tree (in which case the count is incremented), or a null pointer is encountered, indicating that a node must be created and added to the tree. If a new node is created; addtree returns a pointer to it, which is installed in the parent node.
struct tnode *talloc(void); char *strdup(char *);
1* addtree: add a node with w, at or below p*1 struct tnode *addtree(struct tnode *p, char *w) {
int cond;
if (p == NULL) { 1* a new word has arrived *1 p = talloc(); 1* make a new node *1 p->word =strdup(w);
p->count = 1;
p->left =p->right =NULL;
} else if «cond = strcmp(w, p->word» == 0)
p->count++; 1* repeated word *1
else if (cond < 0) 1* less than into left subtree *1
p->left =addtree(p->left, w);
else 1* greater than into right subtree *1
p->right = addtree(p->right, w); return p;
}
Storage for the new node is fetched by a routine talloc, which returns a pointer to a free space suitable for holding a tree node, and the new word is copied to a hidden place by strdup. (We will discuss these routines in a moment.) The count is initialized, and the two children are made null. This part of the code is executed only at the leaves of the tree, when a new node is being added. We have (unwisely) omitted error checking on the values returned by strdup and talloc.
treeprint prints the tree in sorted order; at each node, it prints the left subtree, (all the words less than this word), then the word itself, then the right subtree (all the words greater). If you feel shaky about how recursion works, simulate treeprint as it operates on the tree shownabove.

 142 STRUCTURES
CHAPTER 6
1*treeprint:in-orderprintoftreep*1 void treeprint(struct tnode *p)
{
if (p I=NULL) {
treeprint(p->left);
printf(""4d %s\n", p-o-count,;p->word); treeprint(p->right);
} }
A practical note: if the tree becomes "unbalanced" because the words don't arrive in random order, the running time of the program can grow too much. As a worst case, if the words are already in order, this program does an expen- sive simulation of linear search. There are generalizations of the binary tree that do not suffer from this worst-case behavior, but we will not describe them here.
Before we leave this example, it is also worth a brief digression on a problem related to storage allocators. Clearly it's desirable that there be only one storage allocator in a program, even though it 'allocates different kinds of objects. But if one allocator is to process requests for, say, pointers to ehars and pointers to struet tnodes, two questions arise. First, how does it meet the requirement of most real machines that objects of certain types must satisfy alignment restrictions (for example, integers often must be located at even addresses)? Second, what declarations can c<?pewith the fact that an allocator must necessarily return different kinds of pointerss
Alignment requirements can generally be satisfied easily, at the cost of some wasted space, by ensuring that the allocator always returns a pointer that meets all alignment restrictions. The alloe of Chapter 5 does not guarantee any particular alignment, so we will use the standard library function malloe, which does. In Chapter 8 we will show one way to implement malloe.
The question of the type declaration for a function like malloe is a vexing one for any language that takes its type-checking seriously. In C, the proper method is to declare that malloe returns a pointer to void, then explicitly coerce the pointer into the desired type with a cast. malloe and related rou-
tines are declared in the standard header <stdlib. written as
#include <$tdlib.h>
1* talloc: make ~ tnode *1 struct tnod~ *taltoc(void) {
h>. Thus talloe
can be
return (struct tnode *) mallop(sizeof(struct tnode»;
}
strdup merely copies the string given by its argument into a safe place, obtained by a call on nlalloe:

 SECTION 6.6 TABLE LOOKUP 143
char*strdup(char*s) 1*makeaduplicateofs*1 {
char *p;
p=(char*)malloc(strlen(s)+1); 1*+1for'\0'*1 if (p 1= NULL)
strcpy(p, s); return p;
}
returns NULLif no space is available; strdup
Storage obtained by calling malloc may be freed for re-use by calling free; see Chapters 7 and 8.
Exercise 6-2. Write a program that reads a C program and prints in alphabeti- cal order each group of variable names that are identical in the first 6 charac- ters, but different somewhere thereafter. Don't count words within strings and comments. Make 6 a parameter that can be set from the command line. 0
Exercise 6-3. Write a cross-referencer that prints a list of all words in a docu- ment, and, for each word, a list of the line numbers on which it occurs. Remove noise words like "the," "and," and so on. 0
Exercise 6-4. Write a program that prints the distinct words in its input sorted into decreasing order of frequency of occurrence. Precede each word by its count. 0
6.6 TableLookup
In this section we will write the innards of a table-lookup package, to illus- trate more aspects of structures. This code is typical of what might be found in the symbol table management routines of a macro processor or a compiler. For example, consider the #define statement. When a line like
#define IN 1
is encountered, the name IN and the replacement text 1 are stored in a table. Later, when the name IN appears in a statement like
state =IN;
it must be replaced by 1.
There are two routines that manipulate the names and replacement texts.
install (s, t) records the name s and the replacement text t in a table; s and t are just character strings. lookup (s) searches for s in the table, and returnsapointertotheplacewhereitwasfound,orNULLifitwasn'tthere.
malloc
leaving error-handling to its caller.
passes that value on,
The algorithm is a hash search - the incoming name is converted into a small

 144 STRUCTURES CHAPTER 6
non-negative integer, which is then used to index into an array of pointers. An array element points to the beginning of a linked list of blocks describing names that have that hash value. It is NULL if no names have hashed to that value.
name defn
A block in the list is a structure containing pointers to the name, the replacement text, and the next block in the list. A null next-pointer marks the end of the list.
struct nlist { 1* table entry: *1
struct nlist *next; char *name;
char *defn;
};
The pointer array is just
1* next entry in chain *1 1* defined name *1
1* replacement text *1
#define HASHSIZE 101
static struct nlist *hashtab[HASHSIZE]; 1* pointer table *1
The hashing function, which is used by both lookup and install, adds each character value in the string to a scrambled combination of the previous ones and returns the remainder modulo the array size. This is not the best pos- sible hash function, but it is short and effective.
1* hash: form hash value for string s*1 unsigned hash(char *s)
{
}
Unsigned arithmetic ensures that the hash value is non-negative.
The hashing process produces a starting index in the array hashtab; if the string is to be found anywhere, it will be in the list of blocks beginning there.
The search is performed by lookup. If lookup finds the entry already present, it returns a pointer to it; if not, it returns NULL.
unsigned hashval;
for (hashval = 0; *s 1= '\0'; s++) hashval =*s + 31 * hashval;
return hashval % HASHSIZE;

 SECTION 6.6 TABLE LOOKUP 145
1*lookup: lookforsinhashtab*1 struct nlist *lookup(char *s)
{
}
struct nlist *np;
for (np = hashtab[hash(s)]; np 1= NULL; np = np->next) if (strcmp(s, np->name) == 0)
return np; 1* found *1 return NULL; 1* not found *1
The for loopin lookup isthe standard idiomforwalkingalonga linkedlist:
for (ptr = head; ptr 1= NULL; ptr = ptr->next)
install uses lookup to determine whether the name being installed is already present; if so, the new definition will supersede the old one. Otherwise, a new entry is created. install returns NULLif for any reason there is no room for a new entry.
struct nlist *lookup(char *); char *strdup(char *);
1*install: put(name,defn)inhashtab*1 struct nlist *install(char *name, char *defn) {
struct nlist *np; unsigned hashval;
if «np = lookup(name» == NULL) { 1* not found *1
np =(struct nlist *) malloc(sizeof(*np»;
if (np == NULL I I (np->name = strdup(name» == NULL)
return NULL;
hashval =hash(name); np->next =hashtab[hashval]; hashtab[hashval] =np;
} else 1* already there *1
free«void *) np->defn); 1* free previous defn *1
if «np->defn = strdup(defn» == NULL) return NULL;
return np;
}
Exercise6-5.Writeafunctionundefthatwillremoveanameanddefinition from the table maintained by lookup and install. 0
Exercise6-6.Implementasimpleversionofthe#define processor(i.e.,no arguments) suitable for use with C programs, based on the routines of this sec- tion. You may also find getch and ungetch helpful. 0

 146 STRUCTURES CHAPTER 6 6.7 Typedef
C provides a facility called typedef for creating new data type names. For example, the declaration
typedef int Length;
makes the name Length a synonym for into The type Length can be used in declarations, casts, etc., in exactly the same ways that the type int can be:
Length len,maxlen; Length dengths[] ;
Similarly, the declaration
typedef char *String;
makes String a synonym for char * or character pointer, which may then be used in declarations and casts:
String p, lineptr[MAXLINES], alloc(int); intostrcmp(String, String);
p = (String) malloc(100);
Notice that the type being declared in a typedef appears in the position of a variable name, not right after the word typedef. Syntactically, typedef is like the storage classes extern, static, etc. We have used capitalized names for typedefs, to make them stand out.
As a more complicated example, we could make typedefs for the tree nodes shown earlier in this chapter:
typedef struct tnode *Treeptr;
typedef struct tnode { char *word;
int count; Treeptr left; Treeptr right;
1* the tree node: *1
1* points to the text *1 1* number of occurrences *1 1* left child *1
1* right child *1
} Treenode;
This creates two new type keywords called Treenode (a structure) and
Treeptr (a pointer to the structure). Then the routine talloc could become
Treeptr talloc(void)
{
}
It must be emphasized that a typedef declaration does not create a new type in any sense; it merely adds a new name for some existing type. Nor are there any new semantics: variables declared this way have exactly the same pro- perties as variables whose declarations are spelled out explicitly. In effect, typedef is like #define, except that since it is interpreted by the compiler, it
return (Treeptr) malloc(sizeof(Treenode»;

 SECTION 6.8 UNIONS 147
can cope with textual substitutions that are beyond the capabilities of the preprocessor. For example,
typedef int (*PFI)(char *, char *);
creates the type PFI, for "pointer to function (of two char * arguments) returning int," which can be used in contexts like
PFI strcmp, numcmp;
in the sort program of Chapter 5.
Besides purely aesthetic issues, there are two main reasons for using
typedefs. The first is to parameterize a program against portability problems. Iftypedefs areusedfordatatypesthatmaybemachine-dependent,onlythe typedefs need change when the program is moved. One common situation is to' use tyPedef names for various integer quantities, then make an appropriate set of choices of short, int, and long for each host machine. Types like siz;~_ ~ and ptrdiff_ t from the standard library are examples.
The second purpose of typedefs is to provide better documentation for a program-a type called Treeptr may be easier to understand than one declared only as a pointer to a complicated structure.
6.8 Unions
A union is a variable that may hold {at different times> objects of different types and sizes, with the compiler keeping track of size and alignment require- ments. Unions provide a way to manipulate different kinds of data in a single area of storage, without embedding any machine-dependent information in the program. They are analogous to variant records in Pascal.
As an example such as might be found in a compiler symbol table manager, suppose that a constant may be an int, a float, or a character pointer. The value of a particular constant must be stored in a variable of the proper type, yet it is most convenient for table management if the value occupies the same amount of storage and is stored in the same place regardless of its type. This is the purpose of a union-a single variable that can legitimately hold anyone of several types. The syntax is based on structures:
union u_tag { int ivaI;
float fval;
char *sval;
} u;
The variable u will be large enough to hold the largest of the three types; the specific size is implementation-dependent. Anyone of these types may be assigned to u and then used in expressions, so long as the usage is consistent: the type retrieved must be the type most recently stored. It is the programmer's

 148 STRUCTURES CHAPTER 6
responsibility to keep track of which type is currently stored in a union; the results are implementation-dependent if something is stored as one type and extracted as another.
Syntactically, members of a union are accessed as
union-name. member
or
union-pointer-> member justasforstructures.Ifthevariableutypeisusedtokeeptrackofthecurrent
typestoredinu,thenonemightseecodesuchas
if (utype == INT) printf("%d\n", u.ivaI);
else if (utype == FLOAT) printf(""f\n", u.fval);
else if (utype == STRING) printf(""s\n~, u.sval);
else
printf("bad type "d in utype\n", utype);
Unions may occur within structures and arrays, and vice versa. The notation for accessing a member of a union in a structure (or vice versa) is identical to
that for nested structures.
struct {
char *name;
int flags; int utype; union {
int ivaI; float fval; char *sval;
} u;
} symtab[NSYM];
the member ival is .referredto as symtab[i].u.ival
and the first character of the string sval
*symtab[i].u.sval symtab[i].u.sval[O]
For example, in the structure array defined by
In effect, a union is a structure in which all members have offset zero from the base, the structure is big enough to hold the "widest" member, and the alignment is appropriate for all of the types in the union. The same operations are permitted on unions as on structures: assignment to or copying as a unit, taking the address, and accessing a member. .
A union may only be initialized with a value of the type of its first member;
by either of

 SECTION 6.9 BIT-FIELDS 149
thus the union u described above can only be initialized with an integer value. The storage allocator in Chapter 8 shows how a union can be used to force a
variable to be aligned on a particular kind of storage boundary.
6.9 Bit-fields
When storage space is at a premium, it may be necessary to pack several objects into a single machine word; one common use is a set of single-bit flags in applications like compiler symbol tables. Externally-imposed data formats, such as interfaces to hardware devices, also often require the ability to get at pieces of a word.
Imagine a fragment of a compiler that manipulates a symbol table. Each identifier in a program has certain information associated with it, for example, whether or not it is a keyword, whether or not it is external and/or static, and so on. The most compact way to encode such information is a set of one-bit flags in a single char or into
The usual way this is done is to define a set of "masks" corresponding to the relevant bit positions, as in
#define KEYWORD 01 #define EXTERNAL 02 #define STATIC 04
or
enum { KEYWORD = 01, EXTERNAL = 02, STATIC = 04 };
The numbers must be powers of two. Then accessing the bits becomes a matter of "bit-fiddling" with the shifting, masking, and complementing operators that were described in Chapter 2.
Certain idioms appear frequently:
flags 1= EXTERNAL I STATIC;
turns on the EXTERNAL and STATIC bits in f lags, while
flags &.= -(EXTERNAL 1 STATIC); turns them off, and
if « flags &. (EXTERNAL 1 STATIC» == 0) ...
is true if both bits are off.
Although these idioms are readily mastered, as an alternative C offers the
capability of defining and accessing fields within a word directly rather than by bitwise logical operators. A bit-field, or field for short, is a set of adjacent bits within a single implementation-defined storage unit that we will call a "word." The syntax of field definition and access is based on structures. For example, the symbol table Idefines above could be replaced by the definition of three

 ISO STRUCTURES fields:
struct {
unsigned int is_keyword unsigned int is_extern unsigned int is static
} flags;
This defines a variable called flags
riumber following the colon represents the field width in bits. The fields are declared unsigned int to ensure that they are unsigned quantities.
Individual fields are referenced in the same way as other structure members: flags. is_keyword, flags. is_extern, etc. fields behave like small integers, and may participate in arithmetic expressions just like other integers.
Thus the previous examples may be written more naturally as
flags.is_ext~rn =flags.is_static =1;
to turn the bits on;
flags.is_extern =flags.is_static =0;
to turn them off; and
if (flags.is_extern __ 0 && flags.is_static __ 0)
to test them.
Almost everything about fields is implementation-dependent. Whether a
field may overlap a word boundary is implementation-defined. Fields need not be named; unnamed fields (a colon and width only) are used for padding. The special width 0 may be used to force alignment at the next word boundary.
Fields are assigned left to right on some machines and right to left on others. This means that although fields are useful for maintaining internally-defined data structures, the question of which end comes first has to be carefully con- sidered when picking apart externally-defined data; programs that depend on such things are not portable. .Fields may be declared only as ints; for portabil- ity, specify signed or unsigned explicitly. They are not arrays, and they do not have addresses, so the &. operator cannot be applied to them.
1 ,· 1 ,· 1 ,·
that contains three l-bit fields. The
CHAPTER 6

 CHAPTER 7: Input and Output
Input and output facilities are not part of the C language itself, so we have not emphasized them in our presentation thus far. Nonetheless, programs interact with their environment in much more complicated ways than those we have shown before. In this chapter we will describe the standard library, a set of functions that provide input and output, string handling, storage manage- ment, mathematical routines, and a variety of other services for C programs. We will concentrate on input and output.
The ANSI standard defines these library functions precisely, so that they can exist in compatible form on any system where C exists. Programs that confine their system interactions to facilities provided by the standard library can be moved from one system to another without change.
The properties of library functions are specified in more than a dozen headers; we have already seen several of these, including <stdio .h>, <string. h>, and <ctype. h>. We will not present the entire library here,
since we are more interested in writing C programs that use it. The library is described in detail in Appendix B.
7.1 Standard Input and Output
As we said in Chapter 1, the library implements a simple model of text input and output. A text stream consists of a sequence of lines; each line ends with a newline character. If the system doesn't operate that way, the library does whatever is necessary to make it appear as if it does. For instance, the library might convert carriage return and linefeed to newline on input and back again on output.
The simplest input mechanism is to read one character at a time from the standard input, normally the keyboard, with getchar:
int getchar(void)
getchar returnsthenextinputcharactereachtimeitiscalled,orEOFwhenit encounters end of file. The symbolicconstant EOFis defined in <stdio. h>.
151

 152 INPUT AND OUTPUT CHAPTER 7
Thevalueistypically-1,buttestsshouldbewrittenintermsofEOFsoastobe independent of the specific value.
In many environments, a file may be substituted for the keyboard by using the < convention for input redirection: if a program prog uses getchar, then the command line
prog <infile
causes prog to read characters from infile instead. The switching of the inputisdoneinsuchawaythatprogitselfisoblivioustothechange;inpartic- ular, the string" <infile" is not included in the command-line arguments in argv. Inputswitchingisalsoinvisibleiftheinputcomesfromanotherprogram via a pipe mechanism: on some systems, the command line
otherprog I prog
runs the two programs otherprog and prog, and pipes the standard output of otherprog into the standard input for prog.
The function
int putchar(int)
is used for output: putchar (c) puts the character c on the standard output, whichisbydefaultthescreen.putcharreturnsthecharacterwritten,orEOF if an error occurs. Again, output can usually be directed to a file with »filename: if prog uses putchar,
prog >outfile
willwritethestandardoutputtooutfile instead. Ifpipesaresupported, prog I anotherprog
puts the standard output of prog into the standard input of anotherprog. Output produced by printf also finds its way to the standard output. Calls to putchar and printf may be interleaved-output appears in the
order in which the calls were made.
Each source file that refers to an input/output library function must contain
the line
#include <stdio.h>
before the first reference. When the name is bracketed by < and > a search is made for the header in a standard set of places (for example, on UNIX systems, typically in the directory /usr/include).
Many programs read only one input stream and write only one output stream; for such programs, input and output with getchar, putchar, and printf may be entirely adequate, and is certainly enough to get started. This is particularly true if redirection is used to connect the output of one program to the input of the next. For example, consider the program lower, which con- verts its input to lower case:

 SECTION 7.2 FORMATTED OUTPUT-PRINTF 153
#include <stdio.h> #include <ctype.h>
main() 1*lower:convertinputtolowercase*1 {
int c;
while «c = getchar(» 1= EOF) putchar(tolower(c»;
return 0;
}
The function tolower is defined in <ctype. h»; it converts an upper case letter to lower case, and returns other characters untouched. As we mentioned earlier, "functions" like getchar and putchar in <stdio. h> and tolower in<ctype.h>areoftenmacros,thusavoidingtheoverheadofafunctioncall percharacter. WewillshowhowthisisdoneinSection8.5. Regardlessofhow the<ctype.h>functionsareimplementedonagivenmachine,programsthat use them are shielded from knowledgeof the character set.
Exercise 7-1. Write a program that converts upper case to lower or lower case toupper,dependingonthenameitisinvokedwith,asfoundinargv[0]. 0
7.2 Formatted Output- Printf
The output function printf translates internal values to characters. We haveusedprintf informallyinpreviouschapters. Thedescriptionherecovers most typical uses but is not complete; for the full story, see Appendix B.
int printf(char *format, arg c , arg2, ... )
printf converts, formats, and prints its arguments on the standard output undercontroloftheformat. Itreturnsthenumberofcharactersprinted.
The format string contains two types of objects: ordinary characters, which are copied to the output stream, and conversion specifications, each of which causes conversion and printing of the next successive argument to printf. Each conversion specification begins with a " and ends with a conversion char- acter. Between the" and the conversion character there may be, in order:
• A minus sign, which specifies left adjustment of the converted argument.
• A number that specifies the minimum field width. The converted argument will be printed in a field at least this wide. If necessary it will be padded on the left (or right, if left adjustment is called for) to make up the field width.
• A period, which separates the field width from the precision.
• A number, the precision, that specifies the maximum number of characters to be printed from a string, or the number of digits after the decimal point of a floating- point value, or the minimum number of digits for an integer.

 154 INPUT AND OUTPUT CHAPTER 7 • An h if the integer is to be printed as a short,or I (letter ell) if as a long.
ConversioncharactersareshowninTable7-1.Ifthecharacterafterthe" is not a conversion specification, the behavior is undefined.
CHARACTER
d,i o x, X
u
c
s
f
TABLE 7-1. BASIC PRINTF CONVERSIONS ARGUMENT TYPE; PRINTED AS
int;decimal number.
int;unsigned octal number (without a leading zero). int;unsigned hexadecimal number (without a leading Ox or
OX),using abcdef or ABCDEF for 10, ..., 15. int;unsigned decimal number.
int;single character.
char *;print characters from the string until a ' \0' or the number of characters given by the precision.
double;[-1m.dddddd,where the number of d's is given by the precision (default 6).
e,E double;[-1m.dddddde±xx or [-1m.ddddddE±XX, where the number of d's is given by the precision (default 6).
g,G double;use%eor%Eiftheexponentislessthan-4orgreater than or equal to the precision; otherwise use %f. Trailing zeros and a trailing decimal point are not printed.
p void *;pointer (implementation-dependent representation). % no argument is converted; print a %.
A width or precision may be specified as *, in which case the value is com- putedbyconvertingthenextargument(whichmustbeanint). Forexample, to print at most max characters from a string s,
printf("%.*s", max, sl ;
Most of the format conversions have been illustrated in earlier chapters. Oneexceptionisprecisionasitrelatestostrings. Thefollowingtableshowsthe effect of a variety of specifications in printing "hello, world" (12 characters). We have put colons around each field so you can see its extent.
:%s: :%10s: :%.10s: :%-10s: :%.15s: :%-158: :%15.10s: :%-15.108:
:hello, world: :hello, world: :hello, wor: :hello,world: :hello, world: :hello,world
hello, wor: :hello, wor
Awarning:printf usesitsfirstargumenttodecidehowmanyarguments

 SECTION 7.3 VARIABLE-LENGTH ARGUMENT LISTS ISS
followandwhattheirtypesare.Itwillgetconfused,andyouwillgetwrong answers, if there are not enough arguments or if they are the wrong type. You should also be aware of the difference between these two calls:
printf(s); 1*FAILSifscontains%*1 printf("%s", s); 1* SAFE *1
The function sprintf does the same conversionsas printf stores the output in a string:
int sprintf(char *string, char *format, arg i , arg2,
does, but
... )
sprintf formatstheargumentsinargbarg2,etc.,accordingtoformatas before, but places the result in string instead of on the standard output; string mustbebigenoughtoreceivetheresult.
Exercise 7-2. Write a program that will print arbitrary input in a sensible way. As a minimum, it should print non-graphic characters in octal or hexadecimal according to local custom, and break long text lines. 0
7.3 Variable-length Argument Lists
Thissectioncontainsanimplementationofaminimalversionofprintf, to show how to write a function that processes a variable-length argument list in a portable way. Since we are mainly interested in the argument processing, minprintf willprocesstheformatstringandarguments'butwillcallthereal printf todotheformatconversions.
Theproperdeclarationforprintf is
int printf(char *fmt, ...)
where the declaration •.. means that the number and types of these arguments may vary. The declaration •.. can only appear at the end of an argument list. Ourminprintf isdeclaredas
void minprintf(char *fmt, ...)
sincewewillnotreturnthecharactercountthatprintf does. Thetrickybitishowminprintf walksalongtheargumentlistwhenthe list doesn't even have a name. The standard header <stdarg. h> contains a set of macro definitions that define how to step through an argument list. The implementation of this header will vary from machine to machine, but the inter-
face it presents is uniform.
Thetypeva_list isusedtodeclareavariablethatwillrefertoeachargu-
mentinturn;inminprintf, thisvariableiscalledap,for"argumentpointer." The macro va_start initializes ap to point to the first unnamed argument. It mustbecalledoncebeforeapisused.Theremustbeatleastonenamedargu- ment;thefinalnamedargumentisusedbyva_start togetstarted.

 IS6 INPUT AND OUTPUT CHAPTER 7
Each call of va_arq returns one argument and steps ap to the next; va_arq uses a type name to determine what type to return and how big a step to take. Finally, va_end does whatever cleanup is necessary. It must be called before the function returns.
Thesepropertiesformthebasisofoursimplifiedprintf:
#include <stdarg.h>
1* minprintf: minimal printf with variable argument list*1 void minprintf(char *fmt, ...)
{
va_list ap; 1* points to each unnamed arg in turn*1 char *p, *sval;
int ivaI;
double dval;
va_start(ap, fmt); 1* make ap point to 1st unnamed arg *1 for (p =fmt; *p; p++) {
if (*p 1= ',,') { putchar (*p);
continue;
}
switch (u+p) { case 'd':
ivaI =va_arg(ap, int); printf(""d", ivaI); break;
case 'f':
dval =va_arg(ap, double); printf(""f", dval);
,break; case's' :
for (sval =va_arg(ap, char *); *sval; sval++) putchar(*sval);
break; default:
} }
putchar( *p) ;
brea~;
va_end(ap); 1*cleanupwhendone*1 }
Exercise7-3. Revise minprintf to handle more of the other facilities of printf. 0

 SECTION 7.4 FORMATTED INPUT -SCANF 157
7.4 FormattedInput-Scant
The function scanf is the input analog of printf, providing many of the same conversion facilities in the opposite direction.
int scanf(char *£ormat, ... )
scanf reads characters from the standard input, interprets them according to thespecificationinformat,andstorestheresultsthroughtheremainingargu- ments. The format argument is described below; the other arguments, each of which must be a pointer, indicate where the' corresponding converted input shouldbestored. Aswithprintf, thissectionisasummaryofthemostuseful features, not an exhaustive list.
scanfstopswhenitexhaustsitsformat'string,orwhensomeinputfailsto match the control specification. It returns as its value the number of success- fully matched and assigned input items. This can be used to decide how many items were found. On end of file, EOF is returned; note that this is different from 0, which means that the next input character does not match the first specification in the format string. The 'next call to scanf resumes searching immediately after the last character already converted.
There is also a function sscanf that reads from a string instead of the standard input:
int sscanf(char *strinq, char *£ormat, arg), arg2, ...)
Itscansthestring accordingtotheformatinformat,andstorestheresult- ing values through arg., arg2, etc. These arguments must be pointers.
The format string usually contains conversion specifications, which are used to control conversionof input. The format string may contain:
• Blanks or tabs, which are ignored.
• Ordinary characters (not ,,), which are expected to match the next non-white space character of the input stream.
• Conversion specifications, consisting of the character '" an optional assignment suppression character *, an optional number specifying a maximum field width, an optional h, 1, or L indicating the width of the target, and a conversioncharacter.
A conversion specification directs the conversion of the next input field. Nor- mally the result is placed in the variable pointed to by the corresponding argu- ment.Ifassignmentsuppressionisindicatedbythe*character,however,the input field is skipped; no assignment is made. An input field is defined as a string of non-white space characters; it extends either to the next white space character or until the field width, if specified, is exhausted. This implies that scanf will read across line boundaries to find its input, since newlines are white space. (White space characters are blank, tab, newline, carriage return, vertical tab, and formfeed.)
The conversioncharacter indicates the interpretation of the input field. The corresponding argument must be a pointer, as required by the call-by-value

 158 INPUT AND OUTPUT CHAPTER 7
semantics of C.
CHARACTER
d i
o
u x c
s
e, f, q
"
Theconversioncharactersd,i,0,u,andxmaybeprecededbyhtoindi- cate that a pointer to short rather than int appears in the argument list, or by1(letterell)toindicatethatapointertolongappearsintheargumentlist. Similarly, the conversioncharacters e, f, and g may be preceded by 1 to indi- cate that a pointer to double rather than float is in the argument list.
As a first example, the rudimentary calculator of Chapter 4 can be written withscanf todotheinputconversion:
#include <stdio.h>
maine) 1* rudimentary calculator *1 {
double sum, V;
sum = 0; while(scanf("%lf",&'v)==1)
printf("\t%.2f\n", sum += v); return 0;
}
Suppose we want to read input lines that contain dates of the form
25 Dec 1988
The scanf statement is
Conversion characters are shown in Table 7-2. TABLE 7-2. BASIC SCANF CONVERSIONS
INPUT DATA; ARGUMENT TYPE
decimal integer; int *.
integer; int *. The integer may be in octal (leading 0) or hexadecimal (leading Ox or OX).
octal integer (with or without leading zero); int *.
unsigned decimal integer; unsigned int *.
hexadecimal integer (with or without leading Ox or OX);int *. characters; char *. The next input characters (default 1) are placed at the indicated spot. The normal skip over white space is suppressed; to read the next non-white space character, use "1s.
character string (not quoted); char *, pointing to an array of characters large enough for the string and a terminating , \0' that will be added.
floating-point number with optional sign, optional decimal point and optional exponent; float *.
literal %; no assignment is made.

 SECTION 7.4 FORMATTED INPUT -SCANF 159
int day, year; char monthname[20];
seanf(""d "S%d", &day, monthname, &year);
No &. is used with monthnames,ince an array name is a pointer.
Literal characters can appear in the scanf format string; they must match the same characters in the input. So we could read dates of the form
mmldd/yywiththisscanfstatement: int day, month, year;
seanf("%d/%d/%d", &month, &day, &year);
scanf ignores blanks and tabs in its format string. Furthermore, it skips over white space (blanks, tabs, newlines, etc.) as it looks for input values. To read input whose format is not fixed, it is often best to read a line at a time, then pick it apart with sscanf. For example, suppose we want to read lines that might contain a date in either of the forms above. Then we could write
while (getline(line, sizeof(line» > 0) {
if (sseanf(line, "%d "S"d", &day, monthname, &year) == 3)
printf("valid:"s\n",line); 1*25Dec1988form*1 else if (sseanf(line, ""d/"d/"d", &month, &day, &year) == 3)
printf("valid:"s\n",line); 1*mm/dd/yyform*1 else
printf("invalid: "s\n", line); 1* invalid form *1
}
Calls to scanf can be mixed with calls to other input functions. The next call to any input function will begin by reading the first character not read by
scanf.
A final warning: the arguments to scanf and sscanf must be pointers.
By far the most common error is writing
seanf(""d", n);
instead of
seanf("%d", &n);
This error is not generally detected at compile time.
Exercise7-4. Writeaprivateversionofscanf analogoustominprintf from the previoussection. 0
Exercise 7-5. Rewrite the postfix calculator of Chapter 4 to use scanf and/or sscanf to do the input and number conversion. 0

 160 INPUT AND OUTPUT CHAPTER 7
7.5 File Access
The examples so far have all read the standard input and written the stand- ard output, which are automatically defined for a program by the local operat- ing system.
The next step is to write a program that accesses a file that is not already connected to the program. One program that illustrates the need for such operations is cat, which concatenates a set of named files onto the standard output. catisusedforprintingfilesonthescreen,andasageneral-purpose input collector for programs that do not have the capability of accessing files by name. For example, the command
cat x.c y.c
printsthecontentsofthefilesx.candy.c(andnothingelse)onthestandard output.
The question is how to arrange for the named files to be read-that is, how to connect the external names that a user thinks of to the statements that read the data.
The rules are simple. Before it can be read or written, a file has to be opened by the library function fopen. fopen takes an external name like x. c ory.c,doessomehousekeepingandnegotiationwiththeoperatingsystem
(details of which needn't concern us), and returns a pointer to be used in subse- quent reads or writes of the file.
This pointer, called the file pointer, points to a structure that contains infor- mation about the file, such as the location of a buffer, the current character position in the buffer, whether the file is being read or written, and whether errors or end of file have occurred. Users don't need to know the details, because the definitions obtained from <stdio. h> include a structure declara- tion called FILE. The only declaration needed for a file pointer is exemplified by
FILE *fp;
FILE *fopen(char *name, char *mode);
This says that fp is a pointer to a FILE, and fopen returns a pointer to a FILE. Notice that FILE is a type name, like int, not a structure tag; it is defined with a typedef. (Details of how fopen can be implemented on the UNIX system are given in Section 8.5.)
The call to f open in a program is
fp =fopen(name, mode);
The first argument of fopen is a character string containing the name of the file. The second argument is the mode, also a character string, which indicates howoneintendstousethefile.Allowablemodesincluderead("r,,),write ("w"), and append (" a "). Some systems distinguish between text and binary files;forthelatter,a"b"mustbeappendedtothemodestring.

 SECTION 7.5 FILE ACCESS 161
If a file that does not exist is opened for writing or appending, it is created if possible. Opening an existing file for writing causes the old contents to be dis- carded, while opening for appending preserves them. Trying to read a file that does not exist is an error, and there may be other causes of error as well, like trying to read a file when you don't have permission. If there is any error, fopen will return NULL.(The error can be identified more precisely; see the discussion of error-handling functions at the end of Section 1 in Appendix B.)
The next thing needed is a way to read or write the file once it is open. There are several possibilities, of which getc and putc are the simplest. getc returns the next character from a file; it needs the file pointer to tell it which file.
int getc(FILE *fp)
getc returns the next character from the stream referred to by fp; it returns EOFforendoffileorerror.
putc is an output function:
int putc(int c, FILE *fp)
putc writes the character c to the file fp and returns the character written, or EOFif an error occurs. Like getchar and putchar, getc and putc may be macros instead of functions.
When a C program is started, the operating system environment is responsi- ble for opening three files and providing file pointers for them. These files are the standard input, the standard output, and the standard error; the correspond- ing file pointers are called stdin, stdout, and stderr, and are declared in
<stdio. h>. Normally stdin is connected to the keyboard and stdout and stderr are connected to the screen, but stdin and stdout may be redirected to files or pipes as described in Section 7.1.
getchar and putchar can be defined in terms of getc, putc, stdin, and stdout as follows:
#define getchar() getc(stdin) #define putchar(c) putc«c), stdout)
For formatted input or output of files, the functions fscanf and fprintf may be used. These are identical to scanf and printf, except that the first argument is a file pointer that specifies the file to be read or written; the format string is the second argument.
int fscanf(FILE *fp, char *format, ) int fprintf(FILE *fp, char *format, )
With these preliminaries out of the way, we are now in a position to write the program cat to concatenate files. The design is one that has been found convenient for many programs. If there are command-line arguments, they are interpreted as filenames, and processed in order. If there are no arguments, the standard input is processed.

 162 INPUT AND OUTPUT
CHAPTER 7
#include <stdio.h>
1* cat: concatenate files, version 1*1 main(int argc, char *argv[])
{
FILE *fp;
void filecopy(FILE *, FILE *);
if (argc == 1) 1* no args; copy standard input *1 filecopy(stdin, stdout);
else
while (--argc > 0)
if « fp = fopen(*++argv, "r") == NULL) { printf("cat: can't open "s\n", *argv); return 1;
} else {
filecopy(fp, stdout); fclose (fp);
}
return 0;
}
1*filecopy: copyfileifptofileofp*1 void filecopy(FILE *ifp, FILE *ofp)
{
}
The file pointers stdin and stdout are objects of type FILE *. They are constants, however, not variables, so it is not possible to assign to them.
The function
int fclose(FILE *fp)
istheinverseoffopen;itbreakstheconnectionbetweenthefilepointerand the external name that was established by fopen, freeing the file pointer for another file. Since most operating systems have some limit on the number of files that a program may have open simultaneously, it's a good idea to free file pointers when they are no longer needed, as we did in cat. There is also another reason for fclose on an output file-it flushes the buffer in which putc is collecting output. fclose is called automatically for each open file when a program terminates normally. (You can close stdin and stdout if they are not needed. They can also be reassigned by the library function freopen.)
int c;
while «c = getc(ifp» 1= EOF) putc(c, ofp);

 SECTION 7.6 ERROR HANDLING-STDERR AND EXIT 163
7.6 Error Handllng-Stderr and Exit
Thetreatmentoferrorsincatisnotideal.Thetroubleisthatifoneofthe files can't be accessed for some reason, the diagnostic is printed at the end of the concatenated output. That might be acceptable if the output is going to a screen, but not if it's going into a file or into another program via a pipeline.
Tohandlethissituationbetter,asecondoutputstream,calledstderr,is assigned to a program in the same way that stdin and stdout arc. Output writtenonstderrnormallyappearsonthescreenevenifthestandardoutput is redirected.
Letusrevisecattowriteitserrormessagesonthestandarderror.
#include <stdio.h>
1*cat: concatenatefiles,version2*1 main(int argc, char *argv[)
{
FILE *fp;
void filecopy(FILE *, FILE *);
char *prog =argv[O); 1* progr~m name for errors *1
if (argc == 1) 1* no args; copy standard input *1 filecopy(stdin, stdout);
else
while (--argc > 0)
if«fp =fopen(*++argv,"r"})==NULL){ fprintf(stderr, "%s: can't open %s\n",
prog, *argv); exit(1);
} else {
filecopy(fp, stdout); fclose(fp);
}
if (ferror(stdout» {
fprintf(stderr, "%s: error writing stdout\n", prog); exit(2);
}
exit(O);
}
The program signals errors two ways. First, the diagnostic output produced by fprintf goes onto stderr, so it finds its way to the screen instead of disappearing down a pipeline or into an output file. We included the program name,fromarqv[0],inthemessage,soifthisprogramisusedwithothers, the source of an error is identified. '
Second, the program uses the standard library function exit, which ter- minatesprogramexecutionwhenitiscalled.Theargumentofexitisavail- able to whatever process called this one, so the success or failure of the program can be tested by another program that uses this one as a sub-process.

 164 INPUT AND OUTPUT CHAPTER 7
Conventionally, a return value of 0 signals that all is well; non-zero values usu- ally signal abnormal situations. exit calls fclose for each open output file, to flush out any buffered output.
Withinmain,returnexprisequivalenttoexit(expr).exithasthe advantage that it can be called from other functions, and that calls to it can be found with a pattern-searching program like those in Chapter 5.
The function ferror returns non-zero if an error occurred on the stream fp.
int ferror(FILE *fp)
Although output errors are rare, they do occur (for example, if a disk fills up), so a production program should check this as well.
The function f eof (FILE *) is analogous to f error; it returns non-zero if end of file has occurred on the specified file.
int feof(FILE *fp)
We have generally not worried about exit status in our small illustrative pro- grams, but any serious program should take care to return sensible, useful status values.
7.7 Line Input and Output
Thestandardlibraryprovidesaninputroutinefgets thatissimilartothe getline function that we have used in earlier chapters:
char *fgets(char *line, int maxline, FILE *fp)
fqets reads the next input line (including the newline) from file fp into the characterarrayline;atmostmaxline-1characterswillberead.Theresult- ing line is terminated with '\0'. Normally fgets returns line; on end of file or error it returns NULL.(Our getline returns the line length, which is a more useful value; zero means end of file.)
For output, the function fputs writes a string (which need not contain a newline) to a file:
int fputs(char *line, FILE *fp)
ItreturnsEOFifanerroroccurs,andzerootherwise.
The library functions gets and puts are similar to fgets and fputs, but
operate on stdin and stdout. Confusingly, gets deletes the terminal ' \n' , and puts adds it.
To show that there is nothing special about functions like fgets and fputs, heretheyare,copiedfromthestandardlibraryonoursystem:

 SECTION 7.7 LINE INPUT AND OUTPUT 165
1* fgets: get at most n chars from iop*1 char *fgets(char *s, int n, FILE *iop)
{
register int c; register char *cs;
cs = s;
while (--n > 0 && (c = getc(iop» 1=EOF)
if «*cs++ = c) == '\n') break;
*cs = '\0';
return(c==EOF&&cs--s)?NULL s; }
1* fputs: put string s on file iop *1 int fputs(char *s, FILE dop)
{
int c;
while (c =*s++) putc(c, iop);
return ferror(iop) ? EOF 0; }
Thestandardspecifiesthatferrorreturnsnon-zeroforerror;fputsreturns EOF for error and a non-negative value otherwise.
Itiseasytoimplementourgetline fromfgets:
1*getline: readaline,returnlength*1 int getline(char *li~e, int max)
{
if (fgets(line, max, stdin) == NULL) return 0;
else
return strlen(line);
}
Exercise 7-6. Write a program to compare two files, printing the first line where they differ. 0
Exercise 7-7. Modify the pattern finding program of Chapter 5 to take its input from a set of named files or, if no files are named as arguments, from the stand- ard input. Should the file name be printed when a matching line is found? 0
Exercise 7-8. Write a program to print a set of files, starting each new one on a new page, with a title and a running page count for each file. 0

 166 INPUT AND OUTPUT CHAPTER 7
7.8 Miscellaneous Functions
The standard library provides a wide variety of functions. This section is a brief synopsis of the most useful. More details and marty other functions can be found in Appendix B.
7.8.1 String Operations
We have already mentioned the string functions strlen, strcpy, strcat, and strcmp, found in <string. h>. In the following, sand t are char *'s, and c and n are ints.
strcat(s,t) strncat(s,t,n) strcmp(s,t)
strncmp(s,t,n) strcpy(s,t) strncpy(s,t,n) strlen(s) st.bhr(s,c) strrchr(s,c)
concatenate t to end of s
concatenate n characters of t to end of s return negative, zero, or positive for
s < t,s =::= t,or s > t
same as strcmp but only in first n characters copyttos
copy at most n characters of t to s
return length of s
return pointer to first c in s, or NULL if not present return pointer to last c in s, or NULL if not present
7.8.2 Character Class Testing and Conversion
Several functions from <ctype. h> perform character tests and conversions. In the following, c is an int that can be represented as an unsigned char, or EOF. The functions return into
isalpha(c) non-zero if c is alphabetic, 0 if not
isupper(c) non-zero if c is upper case, 0 if not
islower(c) non-zero if c is lower case, 0 if not
isdigit(c) non-zero if c is digit, 0 if not
isalnum(c) non-zero if isalpha(c)or isdigit(c),0if not isspace(c) non-zero if c is blank, tab, newline, return, formfeed, vertical tab toupper(c) return c converted to upper case
tolower(c) return c converted to lower case
7.8.3 Ungetc
The standard library provides a rather restricted version of the function ungetch that we wrote in Chapter 4; it is called ungetc.
int ungetc(int c, FILE *fp)
pushes the character c back onto file fp, and returns either c, or EOF for an error. Only one character of pushback is guaranteed per file. ungetc may be used with any of the input functions like scanf, getc, or getchar.

 SECTION 7.8 MISCELLANEOUS FUNCTIONS 167
7.8.4 Command Execution
The function system( char *s) executes the command contained in the character string s, then resumes execution of the current program. The con- tents of s depend strongly on the local operating system. As a trivial example, on UNIX systems, the statement
system("date");
causes the program date to be run; it prints the date and time of day on the standard output. system returns a system-dependent integer status from the command executed. In the UNIX system, the status return is the value returned by exit.
7.8.5 Storage Management
Thefunctionsmalloc andcalloc obtainblocksofmemorydynamically.
void *malloc(size_t n)
returns a pointer to n bytes of uninitialized storage, or NULL if the request can- not be satisfied.
void *calloc(size_t n, size_t size)
returns a pointer to enough space for an array of n objects of the specified size, or NULL if the request cannot be satisfied. The storage is initialized to zero.
The pointer returned by malloc or cel.Loc has the proper alignment for the object in question, but it must be cast into the appropriate type, as in
int dp;
ip = (int *) calloc(n, sizeof(int»;
free ( p) frees the space pointed to by p, where p was originally obtained by a call to malloc or calloc. There are no restrictions on the order in which space is freed, but it is a ghastly error to free something not obtained by callingcalloc ormalloc.
It is also an error to use something after it has been freed. A typical but incorrect piece of code is this loop that frees items from a list:
for(p=head;p1=NULL;P=p->next) 1*WRONG*1 free(p);
The right way is to save whatever is needed before freeing:
for (p = head; p 1= NULL; P = q) { q =p->next;
free(p);
}
Section 8.7 shows the implementation of a storage allocator like meLLoc.Tn

 168 INPUT AND OUTPUT CHAPTER 7
which allocated blocks may be freed in any order.
7.S.6 Mathematical Functions
There are more than twenty mathematical functions declared in <math. h»; here are some of the more frequently used. Each takes one or two double arguments and returns a double.
7 .S. 7
Random
square root of x (x ~O) absolute value of x
Number Generation
sin(x)
cos (x) atan2(y,x) exp(x) log(x) log10(x) pow(x,y) xy sqrt(x) fabs(x)
sine of x, x in radians
cosine of x, x in radians
arctangent of y Ix, in radians
exponential function e"
natural (base e) logarithm of x (x> 0) common (base 10) logarithm of x (x> 0)
The function rand ( ) computes a sequence of pseudo-random integers in the range zero to RAND_MAwXh,ich is defined in <stdlib.h>. One way to pro- duce random floating-point numbers greater than or equal to zero but less than one is
#define frand() «double) rand() / (RAND_MAX+1.0»
(If your library already provides a function for floating-point random numbers, it is likely to have better statistical properties than this one.)
The function srand (unsigned) implementation of rand and srand tion 2.7.
sets the seed for rand. The portable suggested by the standard appears in Sec-
Exercise 7-9. Functions like isupper save time. Explore both possibilities. 0
can be implemented to save space or to

 CHAPTER 8: The UNIX System Interface
The UNIX operating system provides its services through a set of system calls, which are in effect functions within the operating system that may be called by user programs. This chapter describes how to use some of the most important system calls from C programs. If you use UNIX, this should be directly helpful, for it is sometimes necessary to employ system calls for max- imum efficiency, or to access some facility that is not in the library. Even if you use C on a different operating system, however,you should be able to glean insight into C programming from studying these examples; although details vary, similar code will be found on any system. Since the ANSI C library is in many cases modeled on UNIX facilities, this code may help your understanding of the library as well.
The chapter is divided into three major parts: input/output, file system, and storage allocation. The first two parts assume a modest familiarity with the external characteristics of UNIX systems.
Chapter 7 was concerned with an input/output interface that is uniform across operating systems. On any particular system the routines of the standard library have to be written in terms of the facilities provided by the host system. In the next few sections we will describe the UNIX system calls for input and output, and show how parts of the standard library can be implemented with them.
8.1 File Descriptors
In the UNIX operating system, all input and output is done by reading or writing files, because all peripheral devices, even keyboard and screen, are files in the file system. This means that a single homogeneous interface handles all communication between a program and peripheral devices.
In the most general case, before you read or write a file, you must inform the system of your intent to do so, a process called opening the file. If you are going to write on a file it may also be necessary to create it or to discard its pre- vious contents. The system checks your right to do so (Does the file exist? Do
169

 170 THE UNIX SYSTEM INTERFACE CHAPTER 8
you have permission to access it?), and if all is well, returns to the program a small non-negative integer called a file descriptor. Whenever input or output is to be done on the file, the file descriptor is used instead of the name to identify the file. (A file descriptor is analogous to the file pointer used by the standard library, or to the file handle of MS-DOS.) All information about an open file is maintained by the system; the user program refers to the file only by the file descriptor.
Since input and output involving keyboard and screen is so common, special arrangements exist to make this convenient. When the command interpreter (the "shell") runs a program, three files are open, with file descriptors 0, 1, and 2, called the standard input, the standard output, and the standard error. If a
program reads 0 and writes 1 and 2, it can do input and output without worry- ing about opening files.
The user of a program can redirect 1/0 to and from files with < and >: proq <infile >outfile
In this case, the shell changes the default assignments for file descriptors 0 and 1 to the named files. Normally file descriptor 2 remains attached to the screen, so error messages can go there. Similar observations hold for input or output
associated with a pipe. In all cases, the file assignments are changed by the shell, not by the program. The program does not know where its input comes from nor where its output goes, so long as it uses file 0 for input and 1 and 2 for output.
8.2 Low Levell/O-Read andWrite
Inputandoutputusesthereadandwritesystemcalls,whichareaccessed fromCprogramsthroughtwofunctionscalledreadandwrite. Forboth,the first argument is a file descriptor. The second argument is a character array in your program where the data is to go to or come from. The third argument is the number of bytes to be transferred.
int n_read =read(int fd, char *buf, int n); int n_written =write(int fd, char *buf, int n);
Each call returns a count of the number of bytes transferred. On reading, the number of bytes returned may be less than the number requested. A return valueofzerobytesimpliesendoffile,and-1indicatesanerrorofsomesort. For writing, the return value is the number of bytes written; an error has occurred if this isn't equal to the number requested.
Any number of bytes can be read or written in one call. The most common values are 1, which means one character at a time ("unbuffered"), and a numberlike1024or4096thatcorrespondstoaphysicalblocksizeonaperi- pheral device. Larger sizes will be more efficient because fewer system calls

 SECTION 8.2 LOW LEVEL I/O-READ AND WRITE 171
will be made.
Putting these facts together, we can write a simple program to copy its input
to its output, the equivalent of the file copying program written for Chapter 1. This program will copy anything to anything, since the input and output can be redirected to any file or device.
#include "syscalls.h"
maine) 1* copy input to output *1 {
char buf[BUFSIZ]; int n;
while «n = read(O, buf, BUFSIZ» > 0) write(1, buf, n);
return 0;
}
We have collected function prototypes for the system calls into a file called syscalls. h so we can include it in the programs of this chapter. This name is not standard, however.
The parameter BUFSIZis also defined in syscalls. h; its value is a good size for the local system. If the file size is not a multiple of BUFSIZ,some read willreturnasmallernumberofbytestobewrittenbywrite; thenext call to read after that will return zero.
It is instructive to see how read and write can be used to construct higher-level routines like getchar, putchar, etc. For example, here is a ver- sion of getchar that does unbuffered input, by reading the standard input one character at a time.
#include "syscalls.h"
1* getchar: unbuffered single character input*1 int getchar(void)
{
char c;
return (read(O, &c, 1) -- 1)? (unsigned char) c EOF;
}
c must be a char, because read needs a character pointer. Casting c to uns igned char in the return statement eliminates any problem of sign exten- sion.
Thesecondversionofgetchar doesinputinbigchunks,andhandsoutthe characters one at a time.

 172 THE UNIX SYSTEM INTERFACE
CHAPTER 8
#include nsyscalls.h"
1*getchar:simplebufferedversion*1 int getchar(void)
{
static char buf[BUFSIZ]; static char *bufp = buf; static int n = 0;
if(n==0){ 1* bufferisempty*1 n = read(O, buf, sizeof buf); bufp = buf;
}
return (--n >= 0) ? (unsigned char) *bufp++ : EOF;
}
If these versionsof getchar were to be compiledwith <stdio .h> included, it would be necessary to #Undef the name getchar in case it is implemented as a macro.
8.3 Open, Creat, Close, Unlink.
Other than the default standard input, output and error, you must explicitly open files in order to read or write them. There are two system calls for this, open and crea t [sic].
open is rather like the fopen discussedin Chapter 7, except that instead of returning a file pointer, it returns a file descriptor, which is just an into open returns - 1 if any error occurs.
#include <fcntl.h>
int fd;
int open(char *name, int flags, int perms);
fd • open(name, flags, perms);
As with fopen, the name argument is a character string containing the filename. The second argument, flags, is an int that specifies how the file is to be opened; the main values are
O_RDONLY O_WRONLY O_RDWR
open for reading only
open for writing only
open for both reading and writing
These constants are defined in <fcnt1.h> on System V UNIXsystems,and in <sys/file. h> on Berkeley (BSO)versions.
To open an existing file for reading,
fd = open(name, O_RDONLY, 0);

 SECTION 8.3 OPEN, CREAT, CLOSE, UNLINK 173
The permsargument isalwayszerofortheusesofopenthat wewilldiscuss. It is an error to try to open a file that does not exist. The system call
ereat isprovidedtocreatenewfiles,ortore-writeoldones.
int creat(char *name, int perms); fd =creat(name, perms);
returnsafiledescriptorifitwasabletocreatethefile,and-1ifnot.Ifthe file already exists, ere at will truncate it to zero length, thereby discarding its previouscontents; it is not an error to erea t a file that already exists.
If the file does not already exist, ereat creates it with the permissions specified by the perms argument. In the UNIX file system, there are nine bits of permission information associated with a file that control read, write and exe- cute access for the owner of the file, for the owner's group, and for all others. Thus a three-digit octal number is convenient for specifying the permissions. For example, 0755 specifies read, write and execute permission for the owner, and read and execute permission for the group and everyone else.
To illustrate, here is a simplified version of the UNIX program cp, which copies one file to. another. Our version copies only one file, it does not permit the second argument to be a directory, and it invents permissions instead of copying them.
#include <stdio.h>
#include <fcntl.h>
#include "syscalls.h"
#definePERMS0666 1*RWforowner,group,others*1
void error(char *, ...);
1* cp: copy f1 to f2*1 main(int argc, char *arqv[])
{
int f1, f2, n; char buf[BUFSIZ];
if (argc 1= 3)
error("Usage: cp from to");
if «f1 =open(arqv[1], O_RDONLY, 0» ==-1) error("cp: can't open "s", arqv[1]);
if «f2 =creat(arqv[2], PERMS» ==-1) error("cp: can't create "s, mode "030",
arqv[2], PERMS);
while «n =read(f1, buf, BUFSIZ» > 0)
if (write(f2, buf, n) 1= n)
error("cp: write error on file "s", arqv[2]);
return OJ
}
This program creates the output file with fixed permissionsof 0666. With the

 174 THE UNIX SYSTEM INTERFACE CHAPTER 8
stat system call, described in Section 8.6, we can determine the mode of an existing file and thus give the same mode to the cqpy.
Notice that the function error is called with variable argument lists much like printf. The implementation of error illustrates how to use another member of the printf family. The standard library function vprintf is like printf except that the variable argument list is replaced by a single argument that has been initialized by calling the va_start macro. Similarly, vfprintf and vsprintf match fprintf and sprintf.
#include <stdio.h> #include <stdarg.h>
1* error: printanerrormessageanddie*1 void error(char *fmt, ...)
{
}
There is a limit (often about 20) on the number of files that a program may have open simuitaneously. Accordingly, any program that intends to process many files must be prepared to re-use file descriptors. The function close (int fd) breaks the connection between a file descriptor and an open file, and frees the file descriptor for use with some other file; it corresponds to fclose in the standard library except that there is no buffer to flush. Termi- nationofaprogramviaexitorreturnfromthemainprogramclosesallopen files.
Thefunctionunlink(char*name)removesthefilenamefromthefile system. It corresponds to the standard library function remove.
Exercise 8-1. Rewrite the program cat from Chapter 7 using read, write, open and close instead of their standard library equivalents. Perform experi- ments to determine the relative speeds of the two versions. 0
8.4 RandomAccess-Lseek
Input and output are normally sequential: each read or write takes place at a position in the file right after the previous one. When necessary, however, a file can be read or written in any arbitrary order. The system call lseek provides a way to move around in a file without reading or writing any data:
va_list ~rgs;
va_start(args, fmt); fprintf(stderr, "error: H); vfprintf(stderr, fmt, args); fprintf(stderr, "\n"); va_end(args);
exit(1);

 SECTION 8.S EXAMPLE-AN IMPLEMENTATIONOF FOPEN AND GETC 175 long lseek(int fd, long offset, int origin);
sets the current position in the file whose descriptor is fd to offset, which is taken relative to the location specified by origin. Subsequent reading or writ- ing will begin at that position. origin can be 0, 1, or 2 to specify that offset is to be measured from the beginning, from the current position, or from the end of the file respectively. For example, to append to a file (the redirection >> in the UNIXshell, or IIaII for fopen), seek to the end before writing:
lseek(fd, OL, 2);
To get back to the beginning ("rewind"),
lseek(fd, OL, 0);
Notice the OLargument; it could also be written as (long) 0 or just as 0 if lseek is properly declared.
With lseek, it is possible to treat files more or less like large arrays, at the price of slower access. For example, the following function reads any number of bytes from any arbitrary place in a file. It returns the number read, or -1 on error.
#include "syscalls.h"
1*get:readnbytesfrompositionpos*1 int get(int fd, long pos, char *buf, int n) {
if(lseek(fd,pos,0)>= 0) 1* gettopos*1 return read(fd, buf, n);
else
return -1;
}
The return value from lseek is a long that gives the new position in the file, or -1 if an error occurs. The standard library function fseek is similar to lseek except that the first argument is a FILE * and the return is non-zero if
an error occurred.
8.5 Example-An Implementation ot Fopen and Gete
Let us illustrate how some of these pieces fit together by showing an imple- mentation of the standard library routines fopen and gete.
Recall that files in the standard library are described by file pointers rather than file descriptors. A file pointer is a pointer to a structure that contains several pieces of information about the file: a pointer to a buffer, so the file can be read in large chunks; a count of the number of characters left in the buffer; a pointer to the next character position in the buffer; the file descriptor; and flags describing read/write mode, error status, etc.

 176 THE UNIX SYSTEM INTERFACE CHAPTER 8
Thedatastructurethatdescribesafileiscontainedin<stdio.h>,which mustbeincluded(by#include) inanysourcefilethatusesroutinesfromthe standard input/output library. It is also included by functions in that library. In the followingexcerpt from a typical <stdio. h>, names that are intended for use only by functions of the library begin with an underscore so they are less likely to collide with names in a user's program. This convention is used by all standard library routines.
#define NULL 0
#define EOF (-1)
#define BUFSIZ 1024
#define OPEN_MAX 20 1* max #files open at once *1
typedef struct iobuf {
int cnt; char *ptr; char *base; int flag; int fd;
1* characters left *1
1* next character position *1 1* location of buffer *1
1* mode of file access *1
1* file descriptor *1
} FILE;
extern FILE _iob[OPEN_MAX];
#de'finestdin (&_iob[0]) #define stdout (&_iob[1]) #define stderr (&_iob[2])
{
= 01,
= 010, = 020
};
int _fillbuf(FILE *);
enum _flags
_
1* file open for reading *1
1* file open for writing *1
1* file is unbuffered *1
1* EOF has occurred on this file *1 1* error occurred on this file *1
-
=
_
READ
WRITE
02, = 04,
-UNBUF _
EOF
ERR
int _flushbuf(int, FILE *);
«(p)->flag & _EOF) 1= 0) (((p)->flag & _ERR) 1= 0) ((p)->fd)
#define getc(p)
? (unsigned char) *(p)->ptr++ : _fillbuf(p»
#define putc(x,p) (--(p)->cnt >= 0 \
? *(p)->ptr++ = (x) : _flushbuf«x),p»
#define getchar() getc(stdin) #define putchar(x) putc«x), stdout)
#define feof(p) #define ferror(p) #define fileno(p)
(--(p)->cnt >= 0 \
The getc macro normally decrements the count, advances the pointer, and

 SECTION 8.5 EXAMPLE-AN IMPLEMENTATIONOF FOPEN AND GETC 177
returns the character. (Recall that a long #define is continued with a backslash.) If the count goes negative, however, getc calls the function _fiIlbuf to replenish the buffer, re-initialize the structure contents, and returnacharacter. Thecharactersarereturnedunsigned,whichensuresthat all characters will be positive.
Although we will not discuss any details, we have included the definition of putc to show that it operates in much the same way as getc, calling a func- tion _flushbuf when its buffer is full. We have also included macros for accessing the error and end-of-file status and the file descriptor.
The function fopen can now be written. Most of fopen is concerned with getting the file opened and positioned at the right place, and setting the flag bits toindicatetheproperstate.fopendoesnotallocateanybufferspace;thisis doneby_fillbuf whenthefileisfirstread.
#include <fcntl.h>
#include "syscalls.h"
#definePERMS0666 1*RWforowner,group,others*1
1* fopen: open file, return file ptr*1 FILE *fopen(char *name, char *mode)
{
int fd; FILE *fp;
if (*mode 1= 'r' && *mode 1= 'w' && *mode 1= 'a') return NULL;
for (fp = _iob; fp < _iob + OPEN_MAX; fp++) if «fp->flag & (_READ I _WRITE» == 0) break; 1* found free slot *1
if (fp >= iob + OPEN_MAX) 1* no free slots *1 return NULL;
if (*mode == 'w')
fd = creat(name, PERMS);
else if (*mode == 'a') {
if «fd = open(name, O_WRONLY, 0» -- -1)
fd = creat(name, PERMS); lseek(fd, OL, 2);
} else
fd = open(name, O_RDONLY, 0);
if (fd == -1) 1* COUldn't access name *1 return NULL;
fp->fd = fd;
fp->cnt = 0;
fp->base = NULL;
fp->flaq = (*mode == 'r')? _READ return fp;
_WRITE;
}
Thisversionoffopen doesnothandlealloftheaccessmodepossibilitiesofthe

 178 THE UNIX SYSTEM INTERFACE CHAPTER 8
standard, though adding them would not take much code. In particular, our fopen does not recognize the "b" that signals binary access, since that is meaningless on UNIX systems, nor the "+" that permits both reading and writ- ing.
Thefirstcalltogetc foraparticularfilefindsacountofzero,whichforces a call of _fillbuf. If _fillbuf finds that the file is not open for reading, it returns EOF immediately. Otherwise, it tries to allocate a buffer (if reading is to be buffered).
Once the buffer is established, _fillbuf calls read to fill it, sets the count and pointers, and returns the character at the beginning of the buffer. Subse- quentcallsto_fillbuf willfindabufferallocated.
#include "syscalls.h"
1* fillbuf: allocate and fill input buffer *1 int _fillbuf(FILE *fp)
{
int bufsize;
if «fp->flag&(_READI_EOFI_ERR» 1= _READ) return EOF;
bufsize = (fp->flag & _UNBUF) ? 1 : BUFSIZ; if (fp->base == NULL) 1* no buffer yet *1
if «fp->base = (char *) malloc(bufsize» -- NULL) return EOF; 1* can't get buffer *1
fp->ptr =fp->base;
fp->cnt =read(fp->fd, fp->ptr, bufsize); if (--fp->cnt < 0) {
if (fp->cnt == -1) fp->flag 1= _EOF;
else
fp->flag 1= _ERR;
fp->cnt =0;
return EOF;
}
return (unsigned char) *fp->ptr++;
}
The only remaining loose end is how everything gets started. The array
_iob must be defined and initialized for stdin, stdout and stderr:
FILE _iob[OPEN_MAX] = { 1* stdin, stdout, stderr: *1 { 0, (char *) 0, (char *) 0, _READ, 0 },
{ 0, (char *) 0, (char *) 0, _WRITE, 1 },
{ 0, (char *) 0, (char *) 0, _WRITE 1 _UNBUF, 2 }
};
The initialization ofthe flag part of the structure showsthat stdin is to be
read, stdout is to be written, and stderr is to be written unbuffered. Exercise8-2. Rewrite fopen and _fillbuf with fields instead of explicit bit

 SECTION 8.6 EXAMPLE-LISTING DIRECTORIES 179
operations. Compare code size and execution speed. 0
Exercise8-3. Designand write _flushbuf, fflush, and fclose. 0
Exercise 8-4. The standard library function
int fseek(FILE *fp, long offset, int origin)
isidenticaltoIseekexceptthatfpisafilepointerinsteadofafiledescriptor and the return value is an int status, not a position. Write fseek. Make sure that your fseek coordinates properly with the buffering done for the other functions of the library. 0
8.6 Example- Listing Directories
A different kind of file system interaction is sometimes called for- determining information about a file, not what it contains. A directory-listing programsuchastheUNIXcommandIsisanexample-itprintsthenamesof files in a directory, and, optionally, other information, such as sizes, permissions, andsoon. TheMS-DOS dir commandisanalogous.
Since a UNIX directory is just a file, 1s need only read it to retrieve the filenames. But it is necessary to use a system call to access other information about a file, such as its size. On other systems, a system call may be needed even to access filenames; this is the case on MS-DOS, for instance. What we want is provide access to the information in a relatively system-independent way, even though the implementation may be highly system-dependent.
We will illustrate some of this by writing a program called fsize. fsize isaspecialformofIsthatprintsthesizesofallfilesnamedinitscommand- lineargumentlist.Ifoneofthefilesisadirectory,fsize appliesitselfrecur- sively to that dire_ctory. If there are no arguments at all, it processes the current directory.
Let us begin with a short review of UNIX file system structure. A directory is a file that contains a list of filenames and some indication of where they are located. The "location" is an index into another table called the "inode list." The inode for a file is where all information about a file except its name is kept. A directory entry generally consists of only two items, the filename and an inode number.
Regrettably, the format and precise contents of a directory are not the same on all versions of the system. So we will divide the task into two pieces to try to isolate the non-portable parts. The outer level defines a structure called a Dirent and three routines opendir, readdir, and closedir to provide system-independent access to the name and inode number in a directory entry. Wewillwritefsize withthisinterface. Thenwewillshowhowtoimplement these on systems that use the same directory structure as Version 7 and System V UNIX; variants are left as exercises.

 180 THE UNIX SYSTEM INTERFACE CHAPTER 8
The Dirent structure contains the inode number and the name. The max- imum length of a filename component is NAME_MAX, which is a system- dependent value. opendir returns a pointer to a structure called DIR,analo- gous to FILE,which is used by readdir and closedir. This information is collected into a file called dirent. h.
#defineNAME_MAX 141*longestfilenamecomponent;*1 1* system-dependent *1
typedef struct { 1* portable directory entry: *1 long ino; 1* inode number *1
char name[NAME_MAX+1]; 1* name + '\0' terminator *1
} Dirent;
typedef struct { int fd;
Dirent d; } DIR;
1* minimal DIR: no buffering, etc. *1 1* file descriptor for directory *1 1* the directory entry *1
DIR *opendir(char *dirname); Dirent *readdir(DIR *dfd); void closedir(DIR *dfd);
The system call stat takes a filename and returns all of the information in theinodeforthatfile,or-1ifthereisanerror.Thatis,
char *name;
struct stat stbuf;
int stat(char *, struct stat *);
stat(name, &stbuf);
fills the structure stbuf with the inode information for the file name. The structure describing the value returned by stat is in <sys/stat. h>, and typ- ically looks like this:

 SECTION 8.6 EXAMPLE-LISTING DIRECTORIES 181
dev _t and ino_ t are defined in <sys/types. h>, which must be included too.
The st_mode entry contains a set of flags describing the file. The flag definitions are also included in <sys/stat. h>; we need only the part that deals with file type:
#define #define #define #define #define
1* ... *1
S_IFMT 0160000 S_IFDIR 0040000
S_IFCHR 0020000 S_IFBLK 0060000 S_IFREG 0100000
1* type of file: *1
1* directory *1
1* character special *1 1* block special *1
1* regular *1
Now we are ready to write the program fsize. If the mode obtained from stat indicates that a file is not a directory, then the size is at hand and can be printeddirectly. Ifthefileisadirectory,however,thenwehavetoprocessthat
directory one file at a time; it may in turn contain sub-directories, so the process is recursive.
The main routine deals with command-line arguments; it hands each argu- ment to the function fsize.
#include <stdio.h>
#include <string.h>
#include "syscalls.h"
#include <fcntl.h> 1* flags for read and write *1 #include <sys/types.h> 1* typedefs *1
#include <sys/stat.h> 1* structure returned by stat *1 #include "dirent.h"
void fsize(cllar*);
1* print file sizes *1 main(int argc, char **arqv)
{
}
The function fsize prints the size of the file. If the file is a directory, however,fsize firstcallsdirwalk tohandleallthefilesinit. Notehowthe flag names S_IFMTand S_IFDIR from <sys/stat. h> are used to decide if the file is a directory. Parenthesization matters, because the precedence of &. is lower than that of ==.
if (argc ==1) 1* default: current directory *1 fsize(".");
else
while (--argc > 0)
fsize(*++arqv); return 0;

 t8l
THE UNIX SYSTEM INTERFACE
CHAPTER 8
int stat(char *, struct stat *);
void dirwalk(char *, void (*fcn)(char *»;
/* fsize: print size of file "name" */ void fsize(char *name)
{
}
if «stbu,f.st_mode & S_IFMT)==S_IFOIR) dirwalk(name, fsize);
printf(~"8ld "s'n", stbuf.st_size, name);
}
Thefunctiondirwalkisageneralroutinethatappliesafunctiontoeach file in a directory. It opens the directory, loops through the files in it, calling thefunctiononeach,thenclosesthedirectoryandreturns. Sincef~ize calls dirwalk oneachdirectory,thetwofunctionscalleachotherrecursively.
#define MAX_PATH 1024
1*dirwalk:applyfcntoallfilesindir*1 void dirwalk(char *dir, void (*fcn)(char *»
{
struct stat stbuf;
if (stat(name, &stbuf) ==-1) {
fprintf(stderr, "fsize: can't access "s'n", name); return;
char name[MAX_PATH]; Oirent *dl>;
OIR *dfd;
if «dfc1 =opendir(dir» ==NULL) {
fprintf(stcierr, "dirwalk: can't open "s'n", dir); return;
}
while « dp = readdir (dfd» I = NULL) {
if (strcmp(dp->name, ".")==0
I I strcmp(dp->name, ".•") == 0)
continue; 1*skipselfandparent*1
it (strl~n(dir)+strlen(dp->na~e)+2 > sizeof(name»
fprintf(stderr, "dirwalk: name "8/"s too long'n", dir, dp->name);
else {
8printf(name, ""S/"8", dir, dp->name);
(*fcn) (name) ;
} }
closedir(dfd) ;
}
Each call to readdir returns a pointer to information for the next file, or

 SECTION 8.6 EXAMPLE-LISTING DIRECTORIES 183
NULL when there are no files left. Each directory always contains entries for itself, called ".", and its parent, " .. It; these must be skipped, or the program will loop forever.
Down to this level, the code is independent of how directories are formatted. The next step is to present minimal versions of opendir, readdir, and closedir foraspecificsystem.ThefollowingroutinesareforVersion7and System V UNIX systems; they use the directory information in the header <sys/dir. h>, whichlookslikethis:
#ifndef DIRSIZ
#define DIRSIZ 14
#endif
struct direct 1* directory entry *1
{
char d_name[DIRSIZ]; 1* long name does not have '\0' *1 };
Some versions of the system permit much longer names and have a more com- plicated directory structure.
The type ino _t is a typedef that describes the index into the inode list. It happens to be unsigned short on the system we use regularly, but this is not the sort of information to embed in a program; it might be different on a differentsystem,sothetypedef isbetter. Acompletesetof"system"typesis found in <sys/types. h>.
opendiropensthedirectory,verifiesthatthefileisadirectory(thistime by the system call fstat, which is like stat except that it applies to a file descriptor), allocates a directory structure, and records the information:
int fstat(int fd, struct stat *);
1* opendir: open a directory for readdir calls *1 DIR *opendir(char *dirname)
{
ino_t d_ino; 1* inode number *1
int fd;
struct stat stbuf; DIR *dp;
if «fd =open(dirname, O_RDONLY, 0» ==-1
II fstat(fd, &stbuf) ==-1
I I (stbuf.st_mode & S_IFMT) 1= S_IFDIR
I I (dp =(DIR *) malloc(sizeof(DIR») ==NULL)
return NULL; dp->fd =fd;
return dp;
}
closedir closesthedirectoryfileandfreesthespace:

 184 THE UNIX SYSTEM INTERFACE
CHAPTER 8
/* closedir: close directory opened by opendir*1 void closedir(DIR *dp)
{
} }
if (dp) {
close (dp->fd) ;
free(dp) ;
Finally, readdir uses read to read each directory entry. If a directory slot is not currently in use (because a file has been removed), the inode number is zero, and this position is skipped, Otherwise, the inode number and name are placed in a static structure and a pointer to that is returned to the user. Each call overwrites the information from the previous one.
#include <sys/dir.h> 1* local directory structure *1
1* readdir: read directory entries in sequence*1 Dirent *readdir(DIR *dp)
{
struct direct dirbuf; 1* local directory structure *1 static Dirent d; 1* return: portable structure *1
while (read(dp->fd, (char *) &dirbuf, sizeof(dirbuf» ==sizeof(dirbuf» {
if (dirbuf.d_ino ==0) 1* slot not in use *1 continue;
d.ino =dirbuf.d_ino;
strncpy(d.name, dirbuf.d_name, DIRSIZ); d.name[DIRSIZ] ='\0'; 1* ensure termination *1 return &d;
}
return NULL;
}
Althoughthefsize programisratherspecialized,itdoesillustrateacouple of important ideas. First, many programs are not "system programs"; they merely use information that is maintained by the operating system. For such programs, it is crucial that the representation of the information appear only in standard headers, and that programs include those files instead of embedding the declarations in themselves. The second observation is that with care it is possible to create an interface to system-dependent objects that is itself rela- tively system-independent. The functions of the standard library are good examples.
Exercise8-5. Modify the fsize program to print the other information con- tained in the inode entry. 0

 SECTION 8.7 EXAMPLE-A STORAGE ALLOCATOR 185
8.7 Example-A StorageAllocator
In Chapter 5, we presented a very limited stack-oriented storage allocator. Theversionthatwewillnowwriteisunrestricted.Callstomalloeandfree mayoccurinanyorder;malloe callsupontheoperatingsystemtoobtainmore memory as necessary. These routines illustrate some of the considerations involved in writing machine-dependent code in a relatively machine-independent way, and also showa real-life application of structures, unions and typedef.
Ratherthanallocatingfromacompiled-infixed-sizedarray,malloewill request space from the operating system as needed. Since other activities in the program may also request space without calling this allocator, the space that malloe managesmaynotbecontiguous.Thusitsfreestorageiskeptasalist of free blocks. Each block contains a size, a pointer to the next block, and the space itself. The blocks are kept in order of increasing storage address, and the last block (highest address) points to the first.
free list ~
::::1:e(j7---= , !e'~~eIT:::::::e:'t17jl::::
"'-_ fr.e.1e, owned bymalloc 1inuseI inuse,ownedbymalloc 1:::::::Inot owned bymalloc
When a request is made, the free list is scanned until a big-enough block is found. This algorithm is called "first fit," by contrast with "best fit," which looksforthesmallestblockthatwillsatisfytherequest.Iftheblockisexactly the size requested it is unlinked from the list and returned to the user. If the block is too big, it is split, and the proper amount is returned to the user while the residue remains on the free list. If no big-enough block is found, another large chunk is obtained from the operating system and linked into the free list.
Freeing also causes a search of the free list, to find the proper place to insert the block being freed. If the block being freed is adjacent to a free block on either side, it is coalesced with it into a single bigger block, so storage does not become too fragmented. Determining adjacency is easy because the free list is maintained in order of increasing address.
One problem, which we alluded to in Chapter 5, is to ensure that the storage returnedbymalloe isalignedproperlyfortheobjectsthatwillbestoredinit. Although machines vary, for each machine there is a most restrictive type: if the most restrictive type can be stored at a particular address, all other types may be also. On some machines, the most restrictive type is a double; on others, int orlongsuffices.

 186 THE UNIX SYSTEM INTERFACE CHAPTER 8
A free block contains a pointer to the next block in the chain, a record of the size of the block, and then the free space itself; the control information at the beginning is called the "header." To simplify alignment, all blocks are multi- ples of the header size, and the header is aligned properly. This is achieved by a union that contains the desired header structure and an instance of the most restrictivealignmenttype,whichwehavearbitrarilymadealong:
typedeflongAlign; I. foralignmenttolongboundary.1
union header { I.block header: .1 struct {
union header .ptr; I. next block if on free list .1
unsigned size; I. size of this block .1 }s;
Align x; I. force alignment of blocks .1 };
typedef union header Header;
TheAlignfieldisneverused;itjustforceseachheadertobealignedona worst-case boundary.
In malloc, the requested size in characters is rounded up to the proper number of header-sized units; the block that will be allocated contains one more unit, for the header itself, and this is the value recorded in the size field of the header. The pointer returned by malloc points at the free space, not at the header itself. The user can do anything with the space requested, but if any- thing is written outside of the allocated .space the list is likely to be scrambled.
=- ~ul
poi
nts to next free block
L___ address returned to user A block returned by malloc
Thesizefieldisnecessarybecausetheblockscontrolledbymallocneednotbe contiguous-it is not possible to compute sizes by pointer arithmetic.
The variable base is used to get started. If freep is NULL,as it is at the firstcallofmalloc,thenadegeneratefreelistiscreated;itcontainsoneblock of size zero, and points to itself. -In any case, the free list is then searched. The search for a free block of adequate size begins at the point (freep) where the lastblockwasfound;thisstrategyhelpskeepthelisthomogeneous.Ifatoo-big block is found, the tail end is returned to the user; in this way the header of the original needs only to have its size adjusted. In all cases, the pointer returned to the user points to the free space within the block, which begins one unit beyond the header.
I

 SECTION 8.7 EXAMPLE-A STORAGE ALLOCATOR 187
static Header base; 1* empty list to get started *1 static Header *freep = NULL; 1* start of free list *1
1*malloc: general-purposestorageallocator*1 void *malloc(unsigned nbytes)
{
}
for (p = prevp->s.ptr;, ; prevp = p, p = p->s.ptr) { if (p->s.size >= nunits) { 1* big enough *1
} }
Header *p, *prevp;
Header *morecore(unsigned); unsigned nunits;
nunits = (nbytes+sizeof(Header)-1)/sizeof(Header) + 1; if «prevp = freep) == NULL) { 1* no free list yet *1
base.s.ptr = freep = prevp = &base;
base.s.size = 0;
if (p->s.size == nunits) prevp->s.ptr = p->s.ptr;
1* exactly *1
else { 1* allocate tail end *1 p->s.size -= nunits;
p += p->s.size;
p->s.size = nunits;
}
freep = prevp;
return (void *)(p+1);
}
if (p == freep) 1* wrapped around free list *1 if «p = morecore(nunits» == NULL)
return NULL; 1* none left *1
The function moreeore obtains storage from the operating system. The details of how it does this vary from system to system. Since asking the system for memory is a comparatively expensive operation, we don't want to do that on every call to malloe, so moreeore requests at least NALLOCunits; this larger block will be chopped up as needed. After setting the size field, morecore inserts the additional memory into the arena by calling free.
The UNIX system call sbrk (n) returns a pointer to n more bytes of storage. sbrk returns -1 if there was no space, even though NULLwould have been a better design. The - 1 must be cast to ehar *.so it can be compared with the return value. Again, casts make the function relatively immune to the details of pointer representation on different machines. There is still one assumption, however, that pointers to different blocks returned by sbrk can be meaningfully compared. This is not guaranteed by the standard, which permits pointer comparisons only within an array. Thus this version of malloe is port- able only among machines for which general pointer comparison is meaningful.

 188
THE UNIX SYSTEM INTERFACE CHAPTER 8
#define NALLOC 1024 1* minimum #units to request *1
1*morecore: asksystemformorememory*1 static Header *morecore(unsigned nu)
{
char *cp, *sbrk(int); Header *up;
if (nu < NALLOC) nu =NALLOC;
cp = sbrk(nu * sizeof(Header»; if(cp==(char*)-1) 1*nospaceatall*1
return NULL;
up = (Header *) cp; up->s.size = nu; free«void *)(up+1»; return freep;
}
free itself is the last thing. It scans the free list, starting at freep, look- ing for the place to insert the free block. This is either between two existing blocks or at one end of the list. In any case, if the block being freed is adjacent to either neighbor, the adjacent blocks are combined. The only troubles are keeping the pointers pointing to the right things and the sizes correct.
1* free: put block ap in free list *1 void free(void *ap)
{
}
Header *bp, *p;
bp = (Header *)ap - 1; 1* point to block header *1 for (p = freep; I(bp > p && bp < p->s.ptr); p = p->s.ptr)
if(p>=p->s.ptr&&(bp>p ll bp < p->s.ptr»
break; 1* freed block at start or end of arena *1
if (bp + bp->s.size == p->s.ptr) { 1* join to upper nbr *1 bp->s.size += p->s.ptr->s.size;
bp->s.ptr = p->s.ptr->s.ptr;
} else
bp->s.ptr = p->s.ptr;
if (p + p->s.size == bp) { p->s.size += bp->s.size; p->s.ptr = bp->s.ptr;
} else
p->s.ptr = bp;
freep = p;
1* join to lower nbr *1
Although storage allocation is intrinsically machine-dependent, the code above illustrates how the machine dependencies can be controlled and confined to a very small part of the program. The use of typedef and union handles

 SECTION 8.7 EXAMPLE-A STORAGE ALLOCATOR 189
alignment (given that sbrk supplies an appropriate pointer). Casts arrange that pointer conversionsare made explicit, and even cope with a badly-designed system interface. Even though the details here are related to storage allocation, the general approach is applicable to other situations as well.
Exercise 8-6. The standard library function calloc (n, size) returns a pointer to n objects of size size, with the storage initialized to zero. Write calloc, by calling mal10cor by modifyingit. 0
Exercise8-7.mal10cacceptsasizerequestwithoutcheckingitsplausibility; free believes that the block it is asked to free contains a valid size field. Improve these routines so they take more pains with error checking. 0
Exercise 8-8 Write a routine bfree (p, n) that will free an arbitrary block p ofncharactersintothefreelistmaintainedbymal10candfree. Byusing bfree, a user can add a static or external array to the free list at any time. 0

 
 A1. Introduction
APPENDIX A: Reference Manual
This manual describes the C language specified by the draft submitted to ANSI on 31 October, 1988, for approval as "American National Standard for Information Systems-Programming Language C, X3.159-1989." The manual is an interpretation of the proposed standard, not the Standard itself, although care has been taken to make it a reliable guide to the language.
For the most part, this document follows the broad outline of the Standard, which in turn follows that of the first edition of this book, although the organization differs in detail. Except for renaming a few productions, and not formalizing the definitions of the lexical tokens or the preprocessor, the grammar given here for the language proper is equivalent to that of the Standard.
Throughout this manual, commentary material is indented and written in smaller type, as this is. Most often these comments highlight ways in which ANSI Standard C differs from the language defined by the first edition of this book, or from refinements subsequently introduced in various compilers.
A2. Lexical Conventions
A program consists of one or more translation units stored in files. It is translated in several phases, which are described in §A12. The first phases do low-level lexical transformations, carry out directives introduced by lines beginning with the # character, and perform macro definition and expansion. When the preprocessing of §A12 is com- plete, the program has been reduced to a sequence of tokens.
A2.1 Tokens
There are six classes of tokens: identifiers, keywords, constants, string literals, opera- tors, and other separators. Blanks, horizontal and vertical tabs, newlines, formfeeds, and comments as described below (collectively, "white space") are ignored except as they separate tokens. Some white space is required to separate otherwise adjacent identifiers, keywords, and constants.
191

 192 REFERENCE MANUAL APPENDIX A
Iftheinputstreamhasbeenseparatedintotokensuptoagivencharacter,thenext token is the longest string of characters that could constitute a token.
A2.2 Comments
The characters 1* introduce a comment, which terminates with the characters *1.
Comments do not nest, and they do not occur within string or character literals.
A2.3 Identifiers
An identifier is a sequence of letters and digits. The first character must be a letter; the underscore _ counts as a letter. Upper and lower case letters are different. Identi- fiers may have any length, and for internal identifiers, at least the first 31 characters are significant; some implementations may make more characters significant. Internal iden- tifiers include preprocessor macro names and all other names that do not have external linkage (§AI1.2). Identifiers with external linkage are more restricted: implementations ," may make as few as the first six characters as significant, and may ignore case distinc- tions.
A2.4 Keywords
The following identifiers are reserved for use as keywords, and may not be used
otherwise:
auto double int struct break else long switch case enum register typedef char extern return union const float short unsigned continue for signed void default goto sizeof volatile do if static while
Some implementations also reserve the words fortran and asm.
The keywords const, signed, and volatile are new with the ANSI stand- ard; enum and void are new since the first edition, but in common use; entry, formerly reserved but never used, is no longer reserved.
A2.5 Constants
There are several kinds of constants. Each has a data type; §A4.2 discusses the basic types.
constant: integer-constant
character-constant floating-constant
enumeration -constant

 SECTION A2 LEXICAL CONVENTIONS 193
A2.5.1 Integer Constants
An integer constant consisting of a sequence of digits is taken to be octal if it begins with 0 (digit zero), decimal otherwise. Octal constants do not contain the digits 8 or 9. A sequence of digits preceded by Ox or Ox (digit zero) is taken to be a hexadecimal integer. The hexadecimal digits include a or A through f or F with values 10 through 15.
An integer constant may be suffixed by the letter u or U, to specify that it is unsigned. It may also be suffixed by the letter 1 or L to specify that it is long.
The type of an integer constant depends on its form, value and suffix. (See §A4 for a discussion of types.) If it is unsuffixed and decimal, it has the first of these types in which its value can be represented: int, long int, unsigned long into If it is unsuffixed octal or hexadecimal, it has the first possible of these types: int, unsigned int, long int, unsigned long into If it is suffixed by u or u, then unsigned int, unsigned long into If it is suffixed by 1 or L, then long int, unsigned long into
The elaboration of the types of integer constants goes considerably beyond the first edition, which merely caused large integer constants to be long. The U suffixes are new.
A2.5.2 Character Constants
A character constant is a sequence of one or more characters enclosed in single quotes, as in ' x '. The value of a character constant with only one character is the numeric value of the character in the machine's character set at execution time. The value of a multi-character constant is implementation-defined.
Character constants do not contain the ' character or newlines; in order to represent them, and certain other characters, the following escape sequences may be used.
newline NL
horizontal tab HT
vertical tab VT
backspace BS
carriage return CR
form feed FF
audible alert BEL \a
Theescape\000consistsofthebackslashfollowedbyI,2,or3octaldigits,whichare taken to specify the value of the desired character. A common example of this construc- tion is \0 (not followed by a digit), which specifies the character NUL. The escape \xhh consists of the backslash, followed by x, followed by hexadecimal digits, which are taken to specify the value of the desired character. There is no limit on the number of digits, but the behavior is undefined if the resulting character value exceeds that of the largest character. For either octal or hexadecimal escape characters, if the implementa- tion treats the char type as signed, the value is sign-extended as if cast to char type. If the character following the \ is not one of those specified, the behavior is undefined.
In some implementations, there is an extended set of characters that cannot be represented in the char type. A constant in this extended set is written with a preced- ing L, for example L' x" and is called a wide character constant. Such a constant has type wchar_t, an integral type defined in the standard header <stddef. h>. As with
(LF) \n
\t question mark? \? \v single quote \'
backslash
\ \ \
\b double quote
\r octalnumber 000 \000 \f hex number hh \xhh
" \ "

 194 REFERENCE MANUAL APPENDIX A
ordinary character constants, octal or hexadecimal escapes may be used; the effect is undefined if the specified value exceeds that representable with wchar_t.
Some of these escape sequences are new, in particular the hexadecimal charac- ter representation. Extended characters are also new. The character sets com- monly used in the Americas and western Europe can be encoded to fit in the char type; the main intent in adding wchar _t was to accommodate Asian languages.
A2.S.3 Floating Constants
A floating constant consists of an integer part, a decimal point, a fraction part, an e or E, an optionally signed integer exponent and an optional type suffix, one of f, F, 1, or L. The integer and fraction parts both consist of a sequence of digits. Either the integer part or the fraction part (not both) may be missing; either the decimal point or the e and the exponent (not both) may be missing. The type is determined by the suffix; F or f makes it float, L or 1 makes it long double; otherwise it is double.
Suffixes on floating constants are new.
A2.S.4 EnumerationConstants
Identifiers declared as enumerators (see §A8.4) are constants of type into
A2.6 String Literals
A string literal, also called a string constant, is a sequence of characters surrounded by double quotes, as in " ... ". A string has type "array of characters" and storage class static (see §A4 below) and is initialized with the given characters. Whether identical string literals are distinct is implementation-defined, and the behavior of a pro- gram that attempts to alter a string literal is undefined.
Adjacent string literals are concatenated into a single string. After any concatena- tion, a null byte \0 is appended to the string so that programs that scan the string can find its end. String literals do not contain newline or double-quote characters; in order to represent them, the same escape sequences as for character constants are available.
As with character constants, string literals in an extended character set are written with a preceding L, as in L" ••• ". Wide-character string literals have type "array of wchar_t." Concatenation of ordinary and wide string literals is undefined.
The specification that string literals need not be distinct, and the prohibition against modifying them, are new in the ANSI standard, as is the concatenation of adjacent string literals. Wide-character string literals are new.
A3. Syntax Notation
In the syntax notation used in this manual, syntactic categories are indicated by italic type, and literal words and characters in typewriter style. Alternative categories are usually listed on separate lines; in a few cases, a long set of narrow alter- natives is presented on one line, marked by the phrase "one of." An optional terminal or nonterminal symbol carries the subscript "opt," so that; for example,

 SECTION A4 MEANING OF IDENTIFIERS 195
{ expressionopt }
means an optional expression, enclosed in braces. The syntax is summarized in §A13. Unlike the grammar given in the first edition of this book, the one given here
makes precedence and associativity of expression operators explicit.
A4. Meaningof Identifiers
Identifiers, or names, refer to a variety of things: functions; tags of structures, unions, and enumerations; members of structures or unions; enumeration constants; typedef names; and objects. An object, sometimes called a variable, is a location in storage, and its interpretation depends on two main attributes: its storage class and its type. The storage class determines the lifetime of the storage associated with the identi- fied object; the type determines the meaning of the values found in the identified object. A name also has a scope, which is the region of the program in which it is known, and a linkage, which determines whether the same name in another scope refers to the same object or function. Scope and linkage are discussed in §A11.
A4.1 StorageClass
There are two storage classes: automatic and static. Several keywords, together with the context of an object's declaration, specify its storage class. Automatic objects are local to a block (§A9.3), and are discarded on exit from the block. Declarations within a block create automatic objects if no storage class specification is mentioned, or if the auto specifier is used. Objects declared register are automatic, and are (if possible) stored in fast registers of the machine.
Static objects may be local to a block or external to all blocks, but. in either case retain their values across exit from and reentry to functions' and blocks. Within ~ block, including a block that provides the code for a function, static objects are declared with the keyword static. The objects declared outside all blocks, atthe same level as func- tion definitions, are always static. They may be made local to a particular translation unit by useofthe static keyword; this gives them internal linkage, they become glo- bal to an entire program by omitting an explicit storage class, or by using the keyword extern; this gives them external linkage.
A4.2 Basic Types
There are several fundamental types. The standard header <limits. h> described in Appendix B defines the largest and smallest values of each type in the local imple- mentation. The numbers given in Appendix B show the smallest acceptable magnitudes.
Objects declared as characters (char) are large enough to store any member of the execution character set. If a genuine character from that set is stored in a char object, its value is equivalent to the integer code for the character, and is non-negative. Other quantities may be stored into char variables, but the available range of values, and especially whether the value is signed, is implementation-dependent. '
Unsigned characters declared unsigned char consume the same amount of space as plain characters, but always appear non-negative; explicitly signed characters declared signed c~ar likewise take the same space as plain characters.

 196 REFERENCE MANUAL APPENDIX A
unsigned char type does not appear in the first edition of this book,but is in common use. signed char is new.
Besidesthe char types, up to three sizesof integer, declared short Lnt, int, and longint,areavailable.Plainintobjectshavethenaturalsizesuggestedbythehost machine architecture; the other sizes are provided to meet special needs. Longer
integers provide at least as much storage as shorter ones, but the implementation may makeplainintegersequivalenttoeither.shortintegers,orlongintegers.Theint types all represent signed values unless specified otherwise.
Unsignedintegers,declaredusingthekeywordunsigned,obeythelawsofarith- metic modulo 2n where n is the number of bits in the representation, and thus arithmetic on unsigned quantities can never overflow. The set of non-negative values that can be stored in a signed object is a subset of the values that can be stored in the corresponding unsigned object, and the representation for the overlappingvalues is the same.
Anyofsingleprecisionfloatingpoint(float), doubleprecisionfloatingpoint (double), and extra precisionfloating point (long double) may be synonymous,but the ones later in the list are at least as precise as those before.
long double is new. The first edition made long float equivalent to double;thelocution hasbeenwithdrawn.
Enumerations are unique types that have integral values; associated with each enumeration is a set of named constants (§A8.4). Enumerations behave like integers, but it is common for a compiler to issue a warning when an object of a particular enumeration type is assigned something other than one of its constants, or an expression of its type.
Because objects of these types can be interpreted as numbers, they will be referred to asarithmetic types. Typeschar, and int ofallsizes,eachwithorwithoutsign,and also enumeration types, will collectivelybe called integral types. The types float, double, and long double willbe calledfloating types.
The void type specifiesan empty set of values. It is used as the type returned by functions that generate no value.
A4.3 DerivedTypes
Besides the basic types, there is a conceptually infinite class of derived types con- structed from the fundamental types in the followingways:
arrays. of objects.of a given type;
functions returning objects of a given type; pointers to objects of a given type;
structures containing a sequence of objects of various types;
unions capableofcontaininganyone ofseveralobjectsofvarioustypes. In general these methods of constructing objects can be applied recursively.
A4.4 Type Qualifiers
An object's type may have additional qualifiers. Declaring an object const announcesthatitsvaluewillnotbechanged;declaringitvolatile announcesthatit has special properties relevant to optimization. Neither qualifier affects the range of values or arithmetic properties of the object. Qualifiers are discussed in §A8.2.

 SECTION A6 CONVERSIONS 197
AS. Objects and Lvalues
An object is a named region of storage; an lvalue is an expression referring to an object. An obvious example of an lvalue expression is an identifier with suitable type and storage class. There are operators that yield lvalues: for example, if E is an expres- sion of pointer type, then *E is an lvalue expression referring to the object to which E points. The name "lvalue" comes from the assignment expression E1 = E2 in which the left operand E 1 must be an lvalue expression. The discussion of each operator speci- fies whether it expects lvalue operands and whether it yields an lvalue.
A6. Conve,slons
Some operators may, depending on their operands, cause conversion of the value of an operand from one type to another. This section explains the result to be expected from such conversions. §A6.5 summarizes the conversions demanded by most ordinary operators; it will be supplemented as required by the discussion of each operator.
A6.1 Integral Promotion
A character, a short integer, or an integer bit-field, all either signed or not, or an object of enumeration type, may be used in an expression wherever an integer may be used. If an int can represent all the values of the original type, then the value is con- verted to int; otherwise the value is converted to unsigned into This process is called integral promotion.
A6.2 Integral Conversions
Any integer is converted to a given unsigned type by finding the smallest non- negative value that is congruent to that integer, modulo one more than the largest value that can be represented in the unsigned type. In a two's complement representation, this is equivalent to left-truncation if the bit pattern of the unsigned type is narrower, and to zero-filling unsigned values and sign-extending signed values if the unsigned type is wider.
When any integer is converted to a signed type, the value is unchanged if it can be represented in the new type and is implementation-defined otherwise.
A6.3 Integer and Floating
When a value of floating type is converted to integral type, the fractional part is dis- carded; if the resulting value cannot be represented in the integral type, the behavior is undefined. In particular, the result of converting negative floating values to unsigned integral types is not specified.
When a value of integral type is converted to floating, and .the value is in the representable range but is not exactly representable, then the result may be either the next higher or next lower representable value. If the result is out of range, the behavior is undefined.

 198 REFERENCE MANUAL APPENDIX A
A6.4 Floating Types
When a less precise floating value is converted to an equally or more precise floating type, the value is unchanged. When a more precise floating value is converted to a less precise floating type, and the value is within representable range, the result may be either the next higher or the next lower representable value. If the result is out of range, the behavior is undefined.
A6.5 Arithmetic Conversions
Many operators cause conversions and yield result types in a similar way. The effect is to bring operands into a common type, which is also the type of the result. This pat- tern is called the usual arithmetic conversions.
First, if either operand is long double, the other is converted to long double. Otherwise, if either operand is double, the other is converted to double.
Otherwise, if either operand is float, the other is converted to float.
Otherwise, the integral promotions are performed on' both operands; then, if either operand is unsigned long int, the other is converted to unsigned long into Otherwise, if one operand is long int and the other is unsigned int, the effect depends on whether a long int can represent all values of an unsigned int; if so, the unsigned int operand is converted to long int; if not, both are converted to unsigned long into Otherwise,ifoneoperandislongint,theotherisconvertedtolonginto Otherwise, ifeither operand is unsLqnedint, the other is converted to unsigned into
Otherwise, both operands have type into
Therearetwochangeshere.First,arithmeticonfloatoperandsmaybedone in single precision, rather than double; the first edition specified that all floating arithmetic was double precision. Second, shorter unsigned types, when com- bined with a larger signed type, do not propagate the unsigned property to the result type; in the first edition, the unsigned always dominated. The new rules are slightly more complicated, but reduce somewhat the surprises that may occur when an unsigned quantity meets signed. Unexpected results may still occur when an unsigned expression is compared to a signed expression of the same size.
A6.S Pointers and Integers
An expression of integral type may be added to or subtracted from a pointer; in such a case the integral expression is converted as specified in the discussion of the addition operator (§A7.7).
Two pointers to objects of the same type, in the same array, may be subtracted; the result is converted to an integer as specified in the discussion of the subtraction operator (§A7.7).
An integral constant expression with value 0; or such an expression cast to type void*,maybeconverted,byacast,byassignment,orbycomparison,toa.pointerof any type. This produces a null pointer that is equal to another null pointer of the same type, but unequal to any pointer to a function or object.
Certain other conversions involving pointers are permitted, but have implementation- dependent aspects. They must be specified by an explicit type-conversion operator, or

 SECTION A6 CONVERSIONS 199
cast (§§A7.5 and A8.8).
A pointer may be converted to an integral type large enough to hold it; the required
size is implementation-dependent. The mapping function is also implementation- dependent.
An object of integral type may be explicitly converted to a pointer. The mapping always carries a sufficiently wide integer converted from a pointer back to the same pointer, but is otherwise implementation-dependent.
A pointer to one type may be converted to a pointer to another type. The resulting pointer may cause addressing exceptions if the subject pointer does not refer to an object suitably aligned in storage. It is guaranteed that a pointer to an object may be con- verted to a pointer to an object whose type requires less or equally strict storage align- ment and back again without change; the notion of "alignment" is implementation" dependent, but objects of the char types have least strict alignment requirements. As described in §A6.8, a pointer may also be converted to type void * and back again without change.
A pointer may be converted to another pointer whose type is the same except for the addition or removal of qualifiers (§§A4.4, A8.2) of the object type to which the pointer refers. If qualifiers are added, the new pointer is equivalent to the old except for restric- tions implied by the new qualifiers. If qualifiers are removed, operations on the underly- ing object remain subject to the qualifiers in its actual declaration.
Finally, a pointer to a function may be converted to a pointer to another function type. Calling the function specified by the converted pointer is implementation- dependent; however, if the converted pointer is reconverted to its original type, the result is identical to the original pointer.
A6.7 Void
The «nonexistent) value of a void object may not be used in any way, and neither explicit nor implicit conversion to any non-void type may be applied. Because a void expression denotes a nonexistent value, such an expression may be used only where the value is not required, for example as an expression statement (§A9.2) or as the left operand of a comma operator (§A7.18).
An expression may be converted to type void by a cast. For example, a void cast documents the discarding of the value of a function call used as an expression statement.
void did not appear in the first edition of this book,but has become common since.
A6.8 Pointersto Void
Anypointertoanobjectmaybeconvertedtotypevoid*withoutlossofinforma- tion. If the result is converted back to the original pointer type, the original pointer is recovered. Unlike the pointer-to-pointer conversions discussed in §A6.6, which generally require an explicit cast, pointers may be assigned to and from pointers of type void *, and may be compared with them.
This interpretation of void * pointers is new; previously, char * pointers played the role of generic pointer. The ANSI standard specifically blesses the meeting of void * pointers with object pointers in assignments and relationals, while requiring explicit casts for other pointer mixtures.

 200 REFERENCE MANUAL APPENDIX A
A 7. Expressions
The precedence of expressionoperators is the same as the order of the major subsec- tions of this section, highest precedence first. Thus, for example, the expressions referred to as the operands of + (§A7.7) are those expressionsdefined in §§A7.I-A7.6. Within each subsection, the operators have the same precedence. Left- or right- associativity is specified in each subsection for the operators discussed therein. The grammar in §A13 incorporates the precedence and associativityof the operators.
The precedence and associativity of operators is fully specified, but the order of evaluation of expressionsis, with certain exceptions,undefined, even if the subexpressions involve side effects. That is, unless the definition of an operator guarantees that its operands are evaluated in a particular order, the implementation is free to evaluate operands in any order, or even to interleave their evaluation. However, each operator combines the values produced by its operands in a way compatible with the parsing of the expressionin which it appears.
This rule revokes the previous freedom to reorder expressions with operators that are mathematically commutative and associative. but can fail to be compu- tationally associative. The change affects only floating-point computations near the limits of their accuracy, and situations where overflow is possible.
The handling of overflow,divide check, and other exceptions in expressionevaluation is not defined by the language. Most existing implementations of C ignore overflow in evaluation of signed integral expressions and assignments, but this behavior is not guaranteed. Treatment of division by 0, and all floating-point exceptions, varies among implementations; sometimes it is adjustable by a non-standard library function.
A7.1 Pointer Generation
If the type ofan expressionor subexpressionis "array of T," for some type T, then the value of the expression is a pointer to the first object in the array, and the type of the expressionis altered to "pointer to T." This conversiondoes not take place if the expressionis the operand of the unary & operator, or of ++, --, sizeof, or as the left operand of an assignment operator or the • operator. Similarly, an expression of type "function returning T," except when used as the operand of the & operator, is converted to "pointer to function returning T."
A7.2 Primary Expressions
Primary expressionsare identifiers, constants, strings, or expressionsin parentheses.
primary-expression: identifier
constant string
( expression
An identifier is a primary expression, provided it has been suitably declared as dis- cussed below. Its type is specified by its declaration. An identifier is an lvalue if it refers to an object (tAS) and if its type is arithmetic, structure, union, or pointer.
A constant is a primary expression. Its type depends on its form as discussed in tA2.S.
A string literal is a primary expression. Its type is originally "array of char" (for wide-characterstrings,"array ofwchar_t"), butfollowingtherulegivenin§A7.1,this

 SECTION A7 EXPRESSIONS 201
is usually modified to "pointer to char" (wchar_t) and the result is a pointer to the first character in the string. The conversion also does not occur in certain initializers; see §AS.7.
A parenthesized expression is a primary expression whose type and value are identi- cal to those of the unadorned expression. The presence of parentheses does not affect whether the expression is an lvalue.
A7.3 Postfix Expressions
The operators in postfix expressions group left to right.
postfix -expression: primary-expression
postfix-expression [ expression] postfix-expression(argument-expression-listq, postfix-expression . identifier postfix-expression -> identifier postfix-expression ++
postfix-expression --
argument-expression-list:
assignment-expression
argument-expression-list , assignment-expression
A7.3.1 Array References
A postfix expression followed by an expression in square brackets is a postfix expres- sion denoting a subscripted array reference. One of the two expressions must have type "pointer to T', where T is some type, and the other must have integral type; the type of the subscript expression is T. The expression E1[E2] is identical (by definition) to *((E 1) + (E2 ) ). See §AS.6.2 for further discussion.
A7.3.2 Function Calls
A function call is a postfix expression, called the function designator, followed by parentheses containing a possibly empty, comma-separated list of assignment expressions (§A7.17), which constitute the arguments to the function. If the postfix expression con- sists of an identifier for which no declaration exists in the current scope, the identifier is implicitly declared as if the declaration
extern int identifier();
had been given in the innermost block containing the function call. The postfix expres- sion (after possible implicit declaration and pointer generation, §A7.1) must be of type "pointer to function returning T," for some type T, and the value of the function call has type T.
In the first edition, the type was restricted to "function," and an explicit * operator was required to call through pointers to functions. The ANSI standard blesses the practice of some existing compilers by permitting the same syntax for calls to functions and to functions specified by pointers. The older syntax is still usable.
The term argument is used for an expression passed by a function call; the term parameter is used for an input object (or its identifier) received by a function definition,

 202 REFERENCE MANUAL APPENDIX A
or described in a function declaration. The terms "actual argument (parameter)" and "formal argument (parameter)" respectively are sometimes used for the same distinc- tion.
In preparing for the call to a function, a copy is made of each argument; all argument-passing is strictly by value. A function may change the values of its parame- ter objects, which are copies of the argument expressions, but these changes cannot affect the values of the arguments. However, it is possible to pass a pointer on the understanding that the function may change the value of the object to which the pointer points.
There are two styles in which functions may be declared. In the new style, the types of parameters are explicit and are part of the type of the function; such a declaration is also called a function prototype. In the old style, parameter types are not specified. Function declaration is discussed in §§A8.6.3 and AIO.I.
If the function declaration in scope for a call is old-style, then default argument pro- motion is applied to each argument as follows: integral promotion (§A6.1) is performed on each argument of integral type, and each float argument is converted to double. The effect of the call is undefined if the number of arguments disagrees with the number of parameters in the definition of the function, or if the type of an argument after promotion disagrees with that of the corresponding parameter. Type agreement depends on whether the function's definition is new-style or old-style. If it is old-style, then the comparison is between the promoted type of the argument of the call, and the promoted type of the parameter; if the definition is new-style, the promoted type of the argument must be that of the parameter itself, without promotion.
If the function declaration in scope for a call is new-style, then the arguments are converted, as if by assignment, to the types of the corresponding parameters of the function's prototype. The number of arguments must be the same as the number of explicitly described parameters, unless the declaration's parameter list ends with the ellipsis notation (, •.. ). In that case, the number of arguments must equal or exceed the number of parameters; trailing arguments beyond the explicitly typed parameters suffer default argument promotion as described in the preceding paragraph. If the definition of the function is old-style, then the type of each parameter in the prototype visible at the call must agree with the corresponding parameter in the definition, after the definition parameter's type has undergone argument promotion.
These rules are especially complicated because they must cater to a mixture of old- and new-style functions; Mixtures are to be avoided if possible.
The order of evaluation of arguments is unspecified; take note that various compilers differ. However, the arguments and the function designator are completely evaluated, including all side effects, before the function is entered. Recursive calls to any function are permitted.
A7.3.3 Structure References
A postfix expression followed by a dot followed by an identifier is a postfix expres- sion. The first operand expression must be a structure or a union, and the identifier must name a member of the structure or union. The value is the named member of the structure or union, and its type is the type of the member. The expression is an lvalue if the first expression is an Ivalue, and if the type of the second expression is not an array type.

 SECTION A7 EXPRESSIONS 203
A postfix expression followed by an arrow (built from - and » followed by an iden- tifier is a postfix expression. The first operand expression must be a pointer to a struc- ture or a union, and the identifier must name a member of the structure or union. The result refers to the named member of the structure or union to which the pointer expres- sion points, and the type is the type of the member; the result is an lvalue if the type is not an array type.
Thus the expression E1->MOS is the same as (*E1) •MOS. Structures and unions are discussed in §A8.3.
In the first edition of this book, it was already the rule that a member name in such an expression had to belong to the structure or union mentioned in the postfix expression; however, a note admitted that this rule was not firmly enforced. Recent compilers, and ANSI, do enforce it.
A7.3.4 Postfix Incrementation
A postfix expression followed by a ++ or - - operator is a postfix expression. The value of the expression is the value of the operand. After the value is noted, the operand is incremented (++) or decremented (...-) by 1. The operand must be an lvalue; see the discussion of additive operators (§A7.7) and assignment (§A7.17) for further constraints on the operand and details of the operation. The result is not an lvalue.
A7.4 Unary Operators
Expressions with unary operators group right-to-left,
unary-expression: postfix -expression
++ unary-expression
- - unary-expression unary-operator cast-expression sizeof unary-expression sheof (type-name )
unary-operator: one of &*+
A 7.4. 1 Prefix Incrementation Operators
A unary expression preceded by a ++ or -- operator is a unary expression. The operand is incremented (+ +) or decremented (- -) by 1. The value of the expression.is the value after. the incrementation (decrementation). The operand must be an lvalue; see the discussion of additive operators (§A7.7) and assignment (§A7.17) for further constraints on the operand and details of the operation. The result is not an lvalue.
A7.4.2 Address Operator
The unary & operator takes the address of its operand. The operand must be an lvalue referring neither to a bit-field nor to an object declared as register, or must be of function type. The result is a pointer to the object or function referred to by the Ivalue. If the type of the operand is T, the type of the result is "pointer to T."

 204 REFERENCE MANUAL APPENDIX A
A7.4.3 Indirection Operator
The unary * operator denotes indirection, and returns the object or function to which its operand points. It is an lvalue if the operand is a pointer to an object of arithmetic, structure, union, or pointer type. If the type of the expressionis "pointer to T," the type of the result is T.
A7.4.4 UnaryPlusOperator
The operand of the unary + operator must have arithmetic type, and the result is the value of the operand. An integral operand undergoes integral promotion. The type of the result is the type of the promoted operand.
The unary + is new with the ANSI standard. It was added for symmetry with unary -.
A7.4.6 Unary Minus Operator
The operand of the unary _ operator must have arithmetic type, and the result is the negative of its operand. An integral operand undergoes integral promotion. The nega- tive of an unsigned quantity is computed by subtracting the promoted value from the largest value of the promoted type and adding one; but negative zero is zero. The type of the result is the type of the promoted operand.
A7.4.8 One's Complement Operator
The operand of the - operator must have integral type, and the result is the one's complementofitsoperand.Theintegralpromotionsareperformed.Iftheoperandis unsigned, the result is computed by subtracting the value from the largest value of the promotedtype.Iftheoperandissigned,theresultiscomputedbyconvertingthepro- moted operand to the corresponding unsigned type, applying -, and converting back to the signed type. The type of the result is the type of the promoted operand.
A7.4.7 Logical Negation Operator
The operand of the I operator must have arithmetic type or be a pointer, and the result is 1 if the value of its operand compares equal to 0, and 0 otherwise. The type of the result is into
A7.4.8 Sizeof Operator
Thesizeof operatoryieldsthenumberofbytesrequiredtostoreanobjectofthe type of its operand. The operand is either an expression,.which is not evaluated, or a parenthesized type name. When sizeof is applied to a char, the result is 1; when applied to an array, the result is the total number of bytes in the array. When applied to a structure or union, the result is the number of bytes in the object, including any padding required to make the object tile an array: the size of an array of n elements is n times the size of one element. The operator may not be applied to an operand of func- tion type, or of incomplete type, or to a bit-field. The result is an unsigned integral con- stant; the particular type is implementation-defined. The standard header <stddef. h> (see Appendix B) defines this type as size_ t.

 SECTION A7 EXPRESSIONS 205
A7.5 Casts
A unary expressionpreceded by the parenthesized name of a type causes conversion of the value of the expressionto the named type.
cast-expression: unary-expression
( type-name) cast-expression
This construction is called a cast. Type names are described in §A8.8. The effects of
conversionsare described in §A6. An expressionwith a cast is not an lvalue.
A7.6 MuHiplicativeOperators
The multiplicativeoperators *, I, and" group left-to-right.
multiplicative-expression: cast-expression
multiplicative-expression * cast-expression multiplicative-expression I cast-expression multiplicative-expression" cast-expression
The operands of * and I must have arithmetic type; the operands of " must have integral type. The usual arithmetic conversionsare performed on the operands, and predict the type of the result.
The binary * operator denotes multiplication.
The binary I operator yields the quotient, and the" operator the remainder, of the division of the first operand by the second; if the second operand is 0, the result is unde- fined. Otherwise, it is always true that (alb) *b + a"b is equal to a. If both operands are non-negative,then the remainder is non-negativeand smaller than the divi- sor; if not, it is guaranteed only that the absolute value of the remainder is smaller than the absolute value of the divisor.
A7.7 Additive Operators
Theadditiveoperators+and-groupleft-to-right.Iftheoperandshavearithmetic type, the usual arithmetic conversions are performed. There are some additional type possibilitiesfor each operator.
additive-expression:
multiplicative-expression
additive-expression + multiplicative-expression additive-expression - multiplicative-expression
The result of the + operator is the sum of the operands. A pointer to an object in an array and a value of any integral type may be added. The latter is converted to an address offset by multiplying it by the size of the object to which the pointer points. The sum is a pointer of the same type as the original pointer, and points to another object in the same array, appropriately offset from the original object. Thus if P is a pointer to an object in an array, the expression P+ 1 is a pointer to the next object in the array. If the sum pointer points outside the bounds of the array, except at the first loca- tion beyond the high end, the result is undefined.
The provision for pointers just beyond the end of an array is new. It legitimizes a common idiom for looping over the elements of an array.
The result of the - operator is the difference of the operands. A value of any

 206 REFERENCE MANUAL APPENDIX A
integral type may be subtracted from a pointer, and then the same conversions and con- ditions as for addition apply.
If two pointers to objects of the same type are subtracted, the result is a signed integral value representing the displacement between the pointed-to objects; pointers to successive objects differ by 1. The' type of the result depends on the implementation, but is defined as ptrdiff_ t in the standard header <stddef. h>. The value is undefined unless the pointers point. to objects within the same array; however if P points to the last member of an array,then (P+ 1) -P has value 1.
A7.8 Shift Operators
The shift operators « and» group left-to-right. For both operators, each operand must be integral, and is subject to the integral promotions. The type of the result is that of the promoted left operand. The result is undefined if the right operand is negative, or greater than or equal to the number of bits in the left expression's type.
shift -expression: additive-expression
shift -expression << additive-expression shift -expression > > additive-expression
The value of E1«E2 is E1 (interpreted as a bit pattern) left-shifted E2 bits; in the absence of overflow, this is equivalent to multiplication by 2E2. The value of E1»E2 is E1 right-shifted E2 bit positions. The right shift is equivalent to division by 2£2 if E1 is unsigned or if it has a non-negative value; otherwise the result is implementation-defined.
A7.9 Relational Operators
The relational operators group left-to-right, but this fact is not useful; a-eb-ec is parsed as (a<b) <c, and a-eb evaluates to either 0 or 1.
relational-expression: shift -expression
relational-expression relational-expression relational-expression relational-expression
< shift -expression > shift-expression <= shift -expression >=shift -exprrssion
The operators < (less), > (greater), <= (less or equal) and >= (greater or equal) all yield 0 if the specified relation is false and 1 if it is true. The type of the result is into The usual arithmetic conversions are performed on arithmetic operands. .Pointers to objects of the same type (ignoring any qualifiers) may be compared; the result depends on the relative locations in the address space of the pointed-to objects. Pointer com- parison is defined only for parts of the same object: if two pointers point to the same simple object,· they compare equal; if the pointers are to members of the same structure, pointers to objects declared later in the structure compare higher; if the pointers are to members of the same union, they compare equal; if the pointers refer to members of an array, the comparison is equivalent to comparison of the corresponding subscripts. If P points to the last member of an array, then .P+1 compares higher than P, even though P+ 1 points outside the array. Otherwise, pointer comparison is undefined.
These rules slightly liberalize the restrictions stated in the first edition, by per- mitting comparison of pointers to different members of a structure or union. They also legalize comparison with a pointer just off the end of an array.

 SECTION A7
EXPRESSIONS 207
A7.10 Equality Operators
equality-expression: relational-expression
equality-expression ==relational-expression equality-expression I = relational-expression
The == (equal to) and the I= (not equal to) operators are analogous to the relational operators except for their lower precedence. (Thus a<b == c-ed is 1 whenever a-eb and c-ed have the same truth-value.)
The equality operators follow the same rules as the relational operators, but permit additional possibilities: a pointer may be compared to a constant integral expression with value 0, or to a pointer to void. See §A6.6.
A7.11 Bitwise AND Operator
AND-expression: equality-expression
AND-expression & equality-expression
The usual arithmetic conversions are performed; the result is the bitwise AND function
of the operands. The operator applies only to integral operands.
A7.12 Bitwise Exclusive OR Operator
exclusive-OR-expression: AND-expression
exclusive-OR -expression " AND-expression
The usual arithmetic conversions are performed; the result is the bitwise exclusive OR function of the operands. The operator applies only to integral operands.
A7. 13 Bitwise Inclusive OR Operator
inclusive-OR -expression:
exclusive-OR -expression
inclusive-OR-expression I exclusive-OR-expression
The usual arithmetic conversions are performed; the result is the bitwise inclusive OR function of its operands. The operator applies only to integral operands.
A7.14 Logical AND Operator
logical- AND-expression:
inclusive-OR -expression
logical-AND-expression && inclusive-OR-expression
The && o°perator groups left-to-right. It returns 1 if both its operands compare unequal
to zero,
is evaluated, including all side effects; if it is equal to 0, the value of the expression is 0. Otherwise, the right operand is evaluated, and if it is equal to 0, the expression's value is 0, otherwise 1.
The operands need not have the same type, but each must have arithmetic type or be a pointer. The result is into
otherwise. Unlike &, && guarantees left-to-right evaluation: the first operand

 208 REFERENCE MANUAL A7.15 Logical OR Operator
logical- OR-expression: logical-AND-expression
logical- OR-expression
APPENDIX A
: : logical-AN D-expression
The l l operator grou°ps left-to-right. It returns 1 if either of its operands compares
unequal to zero, and
first operand is evaluated, including all side effects; if it is unequal to 0, the value of the expression is 1. Otherwise, the right operand is evaluated, and if it is unequal to 0, the expression's value is 1, otherwise 0.
The operands need not have the same type, but each must have arithmetic type or be a pointer. The result is into
A7.16 Q)nditional Operator
conditional- expression: logical- OR-expression
logical-OR-expression ? expression: conditional-expression
The first expression is evaluated, including all side effects; if it compares unequal to 0, the result is the value of the second expression, otherwise that of third expression. Only one of the second and third operands is evaluated. If the second and third operands are arithmetic, the usual arithmetic conversions are performed to bring them to a common type,andthatisthetypeoftheresult.Ifbotharevoid,orstructuresorunionsofthe same type, or pointers to objects of the same type°, the result has the common type. If
one is a pointer and the other the constant 0, the theresulthasthattype.Ifoneisapointertovoidandtheotherisanotherpointer,the otherpointerisconvertedtoapointertovoid,andthatisthetypeoftheresult.
In the type comparison for pointers, any type qualifiers (§A8.2) in the type to which the pointer points are insignificant, but the result type inherits qualifiers from both arms of the conditional.
A7~17 Assigl'l1'l9t'tExpressions
There are several assignment operators; all group right-to-Ieft.
assignm ent- expression: conditional- expression
unary- expression assignment- operator assignment- expression assignment-operator: one of
=*=/=%=+=-=«= »= &= 1=
All require an Ivalue as left operand, and the lvalue must be modifiable: it must not be an array, and must not have an incomplete type, or be a function. Also, its type must not be qualified with const; if it is a structure or union, it must not have any member or, recursively, submember qualified with const. The type of an assignment expression is that of its left operand, and the value is the value stored in the left operand after the assignment has taken place.
In the simple assignment with =, the value of the expression replaces that of the object referred to by the lvalue. One of the following must be true: both operands have arithmetic type, in which case the right operand is converted to the type of the left by the assignment; or both operands are structures or unions of the same type; or one
otherwise. Unlike I, I I guarantees left-to-right evaluation: the
is converted to the pointer type, and

 SECTION A7 EXPRESSIONS 209
operandisapointerandtheotherisapointertovoid;ortheleftoperandisapointer and the right operand is a constant expression with value 0; or both operands are pointers to functions or objects whose types are the same except for the possible absence of const or volatile in the right operand.
An expression of the form E1 op = E2 is equivalent to E1 = E1 op (E2) except that E 1 is evaluated only once.
A7.18 Q)nma Operator
expression: assignment-expression
expression, assignment-expression
A pair of expressions separated by a comma is evaluated left-to-right, and the value of the left expression is discarded. The type and value of the result are the type and value of the right operand. All side effects from the evaluation of the left operand are com- pleted before beginning evaluation of the right operand. In contexts where comma is given a special meaning, for example in lists of function arguments (§A7.3.2) and lists of initializers (§A8.7), the required syntactic unit is an assignment expression, so the comma operator appears only in a parenthetical grouping; for example,
f(a, (t=3, t+2), c)
has three arguments, the second of which has the value 5.
A7.19 C4nstart Expressions
Syntactically, a constant expression is an expression restricted to a subset of opera-
tors:
constant- expression: conditional-expression
Expressions that evaluate to a constant are required in several contexts: after case, as array bounds and bit-field lengths, as the value of an enumeration constant, in initializ- ers, and in certain preprocessor expressions.
Constant expressions may not contain assignments, increment or decrement opera- tors, function calls, or comma operators, except in an operand of sizeof. If the con- stant expression is required to be integral, its operands must consist of integer, enumera- tion, character, and floating constants; casts must specify an integral type, and any float- ing constants must be cast to an integer. This necessarily rules out arrays, indirection, address-of, and structure member operations. (However, any operand is permitted for sizeof.)
More latitude is permitted for the constant expressions of initializers; the operands may be any type of constant, and the unary &. operator may be applied to external or static objects, and to external or static arrays subscripted with a constant expression. The unary &. operator can also be applied implicitly by appearance of unsubscripted arrays and functions. Initializers must evaluate either to a constant or to the address of a previously declared external or static object plus or minus a constant.
Less latitude is allowed for the integral constant expressions after #if; sizeof expressions, enumeration constants, and casts are not permitted. See §A12.5.

 210 REFERENCE MANUAL APPENDIX A
AS. Declarations
Declarations specify the interpretation given to each identifier; they do not neces- sarily reserve storage associated with the identifier. Declarations that reserve storage are called definitions. Declarations have the form
declaration:
declaration-specifiers init-declarator-list.g;
The declarators in the init-declarator-list contain the identifiers being declared; the declaration-specifiersconsist of a sequence of type and storage class specifiers.
declaration-specifiers:
storage-class-specifier declaration-specifiers.q, type-specifierdeclaration-specifiersq, type-qualifierdeclaration-specifierss;
init -declarator-list: init -declarator
init-declarator-list , init-declarator
init -declarator: declarator
declarator = initializer
Declarators will be discussed later (§A8.S); they contain the names being declared. A declaration must have at least one declarator, or its type specifier must declare a struc- ture tag, a union tag, or the members of an enumeration; empty declarations are not per- mitted.
A8.1 Storage Class Specifiers
The storage class specifiers are:
storage-class-specifier:
auto register static extern typedef
The meanings of the storage classes were discussed in §A4.
Theautoandregister specifiersgivethedeclaredobjectsautomaticstorage
class, and may be used only within functions. Such declarations also serve as definitions and cause storage to be reserved. A register declaration is equivalent to an auto declaration, but hints that the declared objects will be accessed frequently. Only a few objects are actually placed into registers, and only certain types are eligible; the restric- tionsareimplementation-dependent.However,ifanobjectisdeclaredregister, the unary & operator may not be applied to it, explicitlyor implicitly.
The rule that it is illegal to calculate the address of an object declared register. but actually taken to be auto. is new.
The static specifier gives the declared objects static storage class. and may be used either inside or outside functions. Inside a function, this specifier causes storage to be allocated, and serves as a definition; for its effect outside a function, see §A11.2.
Adeclarationwithextern,usedinsideafunction,specifiesthatthestorageforthe declared objects is defined elsewhere;for its effects outside a function, see §Al1.2.

 SECTION A8 DECLARATIONS 111
The typedef specifier does not reserve storage and is called a storage class specifier only for syntactic convenience;it is discussed in §A8.9.
Atmostonestorageclassspecifiermaybegiveninadeclaration.Ifnoneisgiven, these rules are used: objects declared inside a function are taken to be auto; functions declared within a function are taken to be extern; objects and functions declared out- side a 'function are taken to be static, with external linkage. See§§AIO-All.
AB.2 Type Specifiers The type-specifiersare
type-specifier:
void char short
int
long float double signed unsigned
struct-or-union-specifier enum -specifier typedef-name
At most one of the words long or short may be specified together with int; the meaning is the same if int is not mentioned. The word long may be specifiedtogether with double. At most one of signed or unsigned may be specified together with int or any of its shortor long varieties, or with char. Either may appear alone, in which case int is understood. The signed specifier is useful for forcing char objects to carry a sign; it is permissible but redundant with other integral types.
Otherwise,atmostonetype-specifiermaybegiveninadeclaration.Ifthetype- specifier is missing from a declaration, it is taken to be into
Types may also be qualified, to indicate special properties of the objects being declared.
type-qualifier:
const volatile
Type qualifiers may appear with any type specifier. A const object may be initialized, but not thereafter assigned to. There are no implementation-independentsemantics for
volatile
objects.
The const and volatile properties are new with the ANSI standard. The purpose of conse is to announce objects that may be placed in read-only memory, and perhaps to increase opportunities for optimization. The purpose of volatile is to force an implementation to suppress optimization that could otherwise occur. For. example, for a machine with memory-mapped input/output, a pointer to a device register might be declared as a pointer to volatile, in order to prevent the compiler from removing apparently redun- dant references through the pointer. Except that it should diagnose explicit attemptstochangeconstobjects,acompilermayignorethesequalifiers.

 212 REFERENCE MANUAL APPENDIX A
AS.3 Structure and Union Declarations
A structure is an object consisting of a sequence of named members of various types. A union is an object that contains, at different times, anyone of several members of various types. Structure and union specifiers have the same form.
struct -or-union-specifier:
struct-or-union identifieropt { struct-declaration-list } struct -or-union identifier
struct-or-union:
struct
union
A struct-declaration-list is a sequence of declarations for the members of the structure or union:
struct -declaration -list: struct -declaration
struct -declaration -list struct -declaration
struct -declaration:
specifier-qualifier-list struct -declarator-list
specifier-qualifier-list:
type-specifier specifier-qualifier-listg; type-qualifier specifier-qualifter-listg;
struct -declarator-list: struct -declarator
struct -declarator-list , struct -declarator
Usually, a struct-declarator is just a declarator for a member of a structure or union. A structuremembermayalsoconsistofaspecifiednumberofbits. Suchamemberisalso called a bit-field, or merelyfield; its length is set off from the declarator for the field name by a colon.
struct -declarator: declarator
declaratoropt : constant-expression
A type specifier of the form
struct-or-union identifier { struct-declaration-list }
declares the identifier to be the tag of the structure or union specified by the list. A
subsequent declaration in .the .same or an inner scope may refer to the same type by using the tag in a specifier without the list:
struct -or-union identifier
If a specifier with a tag but without a list appears when.the tag is not declared, an incomplete type is specified. Objects with an incomplete structure or union type may be mentioned in contexts where their size is not needed, for example in declarations (not definitions),forspecifyingapointer,orforcreatinga typede£, butnototherwise. The type becomes complete on occurrence of a subsequent specifier with that tag, and con- taining a declaration list. Even in specifiers with a list, the structure or union type being declared is incomplete within the list, and becomes complete only at the } terminating the specifier.
A structure may not contain a member of incomplete type. Therefore, it is impossi- ble to declare a structure or union containing an instance of itself. However, besides

 SECTION A8 DECLARATIONS 213
givmg a name to the structure or union type, tags allow definition of self-referential structures; a structure or union may contain a pointer to an instance of itself, because pointers to incomplete types may be declared.
A very special rule applies to declarations of the form
struct-or-union identifier ;
that declare a structure or union, but have no declaration list and no declarators. Even if the identifier is a structure or union tag already declared in an outer scope (§All.1), this declaration makes the identifier the tag of anew, incompletely-typed structure or union in the current scope.
This recondite rule is new with ANSI. It is intended to deal with mutually- recursive structures declared in an inner scope, but whose tags might already be declared in the outer scope.
A structure or union specifier with a list but no tag creates a unique type; it can be referred to directly only in the declaration of which it is a part.
The names of members and tags do not conflict with each other or' with ordinary variables. A member name may not appear twice in the same structure or union, but the same member name. may be used in different structures or unions.
In the first edition of this book, the names of structure and union members were not associated with their parent. However, this association became common in compilers well before the ANSI standard.
A non-field member of a structure or union may have any object type. A field member (which need not have a declarator and thus may be unnamed) has type int, unsigned int, or signed int, and is interpreted as an object of integral type of the specified length in bits; whether an int field is treated as signed is implementation- dependent. Adjacent field members of structures are packed into implementation- dependent storage units in an implementation-dependent direction. When a field follow- ing another field will not fit into a partially-filled storage unit, it may be split between units, or the unit may be padded. An unnamed field with width 0 forces this padding, so that the next field will begin at the edge of the next allocation unit.
The ANSI. standard makes fields even more implementation-dependent than did the fi.r~t.~ditioJl. It is advisable to read the language rules for storing bit-fields as "i~pleRl~nt~tioo-dependent" without qIJalificati9n. Structures with bit-fields may be used as a portable way of attempting to reduce the storage required for a structure (with the probable cost of increasing the instruction space, and time, needed to access the fields), or as a non-portable way to describe a storage lay- out known at the bit level. In the second case, it is necessary to understand the rules of the local implementation.
The members of a structure have addresses increasing in the order of their declara- tions. A non-field member of a structure is aligned at an addressing boundary depend- ing on its type; therefore, there may be unnamed holes in a structure. If a pointer to a structure is cast to the type of a pointer to its first member, the result refers to the first member.
A union may be thought of as a structure all of whose members begin at offset 0 and whose size is sufficient to contain any of its members. At most one of the members can be stored in a union at any time. If a pointer to a union is cast to the type of a pointer to a member, the result refers to that member.
A simple example of a structure declaration is

 214 REFERENCE MANUAL
APPENDIX A
struct tnode { char tword[20];
int count;
struct tnode *left; struct tnode *right;
};
which contains an array of 20 characters, an iriteger, and two pointers to similar struc-
tures, Once this declaration has been given, the declaration
struct tnode s, *sp;
declares s to be a structure of the given sort and spto be a pointer to a structure of the given sort. With these declarations, the expression
sp->count
refers to the count field of the structure to which sp points;
s.left
refers to the left subtree pointer of the structure s; and s.r!ght->tword[O]
refers to the first character of the. tword member of the right subtree of s.
In general, a member of a union may riot be inspected unless the value of the union has been assigned using that same member. However, one special guarantee simplifies the use of unions: if a union contains several structures that share a common initial sequence, and if the union currently contains one of these structures, it is permitted to refer to the common initial part of any of the contained structures. For example, the
following is a legal fragment:
union { struct {
int type; }n;
struct {
int type;
int intnode; } ni;
struct {
int type;
float floatnode; } nf;
} u;
u.nf.type =FLOAT; u.nf.floatnode =3.14;
if (u.~.type ==FLOAT) ...sin(u.nf.floatnode)
AS.4 Enumeration.
Enumerations are unique types with values ranging over a set of named constants called enumerators. The form of an enumeration specifier borrows from that of struc- tures and unions.

 SECTION A8
DECLARATIONS 215
enum -specifler:
enum identifieropt { enumerator-list} enum identifier
enumerator-list: enumerator
enumerator-list , enumerator
enumerator: identifier
identifier = constant-expression
The identifiers in an enumerator list are declared as constants of type int, and may appear wherever constants are required. If no enumerators with =appear, then the values of the corresponding constants begin at 0 and increase by 1 as the declaration is read from left to right. An enumerator with = gives the associated identifier the value specified; subsequent identifiers continue the progression from the assigned value.
Enumerator names in the same scope must all be distinct from each other and from ordinary variable names, but the values need not be distinct.
The role of the identifier in the enum-specifier is analogous to that of the structure tag in a struct-specifier; it names a particular enumeration. The rules for enum- specifiers with and without tags and lists are the same as those for structure or union specifiers, except that incomplete enumeration types do not exist; the tag of an enum- specifier without an enumerator list must refer to an in-scope specifier with a list.
Enumerations are new since the first edition of this book, but have been part of the language for some years.
A8.5 Declarator8
Declarators have the syntax:
declarator:
pointer optdirect -declarator
direct -declarator: identifier
( declarator )
direct-declarator [ constant-expressionopt direct -declarator ( parameter-type-list direct-declarator ( identifier-listopt )
pointer:
* type-qualifier-listopt
*type-qualtfter-listi., pointer
type-qualifier-list: type-qualifier
type-qualifier-list type-qualifier
] )
The structure of declarators resembles that of. indirection, function, and array expres- sions; the grouping is the same.

 216 REFERENCE MANUAL APPENDIX A
A8.8 Meaning of Deelaratora
A list of declarators appears after a sequence of type and storage class specifiers. Each declarator declares a unique main identifier, the one that appears as the first alter- native of the production for direct-declarator. The storage class specifiers apply directly to this identifier, but its type depends on the form of its declarator. A declarator is read as an assertion that when its identifier appears in an expression of the same form as the declarator, it yields an object of the specified type.
Considering only the type parts of the declaration specifiers (§A8.2) and a particular declarator, a declaration has the form "T D," where T is a type and 0 is a declarator. The type attributed to the identifier in the various forms of declarator is described inductively using this notation.
In a declaration T 0 where 0 is an unadorned identifier, the type of the identifier is T.
In a declaration T D where 0 has the form ( 01 )
then the type of the identifier in 01 is the same as that of n The parentheses do not alter the type, but may change the binding of complex declarators.
A8.8.1 Pointer Deelaratora
In a declaration T D where 0 has the form * type-qualifier-Iistopt 0 1
and the type of the identifier in the declaration T 01 is "type-modifier T," the type of the identifier of 0 is "type-modifier type-qualifier-list pointer to T." Qualifiers follow- ing * apply to pointer itself, rather than to the object to which the pointer points.
For example, consider the declaration int *ap[];
Here ap[] plays the role of 01; a declaration "int ap[]" (below) would give ap the type "array of int," the type-qualifier list is empty, and the type-modifier is "array of." Hence the actual declaration gives ap the type "array of pointers to int."
eonst int ei =3, *pei;
declare an integer i and a pointer to an integer pi. The value of the constant pointer epimaynotbechanged;itwillalwayspointtothesamelocation,althoughthevalueto whichitrefersmaybealtered.Theintegereiisconstant,andmaynotbechanged
(though it may be initialized, as here.) The type of pei is "pointer to eonst int," andpeiitselfmaybechangedtopointtoanotherplace,butthevaluetowhichitpoints may not be altered by assigning through pcd,
A8.8.2 Array Deelaratora
In a declaration T 0 where 0 has the form 01 [constant-expressionop]t
and the type of the identifier in the declaration T D1 is "type-modifier T," the type of the identifier of 0 is "type-modifier array of T." If the constant-expression is present, it must have integral type, and value greater than o. If the constant expression specifying
As other examples, the declarations
int i, *pi, *eonstepi =&ij

 SECTION A8 DECLARATIONS 217
the bound is missing, the array has an incomplete type.
An array may be constructed from an arithmetic type, from a pointer, from a struc-
ture or union, or from another array (to generate a multi-dimensionalarray). Any type from which an array is constructed must be complete; it must not be an array or struc- ture of incomplete type. This implies that for a multi-dimensional array, only the first dimension may be missing. The type of an object of incomplete array type is completed by another, complete, declaration for the object (§AlO.2), or by initializing it (§A8.7). For example,
float fa[17], declares an array of float
*afp[17];
numbers and an array of pointers to float numbers. Also,
static int x3d[3][S][7];
declares a static three-dimensional array of integers, with rank 3x5x7. In complete detail, x3d is an array of three items; each item is an array of five arrays; each of the latter arrays is an array of seven integers. Any of the expressions x3d, x3d [ i ], x3d[i][j],x3d[i][j][k]mayreasonablyappearinanexpression.Thefirstthree havetype"array,"thelasthastypeinto Morespecifically,x3d[i][j] isanarrayof 7 integers, and x3d [ i] is an array of 5 arrays of 7 integers.
The array subscripting operation is defined so that E 1 [E2 ] is identical to * (E 1+E2). Therefore, despite its asymmetric appearance, subscripting is a commuta- tive operation. Because of the conversion rules that apply to + and to arrays (§§A6.6,
A7.1, A7.7), if E1 is an array and E2 an integer, then E1[E2] refers to the E2-th member of E1.
In the example, x3d [i ][j ] [k] is equivalent to *(x3d [i ][j] + k). The first subexpressionx3d[i][j] isconvertedby§A7.1totype"pointertoarrayofintegers;" by §A7.7, the addition involvesmultiplication by the size of an integer. It followsfrom the rules that arrays are stored by rows (last subscript varies fastest) and that the first subscript in the declaration helps determine the amount of storage consumed by an array, but plays no other part in subscript calculations.
A8.6.3 Function Declarators
In a new-style function declaration T D where D has the form D 1 tparameter-type-ltst )
and the type of the identifier in the declaration T D1 is "type-modifier T," the type of
the identifier of D is "type-modifier returning T."
The syntax of the parameters is
parameter-type-list: parameter-list
parameter-list ,
parameter-list: parameter-declaration
function with arguments parameter-type-list
parameter-list , parameter-declaration
parameter-declaration:
declaration-specifiers declarator declaration-specifiers abstract -declarator opt
In the new-styledeclaration, the parameter list specifiesthe types of the parameters. As

 218 REFERENCE MANUAL APPENDIX A
a special case, the declarator for a new-style function with no parameters has a parame- tertypelistconsistingsolelyofthekeywordvoid.Iftheparametertypelistendswith an ellipsis ", ••• ", then the function may accept more arguments than the number of parameters explicitly described; see §A7.3.2.
The types of parameters that are arrays or functions are altered to pointers, in accordance with the rules for parameter conversions;see §A10.1. The only storage class specifier permitted in a parameter's declaration specifier is register,and this specifier is ignored unless the function declarator heads a function definition. Similarly, if the declarators in the parameter declarations contain identifiers and the function declarator does not head a function definition, the identifiers go out of scope immediately. Abstract declarators, which do not mention the identifiers, are discussed in §AS.S.
In an old-style function declaration T 0 where 0 has the form 01 (identifier-listopt)
and the type of the identifier in the declaration T 01 is "type-modifier T," the type of theidentifierof0is"type-modifierfunctionofunspecifiedargumentsreturningT." The parameters (if present) have the form
identifier-list: identifier
identifier-list , identifier
In the old-style declarator, the identifier list must be absent unless the declarator is used in the head of a function definition (§AIO.l). No information about the types of the parameters is supplied by the declaration.
For example, the declaration
int f(), *fpi()i (*pfi)();
declares a function f returning an integer, a function fpi returning a pointer to an
integer, and a pointer pfi to a function returning an integer. In none of these are the parameter types specified; they are old-style.
In the new-styledeclaration
int strcpy(char *dest, const char *source), rand(void);
strcpy is a function returning int,with two arguments, the first a character pointer, and the second a pointer to constant characters. The parameter names are effectively comments. The second function rand takes no arguments and returns into
AS.7 Initialization
Function declarators with parameter prototypes are, by far, the most important language change introduced by the ANSI standard. They offer an advantage over the "old-style" declarators of the first edition by providing error-detection and coercion of arguments across function calls, but at a cost: turmoil and con- fusion during their introduction, and the necessity of accommodating both forms. Some syntactic ugliness was required for the sake of compatibility, namely void as an explicit marker of new-style functions without parameters.
The ellipsis notation .. , ••. " for variadic functions is also new, and, together with the macros in the standard header <stdarg. h>, formalizes a mechanism that was officially forbidden but unofficially condoned in the first edition.
These notations were adapted from the C++ language.
When an object is declared, its init-declarator may specify an initial value for the identifier being declared. The initializer is preceded by =, and is either an expression,or a list of initializers nested in braces. A list may end with a comma, a nicety for neat

 SECTION AS
DECLARATIONS 219
formatting.
initializer:
assignment -expression
{ initializer-Iist { initializer-list,
inuialtzer-list: initializer
initializer-Iist
}
}
, initializer
All the expressionsin the initializer for a static object or array must be constant expressionsas described in §A7.19. The expressionsin the initializer for an auto or register object or array must likewisebe constant expressionsif the initializer is a brace-enclosedlist. However,iftheinitializerforanautomaticobjectisasingleexpres- sion, it need not be a constant expression, but must merely have appropriate type for assignment to the object.
The first edition did not countenance initialization of automatic structures, unions, or arrays. The ANSI standard allows it, but only by constant construc- tions unless the initializer can be expressed by a simple expression.
A static object not explicitly initialized is initialized as if it (or its members) were assigned the constant O. The initial value of an automatic object not explicitly initialized is undefined.
The initializer for a pointer or an object of arithmetic type is a single expression, perhapsinbraces. Theexpressionisassignedtotheobject.
The initializer for a structure is either an expressionof the same type, or a brace- enclosed list of initializers for its members in order. Unnamed bit-field members are ignored,andarenotinitialized.Iftherearefewerinitializersinthelistthanmembers of the structure, the trailing members are initialized with o. There may not be more ini- tializers than members.
Theinitializerforanarrayisabrace-enclosedlistofinitializersforitsmembers.If the array has unknown size, the number of initializers determines the size of the array, anditstypebecomescomplete.Ifthearrayhasfixedsize,thenumberofinitializers may not exceed the number of members of the array; if there are fewer, the trailing members are initialized with O.
As a special case, a character array may be initialized by a string literal; successive characters of the string initialize successive members of the array. Similarly, a wide character literal (§A2.6) may initialize an array of type wchar_t. If the array has unknown size, the number of characters in the string, including the terminating null character, determines its size; if its size is fixed, the number of characters in the string, not counting the terminating null character, must not exceed the size of the array.
The initializer for a union is either a single expression of the same type, or a brace- enclosed initializer for the first member of the union.
The first edition did not allow initialization of unions. The "first-member" rule is clumsy, but is hard to generalize without new syntax. Besides allowing unions to be explicitly initialized in at least a primitive way, this ANSI rule makes definite the semantics of static unions not explicitly initialized.
Anaggregate isastructureorarray. Ifanaggregatecontainsmembersofaggregate type, the initialization rules apply recursively. Braces may be elided in the initialization as follows:if the initializer for an aggregate's member that is itself an aggregate begins with a left brace, then the succeeding comma-separated list of initializers initializes the

 220 REFERENCE MANUAL APPENDIX A
members of the subaggregate; it is erroneous for there to be more initializers than members. If, however, the initializer for a subaggregate does not begin with a left brace, then only enough elements from the list are taken to account for the members of the subaggregate; any remaining members are left to initialize the next member of the aggregate of which the subaggregate is a part.
For example,
intx[]= {1,3,5};
declares and initializes x as a l-dimensional array with three members, since no size was specified and there are three initializers.
float y[4][3]= { { 1, 3, 5 },
{ 2, 4, 6 },
{ 3, 5, 7 }, };
is a completely-bracketed initialization: I, 3, and 5 initialize the first row of the array y[0], namely y[0] [0], y[0] [ 1], and y[0] [2]. Likewise the next two lines initial- ize y[1]and y[2 J. The Initializer ends early, and therefore the elements of y[3]are initialized with O. Precisely the same effect could have been achieved by
float y[4][3]= {
1, 3, 5, 2, 4, 6, 3, 5, 7 };
The initializer for y begins with a left brace, but that for y [ 0] does not; therefore three elements from the list are used. Likewise the next three are taken successively for y [ 1 ] and then for y [ 2 ] . Also,
float y[4][3]= {
{1}, {2}, {3}, {4} };
initializes the first column of y (regarded as a two-dimensional array) and leaves the rest O.
Finally,
char msg[] ="Syntax error on line "s\n";
shows a character array whose members are initialized with a string; its size includes the terminating null character,
A8.8 Type Name.
In several contexts (to specify type conversions explicitly with a cast, to declare parameter types in function declarators, and as an argument of sizeof)it is necessary to supply the name of a data type. This is accomplished using a type name, which is syntactically a declaration for an object of that type omitting the name of the object.
type-name:
specifier-qualifier-list abstract -declarator opt
abstract -declarator: pointer
pointer opt direct -abstract -declarator

 SECTION A8
DECLARATIONS 221
direct -abstract -declarator:
( abstract -declarator )
direct -abstract -declarator opt [ direct-abstract-declaratoropt
constant -expressionopt ] parameter-type-list g. )
Itispossibletoidentifyuniquelythelocationintheabstract-declaratorwheretheidenti- fier would appear if the construction were a declarator in a declaration. The named type is then the same as the type of the hypothetical identifier. For example,
int
int *
int *[3]
int (*)[]
int *()
int (*[])(void)
name respectively the types "integer," "pointer to integer," "array of 3 pointers to integers," "pointer to an array of an unspecified number of integers," "function of unspecified parameters returning pointer to integer," and "array, of unspecified size, of pointers to functions with no parameters each returning an integer."
A8.9 Typedef
Declarations whose storage class specifier is typede£ do not declare objects; instead they define identifiers that name types. These identifiers are called typedef names.
typedef-name: identifier
A typedef declaration attributes a type to each name among its declarators in the usual way (see .8.6). Thereafter, each such typedef name is syntactically equivalent to a type specifier keyword for the associated type.
For example, after
typedef long Blockno, *Blockptr;
typedef struct { double r, theta; } Complex;
the constructions
Blockno b;
extern Blockptr bp; Complex z, *zp;
are legal declarations. The type of b is long,that of bp is "pointer to long,"and that of z is the specified structure; zp is a pointer to such a structure.
typedef does not introduce new types, only synonymsfor types that could be speci- fied in another way. In the example, b has the same type as any other long object.
Typedef names may be redeclared in an inner scope, but a non-empty set of type specifiersmustbegiven. Forexample,
extern Blockno; does not redeclare Blockno,but
extern int Blockno;
does.
A8.10 Type Equivalence
Two type specifier lists are equivalent if they contain the same set of type specifiers, taking into account that some specifiers can be implied by others (for example, long

 222 REFERENCE MANUAL APPENDIX A
aloneimplieslongint). Structures,unions,andenumerationswithdifferenttagsare distinct, and a tagless union, structure, or enumeration specifies a unique type.
Two types are the same if their abstract declarators (§A8.8), after expanding any typedef types, and deleting any function parameter identifiers, are the same up to equivalence of type specifier lists. Array sizes and function parameter types are signifi- cant.
A9. Statements
Except as described, statements are executed in sequence. Statements are executed for their effect, and do not have values. They fall into several groups.
statement: labeled-statement
expression-statement compound-statement selection-statement iteration-statement
jump-statement
A9.1 Labeled Statements
Statements may carry label prefixes.
labeled-statement:
identifier : statement
case constant-expression: statement default : statement
A label consisting of an identifier declares the identifier. The only use of an identifier labelisasatargetofqoto. Thescopeoftheidentifieristhecurrentfunction.Because labels have their own name space; they do not interfere with other identifiers and cannot be redeclared. See §AII.I.
Caselabelsanddefaultlabelsareusedwiththeswitchstatement(§A9.4).The constantexpressionofcase musthaveintegraltype.
Labels in themselvesdo not alter the flowof control.
A9.2 Expression Statement
Most statements are expressionstatements, which have the form
expression-statement: expressionopt ;
Most expression statements are assignments or function calls. All side effects from the expression are completed before the next statement is executed. If the expression is missing, the construction is called a null statement; it is often used to supply an empty body to an iteration statement or to place a label.
A9.3 CompoundStatement
So that several statements can be used where one is expected, the compound state- ment (also called "block") is provided. The body of a function definition is a compound statement.

 SECTION A9
STATEMENTS 223
compound-statement:
{ declaration-listoP1 statement -listopt }
declaration-list: declaration
declaration-list declaration
statement -list: statement
statement-list statement
Ifanidentifierinthedeclaration-listwasinscopeoutsidetheblock,theouterdeclara- tion is suspended within the block (see §A11.l), after which it resumes its force. An identifier may be declared only once in the same block. These rules apply to identifiers in the same name space (§AIl); identifiers in different name spaces are treated as dis- tinct.
Initialization of automatic objects is performed each time the block is entered at the top,andproceedsintheorderofthedeclarators.Ifajumpintotheblockisexecuted,
these initializations are not performed. Initializations of static only once, before the program begins execution.
A9.4 Selection Statementa
Selection statements choose one of several flows of control.
selection-statement:
if (expression) statement
if (expression) statement else statement swi tch ( expression ) statement
objects are performed
In both forms of the if statement, the expression, which must have arithmetic or pointer type, is evaluated, including all side-effects, and if it compares unequal to 0, the first substatement is executed. In the second form, the second substatement is executed if the expression is O. The else ambiguity is resolved by connecting an else with the last encountered else-less if at the same block nesting level.
The switch statement causes control to be transferred to one of several statements depending on the value of an expression, which must have integral type. The substate- ment controlled by a switch is typically compound. Any statement within the sub- statement may be labeled with one or more case labels (§A9.l). The controlling expression undergoes integral promotion (§A6.1), and the case constants are converted to the promoted type. No two of the case constants associated with the same switch may have the same value after conversion. There may also be at most one default label associated with a switch. Switches may be nested; a case or def aul t label is associ- ated with the smallest switch that contains it.
When the switch statement is executed, its expression is evaluated, including all sideeffects,andcomparedwitheachcaseconstant. Ifoneofthecaseconstantsisequal to the value of the expression, control passes to the statement of the matched case label. If no case constant matches the expression,and if there is a def aul t label, con- trol passes to the labeled statement. If no case matches, and if there is no default, then none of the substatements of the switch is executed.
In the first edition of this book, the controlling expression of switch, and the caseconstants,wererequiredtohaveinttype.

 114 REFERENCE MANUAL
APPENDIX A
A9.S Iteration Statements
Iteration statements specify looping.
iteration-statement:
while (expression) statement
do statement while (expression)
for (expressionopt ; expressionopt ; expressionopt ) statement
Inthewhileanddostatements,thesubstatementisexecutedrepeatedlysolongas the value of the expression remains unequal to 0; the expression must have arithmetic or pointertype. Withwhile,thetest,includingallsideeffectsfromtheexpression,occurs beforeeachexecutionofthestatement;withdo,thetestfollowseachiteration.
Intheforstatement,thefirstexpressionisevaluatedonce,andthusspecifiesini- tialization for the loop. There is no restriction on its type. The second expression must have arithmetic or pointer type; it is evaluated before each iteration, and if it becomes equal to 0, the for is terminated. The third expressionis evaluated after each iteration, and thus specifies a re-initialization for the loop. There is no restriction on its type. Side-effectsfromeachexpressionarecompletedimmediatelyafteritsevaluation.Ifthe substatementdoesnotcontaincontinue,astatement
for (expression] ; expressionl ; expression] ) statement is equivalent to
expression] ;
whi1e (expression2) {
statement
expression] ;
}
Any of the three expressions may be dropped. A missing second expression makes the implied test equivalent to testing a non-zero constant.
A9.e JumpStatements
Jump statements transfer control unconditionally.
jump-statement:
qoto identifier ;
continue ;
break ;
return expressionopt
In the qoto statement, the identifier must be a label (§A9.1) located in the current function. Control transfers to the labeled statement.
A continue statement may appear only within an iteration statement. It causes control to pass to the loop-continuation portion of the smallest enclosing such statement. More precisely, within each of the statements
while (•.. ) {
contin: ; }
do { contin: ,
}while (....);
for (... ) {
contin: ; }
a continue not contained in a smaller iteration statement is the same as qoto contino
Abreakstatementmayappearonlyinaniterationstatementoraswitchstate- ment, and terminates execution of the smallest enclosing such statement; control passes
;

 SECTION AIO EXTERNAL DECLARATIONS 225
to the statement followingthe terminated statement.
A function returns to its caller-bythe return statement. When return is followed
by an expression,the value is returned to the caller of the function. The expressionis converted, as if by assignment, to the type returned by the function in which it appears.
Flowing off the end of a function is equivalent to a return with no expression. In either case, the returned value is undefined.
A10. External Declarations
The unit of input provided to the C compiler is called a translation unit; it consists of a sequence of external declarations, which are either declarations or function definitions.
translation-unit: external-declaration
translation- unit external-declaration
external-declaration: function-definition
declaration
The scope of external declarations persists to the end of the translation unit in which they are declared, just as the effect of declarations within blocks persists to the end of the block. The syntax of external declarations is the same as that of all declarations, except that only at this level may the code for functions be given.
A10.1 Function Definitiona
Function definitions have the form
function-definition:
declaration-specijiersopt declarator declaration-list.g, compound -statement
Theonlystorage-classspecifiersallowedamongthedeclarationspecifiersareexternor static; see§AI1.2forthedistinctionbetweenthem.
A function may return an arithmetic type, a structure, a union, a pointer, or void, but not a function or an array. The declarator in a function declaration must specify explicitly that the declared identifier has function type; that is, it must contain one of the forms (see §A8.6.3)
direct-declarator ( parameter-type-list ) direct-declarator ( identijier-listopt )
where the direct-declarator is an identifier or a parenthesized identifier. In particular, it must not achieve function type by means of a typedef.
In the first form, the definition is a new-style function, and its parameters, together with their types, are declared in its parameter type list; the declaration-list followingthe function's declarator must be absent. Unless the parameter type list consists solely of void, showingthat the function takes no parameters, each declarator in the parameter type list must contain an identifier. If the parameter type list ends with ", ••• " then the function may be called with more arguments than parameters; the va_arg macro mechanismdefinedinthestandardheader<stdarg.h>anddescribedinAppendixB must be used to refer to the extra arguments. Variadic functions must have at least one named parameter.
In the second form, the definition is old-style: the identifier list names the

 226 REFERENCE MANUAL APPENDIX A
parameters, whilethe declaration list attributes types to them. If no declaration is given for a parameter, its type is taken to be into The declaration list must declare only parameters named in the list, initialization is not permitted, and the only storage-class specifierpossibleis register.
In both styles of function definition, the parameters are understood to be declared just after the beginning of the compound statement constituting the function's body, and thus the same identifiers must not be redeclared there (although they may, like other identifiers, be redeclared in inner blocks). If a parameter is declared to have type "array of type," the declaration is adjusted to read "pointer to type;" similarly, if a
parameter is declared to have type "function returning type," the declaration is adjusted to read "pointer to function returning type." During the call to a function, the argu- ments are converted as necessary and assigned to the parameters; see §A7.3.2.
New-style function definitions are new with the ANSI standard. There is also a small change in the details of promotion; the first edition specified that the declarations of float parameters were adjusted to read double. The differ- ence becomes noticeable when a pointer to a parameter is generated within a function.
A complete example of a new-style function definition is
int max(int a, int b, int c) {
int m;
m=(a>b) ?a:b;
return (m > c) ? m : c; }
Hereint isthedeclarationspecifier;max(int a, int b, int c) isthefunction's declarator, and { ••• } is the block giving the code for the function. The correspond- ing old-style definition would be
int max(a,b,c) int a, b, c;
{
}
wherenowintmax(a,b,c)isthedeclarator,andinta,b,c;isthedeclara- tion list for the parameters.
A 10.2 External Declaration8
External declarations specify the characteristics of objects, functions and other iden- tifiers. The term "external" refers to their location outside functions, and is not directly connectedwiththeexternkeyword;thestorageclassforanexternally-declaredobject may be left empty, or it may be specifiedas extern or static.
Several external declarations for the same identifier may exist within the same trans- lation unit if they agree in type and linkage, and if there is at most one definition for the identifier.
Two declarations for an object or function are deemed to agree in type under the rules discussed in §AS.IO. In addition, if the declarations differ because one type is an incomplete structure, union, or enumeration type (§A8.3) and the other is the corresponding completed type with the same tag, the types. are taken to agree. More- over, if one type is an incomplete array type (§AS.6.2) and the other is a completed

 SECTION All SCOPE AND LINKAGE l'J,7
array type, the types, if otherwise identical, are also taken to agree. Finally, if one type specifies an old-style function, and the other an otherwise identical new-style function, with parameter declarations, the types are taken to agree.
If the first external declaration for a function or object includes the static speci- fier, the identifier has internal linkage; otherwise it has external linkage. Linkage is discussed in §A11.2.
An external declaration for an object is a definition if it has an iriitializer. An exter- nal object declaration that does not have an initializer, and does not contain the extern specifier, is a tentative definition. If a definition for an object appears in a translation unit, any tentative definitions are treated merely as redundant declarations, If no defini- tion for the object appears in the translation unit, all its tentative definitions become a single definition with initializer O.
Each object must have exactly one definition. For objects with internal linkage, this rule applies' separately to each translation unit, because internally-linked objects are uniqueto a translation unit. For objects with external linkage, it applies to the entire program.
Although the one-definition rule is formulated somewhat differently in the first edition of this book, it is in' effect identical to the one 'Stated here. Some imple- mentations relax it by generalizing the notion of tentative definition. In the alternate formulation, which is usual in UNIX systems and recognized as a com- mon extension by the Standard, all the tentative definitions for an externally- linked object, throughout all the translation units of a program, are considered together instead of in each' translation unit separately. If a definition occurs somewhere in. the program, then the' tentative definitions become merely declarations,' but if no definition appears, then all its tentative definitions become a definition with initializer O.
A11. Scope and Linkage
A program need not all be compiled at one time: the source text may be kept in several files containing translation units, and precompiled routines may be loaded from libraries. Communication among the functions of a program may be carried out both through calls and through manipulation of external data.
Therefore, there' are two kinds of scope to consider: first, the lexical scope of an identifier, which is the region of the program text within which the identifier's charac- teristics are understood; and second, the scope associated with objects and functions with external linkage, which determines the connections between identifiers in separately com- piled translation units.
A11.1 Lexical Scope
Identifiers fall into several name spaces thai do not interfere with one another; the same identifier may be used for different purposes, even in the same scope, if the uses are in different name spaces. These classes are: objects, functions, typedef names, and enwn constants; labels; tags of structures, unions, and enumerations; and members of each structure or union individually.
These rules differ in several ways from those described in the first edition of this manual. Labels did not previously have their own name space; tags of structures and unions each had a separate space, and in some implementations

 118 REFERENCE MANUAL APPENDIX A
enumeration tags did as well; putting different kinds of tags into the same space is a new restriction. The most important departure from the first edition is that each structure or union creates a separate. name space for its members, so that the same name may appear in several different structures. This rule has been common practice for several years.
The lexical scope of an object or function identifier in an external declaration begins at the end of its declarator and persists to the end of the translation unit in which it appears. The scope of a parameter of a function definition begins at the start of the block defining the function, and persists through the function; the scope of a parameter in a function declaration ends at the end of the declarator. The scope of an identifier declared at the head of a block begins at the end of its declarator, and persists to the end of the block. The scope of a label is the whole of the function in which it appears. The scope of a structure, union, or enumeration tag, or an enumeration constant, begins at its appearance in a type specifier, and persists to the end of the translation unit (for declarations at the external level) or to the end of the block (for declarations within a function).
If an identifier is explicitly declared at the head of a block, including the block con- stituting a function, any declaration of the identifier outside the block is suspended until the end of the block.
A11.2 Linkage
Within a translation unit, all declarations of the same object or function identifier with internal linkage refer to the same thing, and the object or function is unique to that translation unit. All declarations for the same object or function identifier with external linkage refer to the same thing, and the object or function is shared by the entire pro- gram.
As discussed in §A10.2, the first external declaration for an identifier gives the iden- tifierinternallinkageif.thestatic specifierisused,externallinkageotherwise.Ifa declarationforanidentifierwithinablockdoesnotincludetheexternspecifier,then theidentifierhasnolinkageandisuniquetothefunction.Ifitdoesincludeextern, and an external declaration for the identifier is active in the scope surrounding the block, then the identifier has the same linkage as the external declaration, and refers to the same object or function; but if no external declaration is visible, its linkage is external.
A12. Preprocessing
A preprocessor performs macro substitution, conditional compilation, and inclusion of named files. Lines beginning with I, perhaps preceded by white space, communicate with this preprocessor. The syntax of these lines is independent of the rest of the language; they. may appear anywhere and have effect that lasts (independent of scope) until the end of the translation unit. Line boundaries are significant; each line is analyzed individually (but see §A12.2 for how to adjoin lines). To the preprocessor, a token is any language token, or a character sequence giving a file name as in the linclude directive(§A12.4);inaddition,anycharacternototherwisedefinedistaken as a token. However,the effect of white space characters other than space and horizon- tal tab is undefined within preprocessorlines.
Preprocessing itself takes place in several logically successive phases that may, in a

 SECTION Al2 PREPROCESSING 229 particular implementation, be condensed.
1. First, trigraph sequences as described in §A12.1 are replaced by their equivalents. Should the operating system environment require it, newline characters are intro- duced between the lines of the source file.
2. Each occurrence of a backslash character \ followed by a newline is deleted, thus splicing lines (§AI2.2).
3. The program is split into tokens separated by white-space characters; comments are replaced by a single space. Then preprocessing directives are obeyed, and macros (§§AI2.3-AI2.10) are expanded.
4. Escape sequences in character constants and string literals (§§A2.5.2, A2.6) are replaced by their equivalents;then adjacent string literals are concatenated.
5. The result is translated, then linked together with other programs and libraries, by collecting the necessary programs and data, and connecting external function and object references to their definitions.
A12.1 Trigraph Sequences
The character set of C source programs is contained within seven-bit ASCII, but is a superset of the ISO 646-1983 Invariant Code Set. In order to enable programs to be represented in the reduced set, all occurrences of the following trigraph sequences are replaced by the corresponding single character. This replacement occurs before any other processing.
??= # ??( ??< { ??I \ ??) ??> } ??' ??I ??-
No other such replacements occur.
Trigraph sequences are new with the ANSI standard.
A12.2 Line Splicing
Lines that end with the backslash character \ are folded by deleting the backslash andthefollowingnewlinecharacter. Thisoccursbeforedivisionintotokens.
A12.3 Macro I\)efinitionand Expansion
A control line of the form
# define identifier token-sequence
causes the preprocessor to replace subsequent instances of the identifier with the given sequence of tokens; leading and trailing white space around the token sequence is dis- carded. Asecond#define forthesameidentifieriserroneousunlessthesecondtoken sequence is identical to the first, where all white space separations are taken to be equivalent.
A line of the form
# define identifier( identifier-list) token-sequence
where there is no space between the first identifier and the (, is a macro definition with parameters given by the identifier list. As with the first form, leading and trailing white space around the token sequence is discarded, and the macro may be redefined only with

 230 REFERENCE MANUAL APPENDIX A
a definition in which the number and spelling of parameters, and the token sequence, is identical.
A control line of the form
# undef identifier
causes the identifier's preprocessor definition to be forgotten. It is not erroneous to apply lundef to an unknown identifier.
When a macro has been defined in the second form, subsequent textual instances of the macro identifier followed by optional white space, and then by (, a sequence of tokens separated by commas, and a ) constitute a call of the macro. The arguments of the call are the comma-separated token sequences; commas that are quoted or protected by nested parentheses do not separate arguments. During collection, arguments are not macro-expanded. The number of arguments in the call must match the number of parameters in the definition. After the arguments are isolated, leading and trailing white space is removed from them. Then the token sequence resulting from each argu- ment is substituted for each unquoted occurrence of the corresponding parameter's iden- tifier in the replacement token sequence of the macro. Unless the parameter in the replacement sequence is preceded by #,or preceded or followed by ##,the argument tokens are examined for macro calls, and expanded as necessary,just before insertion.
Two special operators influence the replacement process. First, if an occurrence of a parameter in the replacement token sequence is immediately preceded by #, string quotes (n) are placed around the correspondingparameter, and then both the # and the parameter identifier are replaced by the quoted argument. A \ character is inserted before each "or \ character that appears surrounding, or inside, a string literal or char- acter constant in the argument.
Second, if the definition token sequence for either kind of macro contains a ## operator, then just after replacement of the parameters, each ## is deleted, together with any white space on either side, so as to concatenate the adjacent tokens and form a new token. The.effect is undefined if invalid tokens are produced, or if the result depends on the order of processingof the ## operators. Also, ## may not appear at the beginning or .end of a replacement token sequence.
In both kinds of macro, the replacement token sequence is repeatedly rescanned for more defined identifiers. However, once a given identifier has been replaced in a given expansion, it is not replaced if it turns up again during rescanning; instead it is left unchallged.
Even if the final value of a macro expansion begins with #, it is not taken to be a preprocessingdirective.
The details of the macro-expansion process are described more precisely in the ANSI standard than in the first edition. The most important change is the addi- tion of the # and ## operators, which make quotation and concatenation admis- sible. Some of the new rules, especially those involving concatenation, are bizarre. (See example below.)
For example, this facility may be used for "manifest constants," as in
#define TABSIZE 100 int table[TABSIZE];
The definition
#define ABSDIFF(a, b) «a»(b)? (a)-(b) : (b)-(a»
defines a macro to return the absolute value of the difference between its arguments. Unlike a function to do the same thing, the arguments and returned value may have any

 SECTION Al2 PREPROCESSING 231
arithmetic type or even be pointers. Also, the arguments, which might have side effects, are evaluated twice, once for the test and once to produce the value.
Given the definition
#define tempfile{dir) Idir "/%s"
themacrocalltempfile(/usr/tmp)yields "/usr/tmp" "/"s"
which will subsequently be catenated into a single string. After #define cat{x, y) x II y
the call cat{var, 123) yields var123. However, the call cat{ cat{ 1,2) ,3» is undefined:thepresenceofIIpreventstheargumentsoftheoutercallfrombeing expanded. Thus it produces the token string
cat (1 2) 3
and }3 (the catenation of the last token of the first argument with the first token of the second) is not a legal token. If a second level of macro definition is introduced,
#define xcat(x,y) cat{x,y)
things work more smoothly; xcat{xcat{ 1, 2), 3) does produce 123,because the expansionofxcatitselfdoesnotinvolvetheIIoperator.
Likewise, ABSDIFF (ABSDIFF ( a ,b) ,c) produces the expected, fully-expanded result.
A12.4 File Inclu8ion
A control line of the form
# include «filename»
causes the replacement of that line by the entire contents of the file filename. The characters in the name filename must not include > or newline, and the effect is unde- fined if it contains any of ", " \, or / *. The named file is searched for in a sequence of implementation-dependent places.
Similarly, a control line of the form I include "filename"
searches first in association with the original source file (a deliberately implementation- dependent phrase), and if that search fails, then as if in the first form. The effect of using " \, or / * in the filename remains undefined, but > is permitted.
Finally, a directive of the form
# include token-sequence
not matching one of the previous forms is interpreted by expanding the token sequence as for normal text; one of the two forms with <...> or "..." must result, and it is then treated as previously described.
linclude files may be nested. A12.5 Conditional Compilation
Parts of a program may be compiled conditionally, according to the following schematic syntax.

 232 REFERENCE MANUAL preprocessor-conditional:
if-line text elif-parts else-partopt #endif
if-line:
# if constant-expression # ifdef identifier
# ifndef identifier
elif-parts: elif-line text
eli/-partsopt elif-ltne:
# elif constant-expression else-part:
else-line text else-line:
APPENDIX A
# else Eachofthedirectives(if-line,elif-line,else-line,and#endif)appearsaloneonaline. Theconstantexpressionsin#if andsubsequent#elif linesareevaluatedinorderuntil an expressionwith a non-zero value is found; text followinga line with a zero value is discarded. The text following the successful directive line is treated normally. "Text" here refers to any material, including preprocessor lines, that is not part of the condi- tionalstructure;itmaybeempty. Onceasuccessful#if or#elif linehasbeenfound anditstextprocessed,succeeding#elif and#else lines,togetherwiththeirtext,are discarded. If all the expressionsare zero,and there isan #else, the text followingthe #else is treated normally. Text controlled by inactive arms of the conditional is ignored except for checking the nesting of conditionals. .
The constant expressionin #if and #elif is subject to ordinary macro replace- ment. Moreover,any expressionsof the form
or
defined identifier defined ( identifier)
are replaced, before scanning for macros, by 1L if the identifier is defined in the prepro- cessor, and by OL if not. Any identifiers remaining after macro expansion are replaced by OL. Finally, each integer constant is considered to be suffixed with L, so that all arithmetic is taken to be long or unsigned long.
The resulting constant expression (§A7.19) is restricted: it must be integral, and may notcontainsizeof, acast,oranenumerationconstant.
The control lines
#ifdef identifier
#ifndef identifier are equivalent to
# if defined identifier
# if I defined identifier
respectively.
#elif is new since the first edition. although it has been available in some preprocessors. Thedefinedpreprocessoroperatorisalsonew.

 SECTION A12 PREPROCESSING 233
A12.6 Line Control
For the benefit of other preprocessors that generate C programs, a line in one of the forms
# line constant "filename" # 1ine constant
causes the compiler to believe, for purposes of error diagnostics, that the line number of the next source line is given by the decimal integer constant and the current input file is named by the identifier. If the quoted filename is absent, the remembered name does not change. Macros in the line are expanded before it is interpreted.
A12.7 Error Generation
A preprocessor line of the form
# error token-sequence.i,
causes the processor to write a diagnostic message that includes the token sequence.
A12.8 Pragmas
A control line of the form
# pragma token-sequence.g,
causes the processor to perform an implementation-dependent action. An unrecognized pragma is ignored.
A12.9 Null Directive
A preprocessor line of the form #
has no effect.
A12.10 Predefined Names
Several identifiers are predefined, and expand to produce special information. They,
and also the preprocessor expression operator defined, may not be undefined or rede-
fined.
__LINE__
FILE__ __DATE__
__TIME__
A decimal constant containing the current source line number.
A string literal containing the name of the file being compiled.
A string literal containing the date of compilation, in the form
"Mmm dd yyyy".
A string literal containing the time of compilation, in the form
"hh:mm: ss".
STDC The constant 1. It is intended that this identifier be defined to be 1
only in standard-conforming implementations.
#error and #pragma are new with the ANSI standard; the predefined preprocessor macros are new, but some of them have been available in some implementations.

 234 REFERENCE MANUAL APPENDIX A
A 13. Grammar
Below is a recapitulation of the grammar that was given throughout the earlier part of this appendix. It has exactly the same content, but is in a different order.
The grammar has undefined terminal symbols integer-constant, character-constant, floating-constant, identifier, string, and enumeration-constant; the typewriterstyle words and symbols are terminals given literally. This grammar can be transformed mechanically into input acceptable to an automatic parser-generator. Besides adding whatever syntactic marking is used to indicate alternatives in productions, it is necessary to expand the "one or' constructions, and (depending on the rules of the parser-
generator) to duplicate each production with an opt symbol, once with the symbol and once without. With one further change, namely deleting the production typedef-name: identifier and making typedef-name a terminal symbol, this grammar is acceptable to the YACC parser-generator. It has only one conflict, generated by the if-elseambi- guity.
translation-unit: external-declaration
translation- unit external-declaration
external-declaration: function-definition
declaration
function-definition:
declaration-specifiers.c. declarator declaration-Iistopt compound-statement
declaration:
declaration-specifiers init -declarator-Iistopt
declaration-list: declaration
declaration-list declaration
declaration-specifiers:
storage-class-specifier declaration-spectfiers.q, type-specifier declaratton-speciftersg; type-qualifier declaration-specifiersg;
storage-class-specifier: one of
auto register static extern typedef
type-specifier: one of
void char short int long float double signed
unsigned struct-or-union-specifler ' enum-specifier typedef-name type-qualifier: one of
const volatile
struct -or-union-specifier:
struct-or-union identifieropt { struct-declaration-list } struct -or- union identifier
struct-or-union: oneof struct union
struct -declaration-list: struct -declaratton
struct -declaration-ltst struct -declaration

 SECTION A13
GRAMMAR 235
init -declarator-list: init -declarator
init-declarator-list
init -declarator: declarator
declarator = initializer struct -declaration:
specifier-qualifier-list
specifier-qualifier-list:
type-specifier specifier-qualifier-ltst.p type-qualifier specifier-qualifier-listg;
struct -declarator-list: struct -declarator
struct -declarator-list , struct -declarator
struct -declarator: declarator
declarator opt : constant -expression
enum -specifier:
enum identifier opt { enumerator-list } enum identifier
enumerator-list: enumerator
enumerator-list , enumerator
enumerator: identifier
identifier = constant -expression declarator:
pointer optdirect -declarator
direct -declarator: identifier
( declarator )
direct-declarator [ constant-expression.g, ] direct-declarator ( parameter-type-list ) direct-declarator(tdenttfier-listc;)
pointer:
* type-qualifier-list opt
* type-qualifier-listopt pointer
type-qualifier-list: type-qualifier
type-qualifier-list
parameter-type-list: parameter-list
parameter-list ,
type-qualifier
parameter-list: parameter-declaration
parameter-list , parameter-declaration
, init-declarator
struct -declarator-list

 236 REFERENCE MANUAL
APPENDIX A
parameter-declaration:
declaration-specifiers declarator declaration-specifiers abstract -declarator opt
identifier-list: identifier
identifier-list , identifier
inittalizer:
assignment -expression
{ inuializer-list }
{ initializer-list, }
initializer-list: initializer
initializer-list , initializer
type-name:
specifier-qualifier-list abstract -declarator opt
abstract -declarator:
pointer .
pointer opt direct-abstract-declarator
direct -abstract -declarator:
( abstract -declarator )
direct -abstract -declarator opt [ constant -expressionopt direct-abstract-declaratorg; ( parameter-type-listg. )
typedef-name: identifier
statement:
labeled -statement
expression-statement compound -statement selection-statement iteration-statement
jump-statement
labeled -statement:
identifier : statement
case constant-expression default : statement
expression-statement: expressionopt ;
compound -statement:
{ declaration-listopt
statement -list: statement
statement
statement-list statement
selection-statement:
if (expression ) statement
if (expression) statement else statement switch (expression ) statement
statement-listopt }
]

 SECTION Al3 GRAMMAR 237
iteration-statement:
while (expression) statement
do statement while ( expression) ;
for (expressionopI ; expressionopl ; expressionoP1 ) statement
jump-statement:
goto identifier
continue ;
break ;
return expressionoP1
expression:
assignment -expression
expression , assignment -expression
assignment-expressiolt' conditional-expression
unary-expression assignment -operator assignment -expression assignment -operator: one of
=*=/=%=+=-=«= »= &= =1=
conditional-expression: logical-l)~-expression
logical-on-expression ? expression: constant -expression:
conditional-expression
conditional-expression
logical-ate -expression: logical- AND-expression logical-Ok-expression
logical- ANIr-expression: tnclusive-on -expression logical-AND-expression
: : logical-AND-expression &.&. inclusive-Ok-expresston
inclusive-on-expression: exclustve-ok -expression tnclustve-ok-expresston
exclustve-ok-expresston: AND-expression
exclustve-on-expression
AND-expressiolt' equality-expression
: exclustve-on-expresston
,. AND-expression
AND-expression &. equality-expression
equality-expression: relational-expression
equality-expression ==relational-expression
equality-expression
relational-expresston: shift -expression
relational-expression relational-expression relational-expression relational-expression
I =relational-expression
< shift -expression > shift -expression <=shift -expression >=shift -expression

 238 REFERENCE MANUAL
APPENDIX A
shift -expression: additive-expression
shift-expression << additive-expression shift -expression > > additive-expression
additive-expression:
multiplicative-expression
additive-expression + multiplicative-expression additive-expression - multiplicative-expression
multiplicative-expression: cast -expression
multiplicative-expression multiplicative-expression multiplicative-expression"
cast -expression: unary-expression
* cast-expression / cast-expression cast-expression
( type-name) cast-expression
unary-expression: postfix -expression
++ unary-expression
-- unary-expression unary-operator cast-expression sizeof unary-expression sizeof (type-name )
unary-operator: one of &. * +
postfix -expression: primary-expression
postfix-expression [ expression] postfix-expression(argument-expression-listg, postfix-expression • identifier
postfix-expression -> identifier
postfix -expression ++ postfix-expression --
primary -expression: identifier constant
string
( expression
argument -expresston-list: assignment -expression
argument -expression-list
constant: integer-constant
character-constant floating-constant
enumeration-constant
, assignment -expression
The foIiowing grammar for the preprocessor summarizes the structure of control lines, but is not suitable for mechanized parsing. It includes the symbol text, which means ordinary program text, non-conditional preprocessor control lines, or complete preprocessor conditional constructions.

 SECTION Al3
GRAMMAR 239
control-line:
# define identifier token-sequence
# define identifier ( identifier , ... ,identifier)
# undef identifier
# include «filename»
# include "filename"
# include token-sequence
# line constant "filename"
# line constant
# error token-sequenceopt
# pragma token-sequenceopt #
preprocessor-conditional preprocessor-conditional:
if-line text elif-parts else-partopt # endif
if-line:
# if constant-expression # ifdef identifier
# ifndef identifier
elif-parts:
elif-line text
eli/-partsoP1 elif-line:
# elif constant-expression else-part:
else-line text
else-line:
# else
token-sequence

 
 APPENDIX B: Standard Library
This appendix is a summary of the library defined by the ANSI standard. The standard library is not part of the C language proper, but an environment that supports standard C will provide the function declarations and type and macro definitions of this library. We have omitted a few functions that are of limited utility or easily synthesized from others; we have omitted multi-byte characters; and we have omitted discussionof locale issues, that is, properties that depend on local language, nationality, or culture.
The functions, types and macros of the standard library are declared in standard
headers:
<assert.h> <float.h> <math.h> <stdarg.h> <stdlib.h> <ctype.h> <limits.h> <setjmp.h> <stddef.h> <string.h> <errno.h> <locale.h> <signa1.h> <stdio.h> <time.h>
A header can be accessed by
#include <header>
Headers may be included in any order and any number of times. A header must be included outside of any external declaration or definition and before any use of anything it declares. A header need not be a source file.
External identifiers that begin with an underscore are reserved for use by the library, as are all other identifiers that begin with an underscore and an upper-case letter or another underscore.
B1. Input and Output: <atdlo.h>
The input and output functions, types, and macros defined in <stdio.'h>represent nearly one third of the library.
A stream is a source or destination of data that may be associated with a disk or other peripheral. The library supports text streams and binary streams, although on some systems, notably UNIX, these are identical. A text stream is a sequence of lines; eachlinehaszeroormorecharactersandisterminatedby,\n'. Anenvironmentmay need to convert a text stream to or from some other representation (such as mapping
,\n'tocarriagereturnandlinefeed).Abinarystreamisasequenceofunprocessed bytes that record internal data, with the property that if it is written, then read back on the same system, it will compare equal.
A stream is connected to a file or device by opening it; the connection is broken by 241

 242 STANDARD LIBRARY APPENDIX B
closing the stream. Opening a file returns a pointer to an object of type FILE,which records whatever information is necessary to control the stream. We will use "file pointer" and "stream" interchangeably when there is no ambiguity.
When a program begins execution, the three streams stdin,stdout,and stderr are already open.
B1.1 File Operations
The following functions deal with operations on files. The type size_t is the
unsigned integral type produced by the sizeofoperator.
FILE *fopen(const char *filename, const char *mode)
fopen opens the named file, and returns a stream, or NULL if the attempt fails. Legal values formodeinclude
"r" "w" "a" "r+ " "w+" "a+"
open text file for reading
create text file for writing; discard previous contents if any append; open or create text file for writing at end of file open text file for update (i.e., reading and writing)
create text file for update; discard previous contents if any append; open or create text file for update, writing at end
Update mode permits reading and writing the same file; fflush or a file-positioning function must be called between a read and a write or vice versa. If the mode includes b after the initial letter, as in "rb" or "w+b", that indicates a binary file. Filenames are limited to FILENAME_MAX characters. At most FOPEN_MAX files may be open at once.
FILE *freopen(const char *filename, const char *mode, FILE *stream)
freopenopens the file with the specified mode and associates the stream with it. It returns stream,or NULL if an error occurs. freopen is normally used to change the files associated with stdin,stdout,or stderr.
int fflush(FILE *stream)
On an output stream, fflushcauses any buffered but unwritten data to be written; on an input stream, the effect is undefined. It returns EOF for a write error, and zero otherwise. fflush (NULL) flushes all output streams.
int fclose(FILE *stream)
fclose flushes any unwritten data for stream,discards any unread buffered input, frees any automatically allocated buffer, then closes the stream. It returns EOFif any errors occurred, and zero otherwise.
int remove(const char *filename)
remove removes the named file, so that a subsequent attempt to open it will fail. It returns non-zero if the attempt fails.
int rename(const char *oldname, const char *newname) rename changes the name of a file; it returns non-zero if the attempt fails.

 SECTION Bl INPUT AND OUTPUT: <STDIO.H> 243
FILE *tmpfile(void)
tmpfile creates a temporary file of mode "wb+" that will be automatically removed when closed or when the program terminates normally. tmpfile returns a stream, or NULLif it could not create the file.
char *tmpnam(char s[L_tmpnam])
tmpnam(NULL)creates a string that is not the name of an existing file, and returns
a pointer to an internal static array. tmpnam(s) stores the string in s as well as returning it as the function value; s must have room for at least L_tmpnam charac- ters. tmpnam generates a different name each time it is called; at most TMP_MAX different names are guaranteed during execution of the program. Note that tmpnam creates a name, not a file.
int setvbuf(FILE *stream, char *buf, int mode, size_t size)
setvbuf controls buffering for the stream; it must be called before reading, writing, or any other operation. A mode of _IOFBF causes full buffering, _IOLBF line buffering of text files, and _IONBFno buffering. If buf is not NULLi,t will be used
as the buffer; otherwise a buffer will be allocated. size determines the buffer size. setvbuf returns non-zero for any error.
void setbuf(FILE *stream, char *buf)
If buf is NULL,buffering is turned off for the stream. Otherwise, setbuf is equivalent to (void) setvbuf (stream, buf, _IOFBF, BUFSIZ).
81.2 FQrmaHedOutput
The printf functions provide formatted output conversion.
int fprintf(FILE *stream, const char *format, ... )
fprintf converts and writes output to stream under the control of format. The
return value is the number of characters written, or negative if an error occurred.
The format string contains two types of objects: ordinary characters, which are copied to the output stream, and conversion specifications, each of which causes conver- sion and printing of the next successive argument to fprintf. Each conversion specifi- cation begins with the character " and ends with a conversion character. Between the "
and the conversion character there may be, in order:
• Flags (in any order), which modify the specification:
-, which specifies left adjustment of the converted argument in its field.
+, which specifies that the number will always be printed with a sign.
space: if the first character is not a sign, a space will be prefixed.
0: for numeric conversions, specifies padding to the field width with leading zeros.
#,whichspecifiesanalternateoutputform.For0,thefirstdigitwillbezero.ForxorX, Ox or oxwill be prefixed to a non-zero result. For e, E, f, g, and G, the output will always have a decimal point; for g and G, trailing zeros will not be removed.
• A number specifying a minimum field width. The converted argument will be printed in a field at least this wide, and wider if necessary. If the converted argument has fewer characters than the field width it will be padded on the left (or right, if left adjustment has been requested) to make up the field width. The padding character is normally space, but is 0 if the zero padding flag is present.

 244
STANDARD LIBRARY APPENDIX B
• •
A period, which separates the field width from theprecision,
A number, the precision, that specifies the maximum number of characters to be printed from a string, or the number of digits to be printed after the decimal point for e, E, or f conversions, or the number of significant digits for g or G conversion, or the minimum number of digits to be printed for an integer Oeading Os will be added to make up the necessary width}.
•Alengthmodifierh,1(letterell),orL."h"indicatesthatthecorrespondingargumentistobe printed as a short or unsigned short; "L" indicates that the argument is a long or unsigned long; "L" indicates that the argument is a long double.
Width or precision or both may be specified as *, in which case the value is computed byconvertingthenextargument(s),whichmustbeinto
The conversioncharacters and their meanings are shown in Table B-1. If the char- acter after the" is not a conversioncharacter, the behavior is undefined.
TABLE B-1. PRINTF CONVERSIONS
CHARACTER ARGUMENT TYPE; CONVERTED TO
d,i int; signeddecimalnotation.
o int; unsignedoctalnotation(withoutaleadingzero).
x, X int; unsigned hexadecimal notation (without a leading Oxor OX)u,singabcdef forOxorABCDEfForox.
u int; unsigneddecimalnotation.
c s
f
e, E
g, G
p
n
"
int; singlecharacter, after conversionto unsigned char. char*; charactersfromthestringareprinteduntila'\0' is reached or until the number of characters indicated by the pre-
cision have been printed.
double; decimal notation of the form [- ]mmm.ddd, where the
number of d's is specified by the precision. The default preci- sion is 6; a precision of 0 suppresses the decimal point.
double; decimal notation of the form [--]m.dddddde±xx or [-]m.ddddddE±Xx, where the number of d's is specified by the precision. The default precision is 6; a precision of 0 suppresses the decimal point.
double; "e or "E is used if the exponent is less than -4 or
greater than or equal to the precision; otherwise
"f
is used. Trailing zeros and a trailing decimal point are not printed.
void *; print as a pointer (implementation-dependentrepresen- tation).
int *; the number of characters written so far by this call to printf is written into the argument. No argument is con- verted.
no argument is converted;print a ".
int printf(const char *format•... )
printf (.. .) is equivalentto fprintf (stdout ....).

 SECTION B1 INPUT AND OUTPUT: <STOIO.H> 245
int sprintf(char *s, const char *format, .••)
sprintf is the same as printf except that the output is written into the string s, terminated with ' \0'. s must be big enough to hold the result. The return count
does not include the ' \0' .
vprintf(const char *format, va_list arg)
vfprintf(FILE *stream, const char *format, va_list arg) vsprintf(char *s, const char *format, va_list arq)
The functions vprintf, vfprintf, and vsprintf are equivalent to the corresponding printf functions, except that the variable argument list is replaced by arq,which has been initialized by the va_start macro and perhaps va_arq calls. See the discussionof <stdarq.h> in Section B7.
B 1.3 Formatted Input
The scanf functions deal with formatted input conversion.
int fscanf(FILE *stream, const char *format, •..)
fscanf reads from stream under control of format,and assigns converted values through subsequent arguments, each of which must be a pointer. It returns when
format is exhausted. fscanf returns EOF if end of file or an error occurs before any conversion;otherwise it returns the number of input items converted and assigned.
The format string usually contains conversionspecifications,which are used to direct interpretation of input. The format string may contain:
• Blanks or tabs, which are ignored.
• Ordinary characters (not x), which are expected to match the next non-white space character of
the input stream.
• Conversion specifications, consisting of a %, an optional assignment suppression character *, an optional number specifying a maximum field width, an optional h. 1, or L indicating the width of the target, and a conversion character.
A conversion specification determines the conversion of the next input field. Nor- mally the result is placed in the variable pointed to by the correspondingargument. If assignment suppression is indicated by *, as in ,,*S, however, the input field is simply skipped;noassignmentismade. Aninputfieldisdefinedasastringofnon-whitespace characters; it extends either to the next white space character or until the field width, if specified,isexhausted. Thisimpliesthatscanfwillreadacrosslineboundariestofind its input, since newlines are white space. (White space characters are blank, tab, new- line, carriage return, vertical tab, and formfeed.)
The conversion character indicates the interpretation of the input field. The corresponding argument must be a pointer. The legal conversioncharacters are shown in Table B-2.
Theconversioncharactersd,i,n,0,u,andxmaybeprecededbyhiftheargument is a pointer to short rather than int,or by 1 (letter ell) if the argument is a pointer to long. The conversion characters e,f,and q may be preceded by 1 if a pointer to double rather than float is in the argument list, and by L if a pointer to a lonq double.

 246
STANDARD LIBRARY APPENDIX B
int int
scanf{const
scanf ( ... ) is identical to fscanf ( stdin,
CHARACTER
d i
o u x c
s
e, f, g
p n
[...] [A...]
"
TABLE B-2. SCANF CONVERSIONS
INPUT DATA; ARGUMENT TYPE
decimal integer; int *.
integer; int *. The integer may be in octal (leading 0) or hexadecimal (leading Ox or OX).
octal integer (with or without leading zero); int *.
unsigned decimal integer; unsigned int *.
hexadecimal integer (with or without leading Ox or OX); int *. characters; char *. The next input characters are placed in the indicated array, up to the number given by the width field; the defaultis1.No'\0'isadded.Thenormalskipoverwhite space characters is suppressed in this case; to read the next non-white space character, use %1s.
string of non-white space characters (not quoted); char *, pointing to an array of characters large enough to hold the
stringandaterminating,\0' thatwillbeadded.
floating-point number; float *. The input format for float's
is an optional sign, a string of numbers possibly containing a decimal point, and an optional exponent field containing an E or e followedby a possiblysigned integer.
pointer value as printed by printf{ ""p"); void *.
writes into the argument the number of characters read so far by this call; int *. No input is read. The converted item count is not incremented.
matches the longest non-empty string of input characters from thesetbetweenbrackets;char*.A'\0'isadded.[]...] includes ] in the set. matchesthelongestnon-emptystringofinputcharactersnot fromthesetbetweenbrackets;char*.A'\0'isadded. [ A ] ... ] includes]intheset.
literal "; no assignment is made.
char *format, ... )
sscanf{char *s, const char *format, .•. )
sscanf ( s, ... ) is equivalent to scanf ( ... ) taken from the string s.
except that the input
as an unsigned char
characters are
(converted to
B1.4 Character Input and Output Functions
int fgetc{FILE *stream)
fgetc returns the next character of stream an int), or EOFif end of file or error occurs.
... ).

 SECTION Bl INPUT AND OUTPUT: <STDIO.H> 247
char *fgets(char *s, int n, FILE *stream)
fgets reads at most the next n-1 characters into the array s,stopping if a newline isencountered;thenewlineisincludedinthearray,whichisterminatedby'\0'. fgets returns s,or NULL if end of file or error occurs.
int fputc(int c, FILE *stream)
fputc writes the character c (converted to an unsigned char)on stream. It returns the character written, or EOF for error.
int fputs(const char *s, FILE *stream)
fputs writes the string s (which need not contain ' \n,)on stream;it returns non-negative, or EOF for an error.
int getc(FILE *stream)
getc is equivalent to fgetc except that if it is a macro, it may evaluate stream more than once.
int getchar(void)
getchar is equivalent to getc(stdin).
char *gets(char *s)
gets reads the next input line into the array s;it replaces the terminating newline with'\0'. Itreturnss,orNULLifendoffileorerroroccurs.
int putc(int c, FILE *stream)
putc is equivalent to fputc except that if it is a macro, it may evaluate stream more than once.
int putchar(int c)
putchar(c)is equivalent to putc(c,stdout).
int puts(const char *s) putswritesthestringsandanewlinetostdout.ItreturnsEOFifanerror occurs, non-negativeotherwise.
int ungetc(int c, FILE *stream)
ungetc pushes c (converted to an unsigned char)back onto stream,where it will be returned on the next read. Only one character of pushback per stream is guaranteed. EOF may not be pushed back. ungetc returns the character pushed back, or EOF for error.
B 1.5 Direct Input and Output Functions
size_t fread(void *ptr, size_t size, size_t nobj, FILE *stream) fread reads from stream ink>the array ptr at most nobj objects of size size. fread returns the number of objects read; this may be less than the number requested. feof and ferror must be used to determine status.
size_t fwrite(const void *ptr, size_t size, size_t nobj, FILE *stream)
fwrite writes, from the array ptr,nobj objects of size size on stream. It returns the number of objects written, which is less than nobj on error.

 /
81.6 File Positioning Functions
int fseek(FILE *stream, long offset, int origin)
fseek setsthefilepositionforstream; asubsequentreadorwritewillaccessdata beginningatthenewposition.Forabinaryfile,thepositionissettooffset char- acters from origin, which may be SEEK_SET(beginning), SEEK_CUR(current position),or SEEK_EN(Dend of file). For a text stream, offset must be zero,or a
value returned by ftell (in which case origin must be SEEK_SET).fseek returns non-zero on error.
long ftell(FILE *stream)
ftell returnsthecurrentfilepositionforstream,or-1Lonerror.
void rewind(FILE *stream)
rewind(fp) isequivalentto fseek(fp,OL,SEEK_SET); clearerr(fp).
int fgetpos(FILE *stream, fpos~t *ptr)
fgetpos records the current position in stream in *ptr, for subsequent use by fsetpos. The type fpos_ t is suitable for recording such values. fgetpos returns non-zero on error.
int fsetpos(FILE *stream, const fpos_t *ptr)
fsetpos positions stream at the position recorded by fgetpos in *ptr. fsetpos returns non-zeroon error.
81.7 Error Functions
Many of the functions in the library set status indicators when error or end of file occur. These indicators may be set and tested explicitly. In addition, the integer expres- sion errno (declared in <errno. h» may contain an error number that givesfurther information about the most recent error.
void clearerr(PILE *stream)
clearerr clearstheendoffileanderrorindicatorsforstream.
int feof(FILE *stream)
feof returns non-zero if the end of file indicator for stream is set.
int ferror(FILE *stream)
f error returns non-zero if the error indicator for stream is set.
void perror(const char *s)
perror (s) prints s and an implementation-definederror messagecorrespondingto the integer in errno, as if by
fprintf (stderr, ""s: "s\n", s, "error message" ) See strerror in Section B3.
82. CharacterClas.Te.t.: <ctype.h>
Theheader<ctype.h>declaresfunctionsfortestingcharacters.Foreachfunction, the argument is an int, whosevalue must be EOFor representable as an unsigned
148 STANDARD LIBRARY APPENDIX B

 SECTION B3 STRING FUNCTIONS: <STRING.H> 249
char, and the return value is an into The functions return non-zero (true) if the argu- ment c satisfies the condition described, and zero if not.
isalnum(c) isalpha(c) iscntrl(c) isdigit(c) isgraph(c) islower(c) isprint(c) ispunct(c) isspace(c) isupper(c) isxdigit(c)
isalpha (c) or isdigi t (c) is true isupper (c) or islower (c) is true
control character
decimal digit
printing character except space
lower-case letter
printing character including space
printing character except space or letter or digit
space, formfeed, newline, carriage return, tab, vertical tab upper-case letter
hexadecimal digit
In the seven-bit ASCII character set, the printing characters are Ox20 (, ,) to Ox7E (,_,); the control characters are 0 (NUL) to Ox1F (US), and Ox7F (DEL).
In addition, there are two functions that convert the case of letters:
int tolower (int c) convert c to lower case int toupper (int c) convert c to upper case
If c is an upper-case letter, tolower (c) returns the correspondinglower-caseletter; otherwiseitreturnsC. Ifcisalower-caseletter,toupper (c)returnsthecorrespond- ingupper-caseletter;otherwiseitreturnsC.
83. String Functions: <string.h >
There are two groups of string functions defined in the header <string. h>. The first have names beginning with str; the second have names beginning with mem. Except for memmove,the behavior is undefined if copying takes place between overlap- ping objects. Comparison functions treat arguments as uns igned char arrays.
In the followingtable, variables sand t are of type char *; cs and ct are of type const char *; n is of type size_ t; and c is an int converted to char.
char *strcpy(s,ct) char *strncpy(s,ct,n)
char *strcat(s,ct) char *strncat(s,ct,n)
int strcmp(cs,ct)
copystringcttostrings,including,\0';returnS. copyatmostncharactersofstringcttos;returnS. Pad with ' \ 0 ' s if t has fewer than n characters. concatenatestringcttoendofstrings;returnS. concatenate at most n characters of string ct to string s,terminateswith'\0'; returnS.
compare string cs to string ct; return <0 if cs<ct, 0 if cs==ct, or >0 if cs>ct.
compare at most n characters of string cs to string ct; return <0 if cs-ece, 0 if cs==ct, or >0 if cs>ct. return pointer to first occurrence of c in cs or NULL if not present.
return pointer to last occurrence of c _in cs or NULL if not present.
int char char
strncmp(cs,ct,n) *strchr(cs,c) *strrchr(cs,c)

 250 STANDARD LIBRARY size t strspn(cs,ct)
APPENDI~ B
return length of prefix of cs consisting of characters in ct.
return length of prefix of cs consisting of characters not in ct.
return pointer to first occurrence in string cs of any character of string ct, or NULLif none are present. return pointer to first occurrence of string ct in cs, or NULLif not present.
return length of cs.
return pointer to implementation-defined string correspondingto error n.
strtok searches s for tokens delimited by characters from ct; see below.
A sequence of calls of strtok ( s , ct) splits s into tokens, each delimited by a characterfromct.Thefirstcallinasequencehasanon-NULLs.Itfindsthefirst token in s consisting of characters not in ct; it terminates that by overwriting the next character of s with ' \0' and returns a pointer to the token. Each subsequent call, indi- cated by a NULLvalue of s, returns the next such token, searching from just past the end of the previous one. strtok returns NULLwhen no further token is found. The string ct may be different on each call.
The melD...functions.are meant for manipulating objects as character arrays; the intent is an interface to efficient routines. In the followingtable, sand t are of type void *;cs andct areoftypeconst void *;nisoftypesize_ t; andcisanint
size_t
char
char
strcspn(cs,ct) *strpbrk(cs,ct) *strstr(cs,ct)
size_t
char *strerror(n)
strlen(cs) char *strtok(s,ct)
converted to an unsigned
void *memcpy(s,ct,n) void *memmove(s,ct,n)
char.
copy n characters from ct to s, and return s.
same as memcpy except that it works even if the objects overlap.
compare the first n characters of cs with ct; return as with strcmp.
return pointer to first occurrence of character c in cs, or NULLif not present among the first n characters. place character c into first n characters of s, return s.
int void void
memcmp(cs,ct,n) *memchr(cs,c,n) *memset(s,c,n)
84. MathematicalFunctions: <math.h>
The header"<math. h> declares mathematical functions and macros.
The macros EDOM and ERANGE (found in <errno.h» are non-zero integral con- stants that are used to signal domain and range errors for the functions; HUGE_ VAL is a positive double value. A domain error occurs if an argument is outside the domain over which the function is defined. On a domain error, errno is set to EDOM; the return value is implementation-dependent. A range error occurs if the result of the function cannot be represented as a double. If the result overflows,the function returns HUGE_ VAL with the right sign, and errno is set to ERANGE. If the result underflows, the function returns zero; whether errno is set to ERANGE is implementation-defined.
In the followingtable, x and yare of type double, n is an int, and all functions return double. Angles for trigonometric functions are expressed in radians.

 SECTION B5
UTILITY FUNCTIONS: <STDLIB.H> 2S1
log10(x) pow(x,y)
natural logarithm In(x), x >o.
base 10logarithm log10(x), x> O.
x", A domain error occurs if x-o and y~O, or if x <0 and y is not an integer.
sqrt(x) Fx,x~O.
ceil (x)
floor(x)
f abs (x)
ldexp(x,n) x·2n frexp(x, int *exp)
sine of x
cosine of x
tangent of x
sin-l(x) inrange[-11'"/2, 11'"/2],x E [-1, 1]. cos"!(x) in range [0, 11'"],x E [-1, 1].
tan"! (x) in range [-11'"/2, 11'"/2]. tan-1 (yIx) in range [-11'", 11'"]. hyperbolicsineofx hyperboliccosineof x hyperbolictangent of x
sin(x)
cos (x)
tan{x)
asin{x)
acos(x)
atan{x)
atan2 (y ,x )
sinh (x)
cosh{x)
tanh{x)
exp(x) exponentialfunctione" log(x)
smallest integer not lessthan x, as a double. largest integer not greater than x, as a double. absolute value Ix I
splits x into a normalized fraction in the interval [112, 1), which is returned, and a power of 2, which is stored in *exp. If x is zero, both parts of the result are zero.
modf(x, double *ip)
splits x into integral and fractional parts, each with the
same sign as x. It stores the integral part in *ip, and
returns the fractional part.
fmod(x,y) floating-pointremainderofx/y, withthesamesignas
x.Ifyiszero,theresultisimplementation-defined.
85. Utility Functions: <stdlib.h>
The header <stdlib. h> declares functions for number conversion,storage alloca- tion, and similar tasks.
double atof(const char *s)
atof convertss to double; it isequivalentto strtod(s, (char**)NULL).
int atoi(const char *s)
convertss to int; it isequivalentto (int) strtol (s , (char**) NULL,10).
long atol(const char *s)
convertss to long; it isequivalentto strtol (s , (char**) NULL,10).
double strtod(const char *s, char **endp)
strtod convertsthe prefixof s to double, ignoringleadingwhitespace;it storesa pointer to any unconverted suffix in *endp unless endp is NULL.If the answer

 252 STANDARD LIBRARY APPENDlX B wouldoverflow,HUGEV_ALisreturnedwiththepropersign;iftheanswerwould
underflow,zero is returned. In either case errno is set to ERANGE.
long strtol(const char *s, char **endp, int base)
strtol converts the prefix of s to long, ignoring leading white space; it stores a pointer to any unconverted suffix in *endp unless endp is NULL. If base is between 2 and 36, conversionis done assuming that the input is written inthat base. If base is zero, the base is 8, 10,or 16;leading0 impliesoctal and leading Ox or ox
hexadecimal. Letters in either case represent digits from 10 to base-1; a leading Ox or ox is permitted in base 16. If the answer would overflow, LONG_MAoXr
LONG_MINis returned, depending on the sign of the result, and errno ERANGE.
unsigned long strtoul(const char *s, char **endp, int base) strtoul is the same as strtol except that the result is unsigned long error value is ULONG_MAX.
is set to
and the
int rand(void)
rand returns a pseudo-random integer in the range 0 to RAND_MAX, which is at least 32767.
void srand(unsigned int seed)
srand uses seed as the seed for a new sequence of pseudo-random numbers. The initial seed is 1.
void *calloc(size_t nobj, size_t size)
calloc returns a pointer to space for an array of nobj objects, each of size size, orNULLiftherequestcannotbesatisfied.Thespaceisinitializedtozerobytes.
void *malloc(size_t size)
malloc returns a pointer to space for an object of size size, or NULLif the request cannot be satisfied. The space is uninitialized.
void *realloc(void *p, size_t size)
realloc changes the size of the object pointed to by p to size. The contents will beunchangeduptotheminimumoftheoldandnewsizes.Ifthenewsizeislarger, the new space is uninitialized. realloc returns a pointer to the new space, or NULLiftherequestcannotbesatisfied,inwhichcase*pisunchanged.
void free(void *p)
free deallocates the space pointed to by p; it does nothing if p is NULL.p must be a pointer to space previouslyallocated by calloc, malloc, or realloc.
void abort(void)
abort causestheprogramtoterminateabnormally,asifbyraise (SIGABRT).
void exit(int status)
exi t causes normal program termination. atexi t functions are called in reverse order of registration, open files are flushed, open streams are closed, and control is returned to the environment. How status is returned to the environment is implementation-dependent, but zero is taken as successful termination. The values EXIT_SUCCESaSnd EXIT_FAILUREmay also be used.

 SECTION 86 DIAGNOSTICS: <ASSERT.H> 253
int atexit(void (*fcn)(void»
a texi t registers the function f cn to be called when the program terminates nor- mally;it returns non-zeroif the registrationcannot be made.
int system(const char *s)
system passesthe string s to the environmentfor execution. If s is NULL, system returns non-zeroif there is a commandprocessor. If s is not NULL, the return value is implementation-dependent.
char *getenv(const char *name)
getenv returns the environmentstring associatedwith name, or NULL if no string exists. Detailsare implementation-dependent.
void *bsearch(const void *key, const void *base, size_t n, size_t size,
int (*cmp)(const void *keyval, const void *datum»
bsearch searches base [0]...base [n-1] for an item that matches *key. The function cmp must return negativeif its first argument (the search key) is less than its second (a table entry), zero if equal, and positiveif greater. Items in the array base must be in ascendingorder. bsearch returns a pointer to a matching item, or NULL if noneexists.
void qsort(void *base, size_t n, size_t size,
int (*cmp)(const void *, const void *»
qsort sorts into ascendingorder an array base [0 ]...base [n-1] size. The comparisonfunction cmp is as in bsearch.
int abs(int n)
abs returns the absolutevalueof its int argument.
long labs(long n)
labs returns the absolutevalueof its long argument.
of objectsof size
div_t div(int num, int denom)
di v computesthe quotientand remainderof num/denom. The resultsare storedin the int membersquot and rem of a structure of type di v _t.
ldiv_t ldiv(long num, long denom)
div computesthe quotient and remainderofnum/denom. The results are stored in thelong membersquot andremofastructureoftypeldi v_t.
B6. Diagnostics: <assert.h>
The assert macro is used to add diagnosticsto programs: void assert (int expression)
If expressioniszerowhen as sert (expression)
is executed,the assert macro will print on stderr a message,such as Assertion failed: expression, file filename, line nnn
It then calls abort to terminate execution. The sourcefilenameand line numbercome

 254 STANDARD LIBRARY APPENmx B
from the preprocessor macros __ FILE __ and __ LINE __ .
If NDEBUG is defined at the time <assert. h> is included, the assert macro is
ignored.
B7. Variable Argument Usts: < stdarg.h>
The headet <stdarg. h> provides facilities for stepping through a list of function arguments of unknown number and type.
Suppose lastarg is the last named parameter of a function f with a variable number of arguments. Then declare within f a variable ap of type va_list that will point to each argument in turn:
va_list ap;
ap must be initialized once with the macro va_start before any unnamed argument is accessed:
va_start (va_list ap, lastarg);
Thereafter, each execution of the macro va_arg will produce a value that has the type and value of the next unnamed argument, and will also modify ap so the next use of va_arg returns the next argument:
type va_arg (va_list ap, type); The macro
void va_end(va_list ap);
must be called once after the arguments have been processed but before f is exited.
88. Non-local Jumps: < setjmp.h>
The declarations in <setjmp. h> provide a way to avoid the normal function call and return sequence, typically to permit an immediate return from a deeply nested func- . tion call.
int
setjmp(jmp_buf env)
The macro set jmp saves state information in env for use by long jmp. The return is zero from a direct call of set jmp, and non-zero from a subsequent call of longjmp. A call to setjmp can only occur in certain contexts, basically the test of if, switch, and loops, and only in simple relational expressions.
if (setjmp(env) ==0) /*gethereondirectcall*/
else
/* getherebycallinglongjmp*/
void longjmp(jmp_buf env, int val)
longjmp restores the state saved by the most recent call to set jmp, using informa- tion saved in env, and execution resumes as if the set jmp function had just exe- cuted and returned the non-zero value val. The function containing the set jmp must not have terminated. Accessible objects have the values they had when longjmp was called, except that non-volatile automatic variables in the function calling setjmp become undefined if they were changed after the setjmp call.

 SECTION 810 DATE AND TIME FUNCTIONS: <TIME.H> 255 89. Signals: < signal.h>
The header <signal. h> provides facilities for handling exceptional conditions that arise during execution, such as an interrupt signal from an external source or an error in execution.
void (*signal(int sig, void (*handler)(int»)(int)
signal determines how subsequent signals will be handled. If handler is
SIG_DFL, the implementation-defined default behavior is used; if it is SIG_IGN, the signal is ignored; otherwise, the function pointed to by handler will be called, with the argument of the type of signal. Valid signals include
SIGABRT SIGFPE SIGILL SIGINT SIGSEGV SIGTERM
signal returns the an error occurs.
abnormal termination, e.g., from abort
arithmetic error, e.g., zero divide or overflow
illegal function image, e.g., illegal instruction
interactive attention, e.g., interrupt
illegal storage access, e.g., access outside memory limits termination request sent to this program
previous value of handler for the specific signal, or SIG_ERR if
When a signal sig subsequently occurs, the signal is restored to its default behavior; then the signal-handler function is called, as if by (*handler) (sig). If the handler returns, execution will resume where it was when the signal occurred.
The initial state of signals is implementation-defined.
int raise(int sig)
raise sends the signal sig to the program; it returns non-zero if unsuccessful.
810. Date and Time Functions: <time.h>
The header <time.h> declares types and functions for manipulating date and time. Some functions process local time, which may differ from calendar time, for example because of time zone. clock_t and time_t are arithmetic types representing times, and struct tm holds the components of a calendar time:
inttm_sec; secondsaftertheminute(0,61) int tm_min; minutes after the hour (0,59) int tm_hour; hours since midnight (0,23) inttm_mday; dayofthemonth(1,31)
int tm_mon; months since January (0, 11) inttm_year; yearssince1900
int tm_wday; dayssinceSunday(0,6)
int tm_yday; dayssinceJanuary 1(0,365) inttm_isdst; DaylightSavingTimeflag
tm_isdst is positive if Daylight Saving Time is in effect, zero if not, and negative if the information is not available.
clock_t clock(void)
clock returns the processor time used by the program since the beginning of execu- tion, or -1 if unavailable. clock ( ) /CLOCKS_PER_SEC is a time in seconds.

 256 STANDARD LIBRARY APPENDIX ~
time_t time(time_t *tp) timereturnsthecurrentcalendartimeor-1ifthetimeisnotavailable.Iftpis not NULL,the return value is also assigned to *tp.
double difftime(time_t time2, time_t time1) difftime returns time2-time 1expressed in seconds.
time_t mktime(struct tm *tp)
mktime converts the local time in the structure *tp into calendar time in the same representation used by time. The components will have values in the ranges shown. mktime returns the calendar time or -1 if it cannot be represented.
The next four functions return pointers to static objects that may be overwritten by other calls.
char *asctime(const struct tm *tp)
asctime converts the time in the structure *tp into a string of the form
Sun Jan 3 15:14:13 1988\n\0 char *ctime(const time_t *tp)
ctime converts the calendar time *tp to local time; it is equivalent to asctime(localtime(tp»
struct tm *gmtime(const time_t *tp) gmtimeconvertsthecalendartime*tpintoCoordinatedUniversalTime(UTC).It returns NULL if UTC is not available. The name gmtime has historical significance.
struct tm *localtime(const time_t *tp) localtime converts the calendar time *tp into local time.
size_t strftime(char *s, size_t smax, const char *fmt, const struct tm *tp)
strftime formats date and time information from *tp into s according to fmt, which is analogous to a printf format. Ordinary characters (including the ter- minating '\0') are copied into s. Each %c is replaced as described below, using values appropriate for the local environment. No more than smax characters are placed into s. strftime returns the number of characters, excluding the ' \0',or
zero if more
"a
~ "b "B "C ~ "H "I "j
than smax characters were produced.
abbreviated weekday name. full weekday name. abbreviated month name. full month name.
local date and time representation. day of the month (01-31). hour(24-hourclock)(00-23). hour(12-hourclock)(01-12). dayoftheyear(001-366).

 SECTION Bll IMPLEMENTATION-DEFINED LIMITS: <LIMITS.H> AND <FLOAT.H> 257
%m month (01-12). %II. minute (00-59).
"p
"S second (00-61).
"U week number of the year (Sunday as 1st day of week) (00-53).
local equivalent of AMor PM.
"w
»l weeknumberoftheyear(Mondayas1stdayofweek)(00-53). ~ local date representation.
U local time representation.
"y year without century (00-99).
weekday (0-6, Sunday is 0).
"y
"Z time zone name, if any.
year with century.
"" ".
B11. Implementation-defined Limits: <IImlts.h> and <float.h >
The header <1imits .h> defines constants for the sizes of integral types. The values below are acceptable minimum magnitudes; larger values may be used.
CHAR_BIT 8 CHAR_MAX UCHAR_MAXor
SCHAR_MAX CHAR_MIN o or SCHAR_MIN
bits in a char
maximum value of char
minimum value of char
maximum value of int
minimum value of int
maximum value of long
minimum value of long
maximum value of signed char minimum value of signed char maximum value of short
minimum value of short
maximum value of unsigned char maximum value of unsigned int maximum value of uns igned long maximum value of uns igned short
INT_MAX INT_MIN LONG_MAX LONG_MIN SCHAR_MAX SCHAR_MIN SHRT_MAX SHRT_MIN UCHAR_MAX UINT_MAX ULONG_MAX USHRT_MAX
+32767
-32767 +2147483647
-2147483647 +127
-127 +32767
-32767 255
       65535
 4294967295
65535
The names in the table below, a subset of <float. h>, are constants related to floating-point arithmetic. When a value is given, it represents the minimum magnitude for the corresponding quantity. Each implementation defines appropriate values.
FLT_RADIX FLT_ROUNDS FLT_DIG FLT_EPSILON FLT_MANT_DIG FLT_MAX FLT_MAX_EXP FLT_MIN FLT_MIN_EXP
2 radix of exponent representation, e.g., 2, 16 floating-point rounding mode for addition
6 decimal digits of precision
1E-5 smallest number x such that 1.0 + x ~ 1.0
number of base FLT_RADIX digits in mantissa 1E+37 maximum floating-point number
maximum n such that FLT_RADIXn-1 is representable 1E- 37 minimum normalized floating-point number
minimum n such that Ion is a normalized number

 258 STANDARD LIBRARY
APPENDIX B
DBL_DIG 10 DBL_EPSILON 1E-9 DBL_MANT_DIG DBL_MAX
decimal digits of precision smallestnumberxsuchthat1.0+x~1.0 number of base FLT _RADIX digits in mantissa
DBL_MAX_EXP
DBL_MIN
DBL_MIN_EXP
1E+37 maximum double floating-point number
maximum n such that FLT _RADIX"-l is representable
1E-37 minimum normalized double floating-point number minimum n such that Ion is a normalized number

 APPENDIX c. Summary of Changes
Since the publication of the first edition of this book, the definition of the C language has undergone changes. Almost all were extensions of the original language, and were carefully designed to remain compatible with existing practice; some repaired ambiguities in the original description; and some represent modifications that change existing practice. Many of the new facilities were announced in the documents accom- panying compilers available from AT&T, and have subsequently been adopted by other suppliers of C compilers. More recently, the ANSI committee standardizing the language incorporated most of these changes, and also introduced other significant modifications. Their report was in part anticipated by some commercial compilers even before issuance of the formal C standard.
This Appendix summarizes the differences between the language defined by the first edition of this book, and that expected to be defined by the final Standard. It treats only the language itself, not its environment and library; although these are an important part of the Standard, there is little to compare with, because the first edition did not attempt to prescribe an environment or library.
• Preprocessing is more carefully defined in the Standard than in the first edition, and is extended: it is explicitly token based; there are new operators for catenation of tokens (##), and creation of strings (#); there are new control lines like #elif and #pragma; redeclaration of macros by the same token sequence is explicitly permit- ted; parameters. inside strings are no longer replaced. Splicing of lines by \ is per- mitted everywhere, not just in strings and macro definitions. See §A12.
• The minimum significance of all internal identifiers is increased to 31 characters; the smallest mandated significance of identifiers with external linkage remains 6 mono- case letters. (Many implementations provide more.)
• Trigraph sequences introduced by ?? allow representation of characters lacking in some character sets. Escapes for #\"[]{}I..are defined; see §A12.1. Observe that the introduction of trigraphs may change the meaning of strings containing the sequence ??
• New keywords (void, const, volatile, signed, enwn) are introduced. The stillborn entry keyword is withdrawn.
• New escape sequences, for use within character constants and string literals, are defined. The effect of following \ by a character not part of an approved escape sequence is undefined. See §A2.S.2.
259

 160
SUMMARYOF CHANGES APPENDIXC
• •
• •
•
Everyone'sfavorite trivial change: 8 and 9 are not octal digits.
The Standard introduces a larger set of suffixes to make the type of constants expli- cit: U or L for integers, F or L for floating. It also refines the rules for the type of unsuffixed constants (§A2.5).
Adjacent string literals are concatenated.
There is a notation for wide-character string literals and character constants; see §A2.6.
Characters, as well as other types, may be explicitly declared to carry, or not to carry, a sign by using the keywords signed or unsigned. The locution long float as a synonymfor double is withdrawn;but long double may be used to declare an extra-precision floating quantity.
• For some time, type unsigned char has been available. The standard introduces the signed keyword to make signedness explicit for char and other integral objects.
• The void type has been available in most implementations for some years. The Standardintroducestheuseofthevoid *typeasagenericpointertype;previously char*playedthisrole.Atthesametime,explicitrulesareenactedagainstmixing pointers and integers, and pointersof different type, without the use of casts.
• The Standard places explicit minima on the ranges of the arithmetic types, and man- datesheaders«limits•h>and<float.h» givingthecharacteristicsofeach particular implementation.
• Enumerations are new since the first edition of this book.
• The Standard adopts from C++ the notion of type qualifier, for example const (§A8.2).
• Strings are no longer modifiable, and so may be placed in read-only memory.
• The "usual arithmetic conversions" are changed, essentially from "for integers, unsigned alwayswins;forfloatingpoint,alwaysusedouble" to"promotetothe smallest capacious-enoughtype." See §A6.5.
• The old assignment operators like =+ are truly gone. Also, assignment operators are now single tokens; in the first edition, they were pairs, and could be separated by white space.
• A compiler's license to treat mathematically associative operators as computationally associativeis revoked.
• A unary + operator is introduced for symmetry with unary -.
• A pointer to a function may be used as a function designator without an explicit *
operator. See IA7.3.2.
• Structures may be assigned, passed to functions, and returned by functions.
• Applying the address-of operator to arrays is permitted, and the result is a pointer to the array.
• The sizeof operator, in the first edition, yielded type int; subsequently, many implementations made it unsigned. The Standard makes its type explicitly implementation-dependent, but requires the type, size_ t, to be defined in a

 SUMMARY OF CHANGES APPENDIX C 261
standard header «stddef .h». A similar change occurs in the type (ptrdiff _t) ofthedifferencebetweenpointers.See§A7.4.8and§A7.7.
• Theaddress-ofoperator&.maynotbeappliedtoanobjectdeclaredregister, even if the implementation chooses not to keep the object in a register.
• The type of a shift expression is that of the left operand; the right operand can't pro- mote the result. See §A7.8.
• The Standard legalizes the creation of a pointer just beyond the end of an array, and allows arithmetic and relations on it; see §A7.7.
• The Standard introduces (borrowing from C++) the notion of a function prototype declaration that incorporates the types of the parameters, and includes an explicit recognition of variadic functions together with an approved way of dealing with them. See§§A7.3.2,A8.6.3,B7. Theolderstyleisstillaccepted,withrestrictions.
• Empty declarations, which have no declarators and don't declare at least a structure, union, or enumeration, are forbidden by the Standard. On the other hand, a declara- tion with just a structure or union tag redeclares that tag even if it was declared in an outer scope.
• External data declarations without any specifiers or qualifiers (just a naked declara- tor) are forbidden.
•Someimplementations,whenpresentedwithanexterndeclarationinaninner block, would export the declaration to the rest of the file. The Standard makes it clear that the scope of such a declaration is just the block.
• The scope of parameters is injected into a function's compound statement, so that variable declarations at the top level of the function cannot hide the parameters.
• The name spaces of identifiers are somewhat different. The Standard puts all tags in a single name space, and also introduces a separate name space for labels; see
§All.l. Also, member names are associated with the structure or union of which they are a part. (This has been common practice from some time.)
• Unions may be initialized; the initializer refers to the first member.
• Automatic structures, unions, and arrays may be initialized, albeit in a restricted way.
• Character arrays with an explicit size may be initialized by a string literal with exactly that many characters (the \0 is quietly squeezed out).
• The controlling expression, and the case labels, of a switch may have any integral type.

 
 0 octal constant 37, 193
Ox hexadecimal constant 37,193 + addition operator 41, 205 s,addressoperator 93,203 =assignment operator 17, 42, 208 += assignment operator 50
\ \ backslash character 8, 38 &.bitwise AND operator 48, 207
A bitwise exclusive OR operator
: bitwise inclusive OR operator
, comma operator 62, 209 ?:conditionalexpression51,208 •.• declaration 155, 202
-- decrement operator 18, 46, 106, 203 / division operator 10, 41, 205 ==equality operator 19,41, 207 >=greaterorequaloperator41,206
> greater than operator 41, 206
++ increment operator 18, 46, 106, 203 * indirection operator 94, 203
I = inequality operator 16, 41, 207
« left shift operator 49, 206
<= less or equal operator 41, 206
< less than operator 41, 206 &.&.logicalAND operator 21, 41, 49, 207
I logical negation operator 42, 203-204 : : logical OR operator 21,41, 49, 208
" modulus operator 41, 205
* multiplication operator 41, 205
- one's complement operator 49, 203-204 # preprocessor operator 90, 230
## preprocessor operator 90, 230
, quote character 19, 37-38, 193
" quote character 8, 20, 38, 194
» right shift operator 49, 206
• structure member operator 128, 201
-> structure pointer operator 131, 201
- subtraction operator 41, 205
- unary minus operator 203-204
+ unary plus operator 203-204
_ underscore character 35, 192, 241
\0 null character 30, 38, 193
\a alert character 38, 193 abort library function 252
Index
abs library function 253
abstract declarator no
access mode, file 160, 178, 242 acoslibraryfunction 251
actual argument see argument
addition operator, + 41, 205
additive operators 205
addpoint function 130
address arithmetic see pointer arithmetic address of register 210
address of variable 28, 94, 203 addressoperator,&.93,203 addtree function )41
afree function 102
alert character, \a 38, 193
alignment, bit-field 150, 213 alignmentbyunion186
alignment restriction 138, 142, 148,167, 185,
199
alloc function 101
allocator, storage 142, 185-189
ambiguity, if-else 56, 223, 234
American National Standards Institute (ANSI)
ix, 2, 191 a.out 6,70
argc argument count 114
argument, definition of 25, 201
argument, function 25, 202
argument list, variable length 155, 174, 202,
218, 225, 254
argument list, void 33, 73, 218, 225 argument, pointer 100
argument promotion 45, 202
argument, subarray 100
arguments, command-line 114-118
argv argument vector 114, 163
arithmetic conversions, usual 42, 198 arithmetic operators 41
arithmetic, pointer 94, 98, 100-103, 117, 138,
205
arithmetic types 196
array, character 20, 28, 104
array declaration 22, III, 216
array declarator 216
array initialization 86, 113, 219
array, initialization of two-dimensional 112,
220
48, 207 48, 207
263

 264 THE C PROGRAMMING LANGUAGE
INDEX
array, multi-dimensional 110, 217 array name argument 28, 100, 112 array name, conversion of 99, 200 array of pointers 107
array reference 201
array size, default 86, 113, 133
array, storage order of 112, 217
array subscripting 22,97,201,217
array, two-dimensional 110, 112, 220 arrayvs.pointer97,99-100,104,113 arrays of structures 132
ASCII character set 19, 37, 43, 229, 249 asctime library function 256
asin library function 251
asm keyword 192
<assert. h> header 253
assignment, conversion by 44, 208 assignment expression 17, 21, 51, 208 assignment, multiple 21
assignment operator, = 17,42,208 assignment operator, += 50
assignment operators 42, 50, 208 assignment statement, nested 17, 21, 51 assignment suppression, scanf 157, 245 associativity of operators 52, 200
atan, atan2 library functions 251
atexi t library function 253
atof function 71
atof library function 251
atoi function 43, 61, 73
atoi library function 251
atol library function 251
auto storage class specifier 210
automatic storage class 31, 195
automatic variable 31, 74, 195
automatics, initialization of 31, 40, 85, 219 automatics, scope of 80, 228
avoiding goto 66
\b backspace character 8, 38, 193 backslash character, \ \ 8, 38
bell character see alert character binary stream 160, 241-242
buffering see setbuf, setvbuf BUFSIZ 243
calculator program 72, 74, 76, 158 call by reference 27
call by value 27, 95, 202
calloc library function 167, 252 canonrect function 131 carriagereturncharacter,\r38,193 case label 58, 222
cast, conversion by 45, 198-199, 205
cast operator 45, 142, 167, 198,205,220 cat program 160, 162-163
cc command 6, 70
ceil library function 251
char type 10, 36, 195, 211
character array 20, 28, 104
character constant 19, 37, 193
character constant, octal 37
character constant, wide 193
character count program 18
character input/output 15, 151
character set 229
character set, ASCII 19,37,43,229,249 character set, EBCDIC 43
character set, ISO 229
character, signed 44, 195
character string see string constant character testing functions 166, 248 character, unsigned 44, 195 character-integer conversion 23, 42, 197 characters, white space 157, 166, 245, 249 clearerr library function 248
CLOCKS PER SEC 255
clock library-function 255
clock_ t type name 255
close system call 174
closedir function 184
coercion see cast
comma operator, , 62, 209
command-line arguments 114-118 comment 9, 191-192, 229
comparison, pointer 102, 138, 187, 207 compilation, separate 67, 80, 227 compiling a C program 6, 25
compiling multiple files 70
compound statement 55, 84, 222, 225-226 concatenation, string 38, 90, 194 concatenation, token 90, 230
conditional compilation 91, 231 conditionalexpression,?:51,208
binary tree 139
binsearch function 58, 134, 137
bit manipulation idioms 49, 149
bitcount function 50
bit-field alignment 150, 213
bit-field declaration 150, 212
bitwise AND operator, s, 48, 207
bitwiseexclusiveORoperator,A 48,207
bitwiseinclusiveORoperator,I48,207 constqualifier40,196,'211
bitwise operators 48, 207 block see compound statement block, initialization in 84, 223 block structure 55, 84, 223 boundary condition 19, 65 braces 7, 10, 55, 84
braces, position of 10
break statement 59, 64, 224 bsearch library function 253 buffered getchar 172 buffered input 170
constant expression 38, 58, 91, 209 constant, manifest 230
constant suffix 37, 193
constant, type of 37, 193
constants 37, 192
continue statement 65, 224 control character 249
control line 88, 229-233
conversion 197-199
conversion by assignment 44, 208 conversion by cast 45, 198-199, 205

 THE C PROGRAMMING LANGUAGE
INDEX 265
conversion by return 73, 225
conversion, character-integer 23, 42, 197
conversion, double-f loa t 45, 198
conversion, float-double 44, 198
conversion,floating-integer45,197 difftimelibraryfunction256
conversion, integer-character
conversion, integer-floating
conversion, integer-pointer
conversion of array name 99, 200 conversion of function 200 conversionoperator, explicit seecast conversion,pointer 142,198,205 conversion, pointer-integer 198-199, 205
DIR structure 180
dirdcl function 1].4
directory list program 179 Dirent structure 180
dir .h include file 183
dirwalk function 182 divlibraryfunction 253
division, integer 10, 41
division operator, / 10, 41, 205 div_t,ldiv_ttypenames 253 do statement 63, 224
do-nothing function 70
double constant 37, 194
double type 10, 18,36, 196, 211 double-float conversion 45,198
conversions, usual arithmetic copyfunction 29,33
cos library function 251 cosh library function 251 crea t system call 172 CRLF 151, 241
ctime library function 256 <ctype .h> header 43, 248
42, 198
45 12, 197
199, 205
E notation 37, 194 dateconversionIII EBCDICcharacterset43
day_of_yearfunction III
dcl function 123
dcl program 125
declaration 9, 40, 210-218
declaration, array 22, Ill, 216
declaration, bit-field 150, 212
declaration, external 225-226
declaration of external variable 31, 225 declaration of function 217-218
declaration of function, implicit 27, 72, 201 declaration of pointer 94, 100, 216 declaration, storage class 210
declaration, structure 128, 212 declaration, type 216
declaration, type'def 146, 210, 221 declaration, union 147, 212 declaration vs. definition 33, 80, 210 declarator 215-218
declarator, abstract 220
declarator, array 216
declarator, function 217
decrement operator, -- 18,46, 106, 203 default array size 86, 113, 133
default function type 30, 201
default initialization 86, 219
defaul t label 58, 222
defensive programming
#define 14,89,229
#define, multi-line 89
#define vs. enum 39, 149
#define with arguments 89
defined preprocessor operator 91,232 definition, function 25, 69, 225 definition, macro 229
definition of argument 25, 201 definition of external variable 33, 227 definition of parameter 25, 201 definition of storage 210 definition,removalofsee#undef definition, tentative 227
echoprogram 115-116
EDOM 250
efficiency 51, 83, 88, 142, 187 else see if-else statement #else, #elif 91,232
else-if 23, 57
empty function 70
empty statement see null statement
empty string 38
end of file see EOF
#endif 91
enumspecifier 39, 215
enumvs. #define 39, 149
enumeration constant 39,91, 193-194,215 enumeration tag 215
enumeration type 196
enumerator 194, 215
EOF 16, 151,242
equality operator, == 19,41,207
equality operators. 41, 207
equivalence, type 221
ERANGE 250
errno 248, 250
<errno .h> header 248
#error 233
error function 174
errors, input/output 164, 248
escape sequence 8, 19, 37-38, 193, 229 escape sequence, \x hexadecimal 37, 193 escape sequences, table of 38, 193
evaluation, order of 21, 49, 53, 63, 77, 90, 95,
200
exceptions 200, 255
exit library function 163,252
EXIT FAILURE, EXIT SUCCESS 252 exp library function 251
expansion, macro 230
explicit conversion operator see cast exponentiation24,251
expression 200-209
57, 59
dereference see indirection derived types 1, 10, 196 descriptor, file 170 designator, function 201

 266 THE C PROGRAMMING LANGUAGE expression, assignment 17, 21, 51, 208
expression, constant 38, 58, 91, 209 expression order of evaluation 52, 200 expression, parenthesized 201 expression, primary 200
expression statement 55, 57, 222
extern storage class specifier 31, 33, 80, 210 external declaration 225-226
external linkage 73,192,195,211,228
external names, length of 35, 192
external static variables 83
external variable 31, 73, 195
external variable, declaration of 31, 225 external variable, definition of 33, 227 externals, initialization of 40, 81, 85, 219 externals, scope of 80, 228
\f formfeed character 38, 193 fabs library function 251
f c Loae library function 162, 242 f cntl. h include file 172
f eof library function 164, 248 feof macro 176
ferror library function 164, 248 ferror macro 176
fflush library function 242
fgetc library function 246 fgetpos library function 248 fgets function 165
fgets library function 164, 247 field see bit-field
file access 160, 169, 178, 242
file access mode 160, 178, 242
file appending 160, 175, 242
file concatenation program 160 file copy program 16-17, 171, 173 file creation 161, 169
file descriptor 170
file inclusion 88, 231
file opening 160, 169, 172
file permissions 173
file pointer 160, 175, 242
__ FILE __ preprocessor name 254 FILE type name 160
filecopy function 162
filename suffix, •h 33 FILENAME MAX 242
f i llbuf -function 178
float constant 37, 194
float type 9,36, 196, 211 float-double conversion 44, 198 <float. h> header 36, 257 floating constant 12, 37, 194 floating point, truncation of 45, 197 floating types 196
floating-integer conversion 45, 197 floor library function 251
fmod library function 251
f open function 177
fopen library function 160, 242 FOPEN MAX 242
for ( ; -;) infinite loop 60, 89
for statement 13, 18,60,224
INDEX
for vs. while
formal parameter
formatted input see scanf
formatted output see printf
formfeed character, \f 38, 193
fortran keyword t 92
fpos_ t type name 248
fprintf library function 161, 243
fputc library function 247
fputs function 165
fputs library function 164, 247
fread library function 247
free function 188
free library function 167, 252
freopen library function 162, 242
frexp library function 251
fscanf library function 161, 245
f seek library function 248
fsetpos library function 248
fsize function 182
fsize program 181
fstat system call ) 83
ftelllibrary function 248
function argument 25, 202
function argument conversion see argument
promotion
function call semantics 201
function call syntax 201
function, conversion of 200
function, declaration of 217-218
function declaration, static 83
function declarator 217
function definition 25, 69, 225
function designator 201
function, implicit declaration of 27, 72, 201 function names, length of 35, 192
function, new-style 202
function, old-style 26, 33, 72, 202
function, pointer to 118, 147, 201
function prototype 26, 30, 45, 72, 120, 202 function type, default 30, 201
functions, character testing 166, 248 fundamental types 9, 36, 195
fwri te library function 247
generic pointer see void * pointer getbi ts function 49
getc library function 161, 247 getc macro 176
14, 60
see parameter
getch
getchar,
getchar
getchar,
getenv library function 253 getint function 97
get line function 29, 32, 69, 165 getop function 78
gets library function 164, 247 get token function 125
getword function 136
gmtime library function 256
goto statement 65, 224
greater or equal operator, >= 41, 206
function 79 buffered 172
library function 15, 151, 161, 247 unbuffered 171

 THE C PROGRAMMINGLANGUAGE greater than operator, > 41, 206
•h filename suffix 33
hash function 144
hash table 144
header file 33, 82
headers, table of standard hexadecimal constant, Ox... 37, 193
INDEX 267
internal linkage 195, 228
internal names, length of 35, 192 internal static variables 83
IOFBF, IOLBF, IONBF 243
136, 249
136, 166, 249 249
166, 249
249
166, 249
241
hexadecimal escape sequence, \x Hoare, C. A. R. 87
HUGE_ VAL 250
37, 193
function function function function function function
identifier 192
#if 91, 135,231
#ifdef 91, 232
if-else ambiguity
if-else statement 19,21, 55, 223
#ifndef 91, 232
illegal pointer arithmetic 102-103, 138, 205 implicit declaration of function 27, 72, 201 #inc1ude 33,88,152,231
incomplete type 212
inconsistent type declaration 72
increment operator, ++ 18, 46, 106, 203 indentation 10, 19,23,56
indirection operator, * 94, 203
inequality operator, 1= 16,41, 207
infinite loop, for ( ; ;) 60, 89
information hiding 67-68, 75, 77 initialization 40, 85, 218
initialization, array 86, 113, 219 initialization by string constant 86, 219 initialization, default 86, 219
initialization in block 84, 223
initialization of automatics 31, 40, 85, 219 initialization of externals 40, 81, 85, 219 initialization of statics 40, 85, 219 initialization of structure arrays 133 initialization of two-dimensional array 112,
220
initialization, pointer 102, 138
initialization, structure initialization, union 219 initializer 227
initializer, form of 85, 209 inode 179
input, buffered 170
input, formatted see scanf
input, keyboard 15, 151, 170
input pushback 78
input, unbuffered 170
input/output, character
input/output errors 164, 248 input/output redirection 152, 161, 170 install function 145
int type 9, 36, 211
integer constant 12, 37, 193 integer-character conversion 45 integer-floating conversion 12, 197 integer-pointer conversion 199, 205 integral promotion 44, 197
integral types 196
i toa function 64 jump statements 224
56, 223, 234
128, 219
15, 151
isa1num library isa1pha library iscntr1library
isdigi t library isgraph library
Ls Lowe r library
ISO character set 229
library
library
library
library function
249
249
136, 166,249 166, 249
keyboard input 15,151,170 keyword count program 133 keywords, list of 192
label 65, 222
label, case 58, 222
label, default 58, 222
label, scope of 66, 222, 228
labeled statement 65, 222
labs library function 253
%ld conversion 18
1dexp library function 251
1di v library function 253
leap year computation 41, III
left shift operator, « 49, 206
length of names 35, 192
length of string 30, 38, 104
length of variable names 192
less or equal operator, <= 41, 206
less than operator, < 41, 206
lexical conventions 191
lexical scope 227
lexicographic sorting 118
library function 7, 67, 80
<limi ts. h> header 36, 257
#line 233
line count program 19
__LINE__ preprocessor name 254
line splicing 229
linkage 195, 227-228
linkage, external 73, 192, 195,211,228 linkage, internal 195, 228
list directory program 179
list of keywords 192
locale issues 241
<locale. h> header 241
local time library function 256
log, log 10 library functions 251 logical AND operator, as, 21, 41, 49,207 logical expression, numeric value of 44
isprint
ispunct
isspace
isupper
isxdigi t library function 249 iteration statements 224
function function function

 268 THE C PROGRAMMING LANGUAGE
INDEX
logical negation operator, I 42, 203-204 logical OR operator, I J 21, 41, 49, 208 long constant 37, 193
long double constant 37,194
long double type 36, 196
long type 10, 18, 36, ·196,211 longest-line program 29, 32 longjmp library function 254 LONG MAX, LONG MIN 252 lookup function 145
loop see while, for, do
lower case conversion program 153 lower function 43
1 s command 179
lseek system call 174
Ivalue 197
macro preprocessor 88, 228-233
macros with arguments
magic numbers 14
main function 6
main, return from 26, 164 makepoint function 130
malloc function 187
malloc library function 143, 167, 252 manifest constant 230
<math. h> header 44, 250
member name, structure 128, 213 memchr library function 250 memcmplibrary function 250 memcpylibrary function 250 memmovelibrary function 250
memset library function 250
missing storage class specifier 211
missing type specifier 211
mktime library function 256
modf library function 251
modularization 24, 28, 34, 67, 74-75, 108 modulus operator," 41, 205
month_ day function III
month name function 113
morecore function 188
multi-dimensional array 110, 217
multiple assignment 21
multiple files, compiling 70
multiplication operator, * 41, 205 multiplicative operators 205
multi-way decision 23, 57
mutually recursive structures 140, 213
\n newline character 7, IS, 20, 37-38, 193, 241
new-style function 202
NULL 102
null character, \0 30, 38, 193
null pointer 102, 198
null statement 18, 222
null string 38
numbers, size of 9, 18, 36, 257 numcmpfunction 121
numeric sorting 118
numeric value of logical expression 44 numeric value of relational expression 42, 44
object 195, 197
octal character constant 37
octal constant, 0... 37, 193
old-stylefunction 26,33,n,202
one's complement operator, - 49, 203-204 open system call 1n
opendir function )83
operations on unions 148
operations permitted on pointers 103 operators, additive 205
operators, arithmetic 41
operators, assignment 42, 50, 208
operators, associativity of 52, 200
operators, bitwise 48, 207
operators, equality 41, 207
operators, multiplicative 205
operators, precedence of 17,52,95, 131-132,
200
operators, relational 16, 41, 206
operators, shift 48, 206
operators, table of 53
order of evaluation 21, 49, 53, 63, 77, 90, 95,
200
order of translation 228 O_RDONLY,O_RD~O_WRONLY 172 output, formatted see printf
output redirection 152
output, screen 15, 152, 163, 170 overflow 41, 200, 250, 255
parameter 84, 99, 202
parameter, definition of 25, 201
parenthesized expression 201
parse tree 123
parser, recursive-descent 123
pattern finding program 67, 69, 116-117 permissions, file 173
perror library function 248
phases, translation 191, 228
pipe 152, 170
pointer argument 100
pointer arithmetic 94, 98, 100-103, 117, 138,
205
pointer arithmetic, illegal 102-103, 138, 205 pointer arithmetic, scaling in 103, 198 pointer comparison 102, 138, 187, 207 pointer conversion 142,. 198, 205
pointer, declaration of 94, 100, 216
pointer, file 160, 175, 242
pointer generation 200
name 192
name hiding 84
name space 227
names, length of 35, 192
negative subscripts 100
nested assignment statement
nested structure 129
newline 191, 229
newline character, \n 7, IS, 20, 37-38, 193,
241
89
17, 21, 51

 THE C PROGRAMMING LANGUAGE
INDEX 269
pointer initialization 102, 138 pointer, null 102, 198
pointer subtraction 103, 138, 198 pointer to function 118, 147, 201 pointer to structure 136
pointer, void * 93, 103, 120, 199
pointer vs. array 97, 99-100, 104, 113
pointer-integer conversion 198-199, 205
pointers and subscripts 97, 99, 217
pointers, array of 107
pointers, operations permitted on 103
Polish notation 74
pop function 77
portability 3, 37,43,49, 147, 151, 153, 185
position of braces 10
postfix ++ and - - 46, 105
pow library function 24, 2S 1
powerfunction25,27 \rcarriagereturncharacter38,193
#pragma 233
precedence of operators 17, 52, 95, 131-132,
200
prefix ++ and - _ 46, 106 preprocessor, macro 88, 228~233
raise library function 255 rand function 46
rand library function 252 RAND MAX 252
read system call 170
preprocessor preprocessor preprocessor preprocessor preprocessor preprocessor
primary expression 200
name, __ FILE__ 254 name, __ LINE__ 254 names, predefined 233 operator, # 90, 230 operator, ## 90, 230
readdir
readlines
realloc
recursion 86, 139, 141, 182, 202, 269 recursive-descent parser 123 redirection see input/output redirection register, address of 210
register storage class specifier 83, 210 relational expression, numeric value of 42, 44 relational operators 16, 41, 206
removal of definition see #undef
remove library function 242
rename library function 242 reservation of storage 210
reserved words 36, 192
return from main 26, 164
return statement 25, 30, 70, 73, 225 return, type conversion by 73, 225 reverse function 62
operator, defined
91, 232
printd
printf
printf
printf
printing character 249
program arguments see command-line
arguments
program, calculator 72, 74, 76, 158
program, cat 160, 162-163
program, character count 18
program, dcl 125
program, echo 115-:116
program, file concatenation 160
program, file copy 16-17, 171, 173
program format 10, 19, 23, 40, 138, 191 program, fsize 181
program, keyword count 133
program, line count 19
program, list directory 179
program, longest-line 29, 32
program, lower case conversion 153
program, pattern finding 67, 69, 116-117 program readability 10, 51, 64, 86, 147 program, sorting 108, 119
program, table lookup 143
program, temperature conversion 8-9, 12-13,
15
program, undcl 126
program, white space count 22, 59 program, word count 20, 139
promotion, argument 45, 202
promotion, integral 44, 197
prototype, function 26, 30, 45, 72, 120, 202 ptinrect function 130
function 87
conversions, table of 154, 244 examples, table of 13, 154
library function 7, 11, 18, 153, 244
ptrdiff_ t type name 103, 147, 206 push function 77
pushback, input 78
putc library function 161, 247
putc macro 176
putchar library function 15, 152, 161,247 puts library function 164, 247
qsort function 87, 110, 120 qsort library function 253 qualifier, type 208, 211 quicksort 87, 110
quote character,' 19, 37-38, 193 quote character, " 8, 20, 38, 194
function 184 function 109
library function 252
reverse Polish notation 74 rewind library function 248 Richards, M. 1
right shift operator,»
Ritchie, D. M. xi
sbrk system call 187
scaling in pointer arithmetic 103, 198 scanf assignment suppression 157, 245 scanf conversions, table of 158, 246 scanf library function 96, 157, 246 scientific notation 37, 73
scope 195, 227-228
scope, lexical 227
scope of automatics 80, 228
scope of externals 80, 228
scope of label 66, 222, 228
scope rules 80, 227
screen output 15, 152, 163, 170 SEEK_C~ SEEK_END,SEEK_SET 248 selection statement 223
49, 206

 270 THE C PROGRAMMING LANGUAGE
INDEX
self-referential structure 140, 213 semicolon 10, 15, 18, 55, 57 separate compilation 67, 80, 227 sequencing of statements 222 set):)uf library function 243 setjmp library function 254 <setjmp.h> header 254 setvj:)uf library function 243 Shell, D. L. 61
shellsort function 62
shift operators 48, 206
short type 10, 36, 196, 211
side effects 53, 90, 200, 202 SIG_DFL,SIG_E~ SIG_IGN 255 sign extension 44-45, 177, 193 signal library function 255 <signal. h> header 255
signed character 44, 195 signed type 36, 211
sin library function 251 sinh library function 251
<stddef . h> header 103, 135, 241
size of numbers
size of structure
sizeofoperator
size_t type name 103, 135, 147,204, 242 sorting, lexicographic 118
sorting, numeric 118
sorting program 108, 119
sorting text lines 107, 119
specifier, auto storage class 210
specifier, enum 39, 215
specifier, extern storage class 31, 33, 80,
210
specifier, missing storage class 211 specifier, register storage class 83, 210 specifier, static storage class 83, 210 specifier, storage class 210
specifier, struct 212
specifier, type 211
specifier, union 212
splicing, line 229
sprintf library function 155, 245 sqrt library function 251
squeeze function 47
srand function 46
srand library function 252 sscanf library function 246 standard error 161, 170 standard headers, table of 241 standard input 151,161, 170 standard output 152, 161, 170 stat structure 180
stat system call 180 statement terminator 10, 55 statements 222-225 statements, sequencing of 222 stat. h include file 180-181
9, 18, 36, 257 138, 204
static
static
static
static
static
statics, initialization of 40, 85, 219 <stdarg. h> header 155, 174, 254
function declaration storage class 31, 83, 19)
91,103,135,203-204,247
strcat strcat strchr strcmp strcmp strcpy strcpy strcspn
function 48
library function 249 library function 249 function 106
library function 249 function 105-106 library function 249
storage class specifier 83, 210 variables, external 83 variables, internal 83
83
stderr
stdin
<stdio.
<stdio. h> header 6, 16, 89-90, 102,
151-152,241
<stdlib. h> header 71, 142, 251 stdout 161, 242
storage allocator 142, 185-189
storage class 195
storage class, automatic 31, 195
storage class declaration 210
storage class specifier 210
storage class specifier, auto 210
storage class specifier, extern 31, 33, 80,
210
storage class specifier, missing 211 storage class specifier, register storage class specifier, static storage class, static 31, 83, 195 storage, definition of 210
storage order of array 112, 217 storage, reservation of 210
161, 163, 242 161, 242
h> contents 176
library function 250 stream, binary 160, 241-242
stream, text 15, 151, 241
strerror
strftime
strindex
string concatenation 38, 90, 194
string constant 7, 20, 30, 38,99, 104, 194 string constant, initialization by 86, 219
string constant, wide 194 string, length of 30, 38, 104 string literal see string constant string, type of 200
<string. h> header 39, 106, 249 strlen function 39, 99, 103 strlen library function 250 strnca t library function 249 strncmp library function 249
library function 250 library function 256 function 69
strncpy
strpbrk
strrchr
strspn library function 250
strstr library function 250
strtod library function 251
strtok library function 250
strtol, strtoul library functions 252 struct specifier 212
structure arrays, initialization of 133 structure declaration 128, 212
structure initialization 128, 219 structure member name 128, 213 structure member operator, 128, 201 structure, nested 129
structure pointer operator, _> 131, 201
library function 249 library function 250 library function 249
83, 210 83, 210

 THE C PROGRAMMING LANGUAGE
INDEX 271
structure, pointer to 136
structure reference semantics 202 structure reference syntax 202
trigraph sequence 229
trim function 65
truncation by division 10, 41, 205
truncation of floating point 45, 197 two-dimensional array 110, 112, 220 two-dimensional array, initialization of 112,
220
type conversion by return 73, 225 type conversion operator see cast type conversion rules 42, 44, 198 type declaration 216
type declaration, inconsistent 72 type equivalence 221
type, incomplete 212
type names 220 typeofconstant37,193 typeofstring 200
type qualifier 208, 211
type specifier 211
type specifier, missing 211
typedef declaration 146, 210, 221 types, arithmetic 196
types, derived I, 10, 196
types, floating 196
types, fundamental 9, 36, 195
structure, self-referential structure, size of 138, 204 structure tag 128, 212 structures, arrays of 132
140, 213
structures, mutually
subarray argument
subscripting, array
subscripts and pointers 97, 99, 217 subscripts, negative 100
subtraction operator, - 41, 205 subtraction, pointer 103, 138, 198 suffix, constant 193 swapfunction88,96,110,121 switch statement 58, 75, 223 symbolic constants, length of 35 syntax notation 194
syntax of variable names 35, 192 syscalls. h include file 171 system calls 169
system library function 167, 253
recursive
140, 213 22, 97, 201, 217
100
\ttabcharacter8,11,38,193 types,integral196
table lookup program 143
table of escape sequences 38, 193
table of operators 53
table of printf conversions 154, 244
table of printf examples 13, 154
table of scanf conversions 158, 246
table of standard headers 241
tag, enumeration 215
tag, structure 128, 212
tag, union 212
talloc function 142
tan library function 251
tanh library function 251
temperature conversion program 8-9, 12-13,
15
tentative definition 227
terminal input and output 15 termination, program 162, 164
text lines, sorting 107, 119
text stream 15, 151, 241
Thompson, K. L. 1
time library function. 256 <time.h>header255 time_ttypename255 tmpfilelibraryfunction243
TMP MAX 243 tmpnamlibraryfunction243
token 191, 229
token concatenation 90, 230
token replacement 229
tolower library function 153, 166, 249 toupper library function 166, 249 translation, order of 228
translation phases 191, 228
translation unit 191, 225, 227
tree, binary 139
tree, parse 123
treeprint function 142
types.h include file 181,183
ULONG MAX 252
unary minus operator, _ 203-204 unary plus operator, + 203-204 unbuffered getchar 171 unbuffered input 170
undcl program 126
lundef 90,172,230
underflow 41, 250, 255
underscore character, _ 35, 192,241 ungetc library function 166, 247 ungetch function 79
union, alignment by 186
union declaration 147, 212
union initialization 219
union specifier 212
union tag 212
unions, operations on 148
UNIX file system 169, 179
unl ink system call 174 unsignedchartype36,171 unsignedcharacter44,195 unsignedconstant37,193 unsigned long constant 37,193 unsignedtype36,50,196,211 usual arithmetic conversions 42, 198
\v vertical tab character 38, 193 va_list, va_start,va_arg, va_end
155, 174, 245, 254 variable 195
variable, address of 28, 94, 203
variable, automatic 31, 74, 195
variable, external 31, 73, 195
variable length argument list 155, 174, 202,
218, 225, 2~4

 272 THE C PROGRAMMING LANGUAGE INDEX
variable names, length of 192 variable names, syntax of 35, 192 vertical tab character, \v 38, 193 void * pointer 93, 103, 120, 199 void argument list 33, 73, 218, 225
void type volatile vprintf,
30, 196, 199,211 qualifier 196, 211
vfprintf, vsprintf library functions 174, 245
wchar _t type name 193
while
while
white
white
white
wide character constant 193 wide string constant 194 word count program 20, 139 wri te system call 170 writelines function 109
\x hexadecimal escape sequence 37, 193 zero, omitted test against 56, 105
statement 10, 60, 224
vs.for 14,60
space 191
space characters 157, 166, 245, 249 space count program 22, 59

 
 The C Programming Language Second Edition
Brian W. Kernighan/Dennis M. Ritchie
From the Preface
We have tried to retain the brevity of the first edition. C is not a big language, and it is not well served by a big book. We have improved the exposition of critical features, such as pointers, that are central to C programming. We have refined the original examples, and have added new examples in several chapters. For instance, the treatment of complicated declarations is augmented by programs that convert declarations into words and vice versa. As before, all examples have been tested directly from the text, which is in machine-readable form.
As we said in the preface to the first edition, C "wears well as one's experience with it grows." With a decade more experience, we still feel that way. We hope that this book will help you to learn C and use it well.
PRENTICE HALL, Englewood Cliffs, N.J. 07632
ISBN 0-13-110362-8
